dot.junit.opcodes.add_double_2addr.Main_testB1;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_1 ;add-double/2addr;Boundary #1;Arguments = Double.MAX_VALUE, Double.NaN
dot.junit.opcodes.add_double_2addr.Main_testB2;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_1 ;add-double/2addr;Boundary #2;Arguments = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
dot.junit.opcodes.add_double_2addr.Main_testB3;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_1 ;add-double/2addr;Boundary #3;Arguments = Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY
dot.junit.opcodes.add_double_2addr.Main_testB4;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_1 ;add-double/2addr;Boundary #4;Arguments = Double.POSITIVE_INFINITY, -2.7d
dot.junit.opcodes.add_double_2addr.Main_testB5;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_1 ;add-double/2addr;Boundary #5;Arguments = +0, -0
dot.junit.opcodes.add_double_2addr.Main_testB6;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_1 ;add-double/2addr;Boundary #6;Arguments = -0d, -0d
dot.junit.opcodes.add_double_2addr.Main_testB7;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_1 ;add-double/2addr;Boundary #7;Arguments = -2.7d, 2.7d
dot.junit.opcodes.add_double_2addr.Main_testB8;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_1 ;add-double/2addr;Boundary #8;Arguments = Double.MAX_VALUE, Double.MAX_VALUE
dot.junit.opcodes.add_double_2addr.Main_testB9;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_1 ;add-double/2addr;Boundary #9;Arguments = Double.MIN_VALUE, -4.9E-324
dot.junit.opcodes.add_double_2addr.Main_testN1;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_1 ;add-double/2addr;Normal #1;Arguments = 2.7d, 3.14d
dot.junit.opcodes.add_double_2addr.Main_testN2;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_1 ;add-double/2addr;Normal #2;Arguments = 0, -3.14d
dot.junit.opcodes.add_double_2addr.Main_testN3;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_1 ;add-double/2addr;Normal #3;Arguments = -3.14d, -2.7d
dot.junit.opcodes.add_double_2addr.Main_testN4;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_3 ;add-double/2addr;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this sum of long and double makes no sense but shall not crash the VM.
dot.junit.opcodes.add_double_2addr.Main_testVFE1;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_2 ;add-double/2addr;Verifier #1; Constraint B1, types of arguments - float, double
dot.junit.opcodes.add_double_2addr.Main_testVFE2;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_4 ;add-double/2addr;Verifier #2; Constraint B1, types of arguments - double, reference
dot.junit.opcodes.add_double_2addr.Main_testVFE3;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_6 ;add-double/2addr;Verifier #3; Constraint A24, number of registers
dot.junit.opcodes.add_double_2addr.Main_testVFE4;dot.junit.opcodes.add_double_2addr.d.T_add_double_2addr_4 ;add-double/2addr;Verifier #4; Constraint B1, types of arguments - double, reference
dot.junit.opcodes.add_double.Main_testB1;dot.junit.opcodes.add_double.d.T_add_double_1 ;add-double;Boundary #1;Arguments = Double.MAX_VALUE, Double.NaN
dot.junit.opcodes.add_double.Main_testB2;dot.junit.opcodes.add_double.d.T_add_double_1 ;add-double;Boundary #2;Arguments = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
dot.junit.opcodes.add_double.Main_testB3;dot.junit.opcodes.add_double.d.T_add_double_1 ;add-double;Boundary #3;Arguments = Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY
dot.junit.opcodes.add_double.Main_testB4;dot.junit.opcodes.add_double.d.T_add_double_1 ;add-double;Boundary #4;Arguments = Double.POSITIVE_INFINITY, -2.7d
dot.junit.opcodes.add_double.Main_testB5;dot.junit.opcodes.add_double.d.T_add_double_1 ;add-double;Boundary #5;Arguments = +0, -0
dot.junit.opcodes.add_double.Main_testB6;dot.junit.opcodes.add_double.d.T_add_double_1 ;add-double;Boundary #6;Arguments = -0d, -0d
dot.junit.opcodes.add_double.Main_testB7;dot.junit.opcodes.add_double.d.T_add_double_1 ;add-double;Boundary #7;Arguments = -2.7d, 2.7d
dot.junit.opcodes.add_double.Main_testB8;dot.junit.opcodes.add_double.d.T_add_double_1 ;add-double;Boundary #8;Arguments = Double.MAX_VALUE, Double.MAX_VALUE
dot.junit.opcodes.add_double.Main_testB9;dot.junit.opcodes.add_double.d.T_add_double_1 ;add-double;Boundary #9;Arguments = Double.MIN_VALUE, -4.9E-324
dot.junit.opcodes.add_double.Main_testN1;dot.junit.opcodes.add_double.d.T_add_double_1 ;add-double;Normal #1;Arguments = 2.7d, 3.14d
dot.junit.opcodes.add_double.Main_testN2;dot.junit.opcodes.add_double.d.T_add_double_1 ;add-double;Normal #2;Arguments = 0, -3.14d
dot.junit.opcodes.add_double.Main_testN3;dot.junit.opcodes.add_double.d.T_add_double_1 dot.junit.opcodes.add_double.d.T_add_double_3 dot.junit.opcodes.add_double.d.T_add_double_2 ;add-double;Normal #3;Arguments = -3.14d, -2.7d
dot.junit.opcodes.add_double.Main_testN4;dot.junit.opcodes.add_double.d.T_add_double_3 ;add-double;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this sum of long and double makes no sense but shall not crash the VM.
dot.junit.opcodes.add_double.Main_testVFE1;dot.junit.opcodes.add_double.d.T_add_double_2 ;add-double;Verifier #1; Constraint B1, types of arguments - float, double
dot.junit.opcodes.add_double.Main_testVFE2;dot.junit.opcodes.add_double.d.T_add_double_4 ;add-double;Verifier #2; Constraint B1, types of arguments - double, reference
dot.junit.opcodes.add_double.Main_testVFE3;dot.junit.opcodes.add_double.d.T_add_double_5 ;add-double;Verifier #3; Constraint A24, number of registers
dot.junit.opcodes.add_double.Main_testVFE4;dot.junit.opcodes.add_double.d.T_add_double_6 ;add-double;Verifier #4; Constraint B1, types of arguments - int, int
dot.junit.opcodes.add_float_2addr.Main_testB1;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_1 ;add-float/2addr;Boundary #1;Arguments = Float.MAX_VALUE, Float.NaN
dot.junit.opcodes.add_float_2addr.Main_testB2;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_1 ;add-float/2addr;Boundary #2;Arguments = Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY
dot.junit.opcodes.add_float_2addr.Main_testB3;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_1 ;add-float/2addr;Boundary #3;Arguments = Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY
dot.junit.opcodes.add_float_2addr.Main_testB4;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_1 ;add-float/2addr;Boundary #4;Arguments = Float.POSITIVE_INFINITY, -2.7f
dot.junit.opcodes.add_float_2addr.Main_testB5;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_1 ;add-float/2addr;Boundary #5;Arguments = +0, -0f
dot.junit.opcodes.add_float_2addr.Main_testB6;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_1 ;add-float/2addr;Boundary #6;Arguments = -0f, -0f
dot.junit.opcodes.add_float_2addr.Main_testB7;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_1 ;add-float/2addr;Boundary #7;Arguments = -2.7f, 2.7f
dot.junit.opcodes.add_float_2addr.Main_testB8;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_1 ;add-float/2addr;Boundary #8;Arguments = Float.MAX_VALUE, Float.MAX_VALUE
dot.junit.opcodes.add_float_2addr.Main_testB9;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_1 ;add-float/2addr;Boundary #9;Arguments = Float.MIN_VALUE, -1.4E-45f
dot.junit.opcodes.add_float_2addr.Main_testN1;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_1 ;add-float/2addr;Normal #1;Arguments = 2.7f, 3.14f
dot.junit.opcodes.add_float_2addr.Main_testN2;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_1 ;add-float/2addr;Normal #2;Arguments = 0, -3.14f
dot.junit.opcodes.add_float_2addr.Main_testN3;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_1 ;add-float/2addr;Normal #3;Arguments = -3.14f, -2.7f
dot.junit.opcodes.add_float_2addr.Main_testN5;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_5 ;add-float/2addr;Normal #5;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this sum of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.add_float_2addr.Main_testVFE1;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_2 ;add-float/2addr;Verifier #1; Constraint B1, types of arguments - float, double
dot.junit.opcodes.add_float_2addr.Main_testVFE2;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_3 ;add-float/2addr;Verifier #2; Constraint B1, types of arguments - long, float
dot.junit.opcodes.add_float_2addr.Main_testVFE3;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_4 ;add-float/2addr;Verifier #3; Constraint B1, types of arguments - float, reference
dot.junit.opcodes.add_float_2addr.Main_testVFE4;dot.junit.opcodes.add_float_2addr.d.T_add_float_2addr_6 ;add-float/2addr;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.add_float.Main_testB1;dot.junit.opcodes.add_float.d.T_add_float_1 ;add-float;Boundary #1;Arguments = Float.MAX_VALUE, Float.NaN
dot.junit.opcodes.add_float.Main_testB2;dot.junit.opcodes.add_float.d.T_add_float_1 ;add-float;Boundary #2;Arguments = Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY
dot.junit.opcodes.add_float.Main_testB3;dot.junit.opcodes.add_float.d.T_add_float_1 ;add-float;Boundary #3;Arguments = Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY
dot.junit.opcodes.add_float.Main_testB4;dot.junit.opcodes.add_float.d.T_add_float_1 ;add-float;Boundary #4;Arguments = Float.POSITIVE_INFINITY, -2.7f
dot.junit.opcodes.add_float.Main_testB5;dot.junit.opcodes.add_float.d.T_add_float_1 ;add-float;Boundary #5;Arguments = +0, -0f
dot.junit.opcodes.add_float.Main_testB6;dot.junit.opcodes.add_float.d.T_add_float_1 ;add-float;Boundary #6;Arguments = -0f, -0f
dot.junit.opcodes.add_float.Main_testB7;dot.junit.opcodes.add_float.d.T_add_float_1 ;add-float;Boundary #7;Arguments = -2.7f, 2.7f
dot.junit.opcodes.add_float.Main_testB8;dot.junit.opcodes.add_float.d.T_add_float_1 ;add-float;Boundary #8;Arguments = Float.MAX_VALUE, Float.MAX_VALUE
dot.junit.opcodes.add_float.Main_testB9;dot.junit.opcodes.add_float.d.T_add_float_1 ;add-float;Boundary #9;Arguments = Float.MIN_VALUE, -1.4E-45f
dot.junit.opcodes.add_float.Main_testN1;dot.junit.opcodes.add_float.d.T_add_float_1 ;add-float;Normal #1;Arguments = 2.7f, 3.14f
dot.junit.opcodes.add_float.Main_testN2;dot.junit.opcodes.add_float.d.T_add_float_1 ;add-float;Normal #2;Arguments = 0, -3.14f
dot.junit.opcodes.add_float.Main_testN3;dot.junit.opcodes.add_float.d.T_add_float_1 ;add-float;Normal #3;Arguments = -3.14f, -2.7f
dot.junit.opcodes.add_float.Main_testN5;dot.junit.opcodes.add_float.d.T_add_float_5 ;add-float;Normal #5;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this sum of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.add_float.Main_testVFE1;dot.junit.opcodes.add_float.d.T_add_float_2 ;add-float;Verifier #1; Constraint B1, types of arguments - float, double
dot.junit.opcodes.add_float.Main_testVFE2;dot.junit.opcodes.add_float.d.T_add_float_3 ;add-float;Verifier #2; Constraint B1, types of arguments - long, float
dot.junit.opcodes.add_float.Main_testVFE3;dot.junit.opcodes.add_float.d.T_add_float_4 ;add-float;Verifier #3; Constraint B1, types of arguments - float, reference
dot.junit.opcodes.add_float.Main_testVFE4;dot.junit.opcodes.add_float.d.T_add_float_6 ;add-float;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.add_int_2addr.Main_testB1;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_1 ;add-int/2addr;Boundary #1;Arguments = 0, Integer.MAX_VALUE
dot.junit.opcodes.add_int_2addr.Main_testB2;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_1 ;add-int/2addr;Boundary #2;Arguments = Integer.MAX_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.add_int_2addr.Main_testB3;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_1 ;add-int/2addr;Boundary #3;Arguments = Integer.MAX_VALUE, 1
dot.junit.opcodes.add_int_2addr.Main_testB4;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_1 ;add-int/2addr;Boundary #4;Arguments = Integer.MIN_VALUE, 1
dot.junit.opcodes.add_int_2addr.Main_testB5;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_1 ;add-int/2addr;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.add_int_2addr.Main_testB6;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_1 ;add-int/2addr;Boundary #6;Arguments = Integer.MIN_VALUE, Integer.MIN_VALUE
dot.junit.opcodes.add_int_2addr.Main_testN1;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_1 ;add-int/2addr;Normal #1;Arguments = 8, 4
dot.junit.opcodes.add_int_2addr.Main_testN2;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_1 ;add-int/2addr;Normal #2;Arguments = 0, 255
dot.junit.opcodes.add_int_2addr.Main_testN3;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_1 ;add-int/2addr;Normal #3;Arguments = 0, -65536
dot.junit.opcodes.add_int_2addr.Main_testN4;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_1 ;add-int/2addr;Normal #4;Arguments = 0, -2147483647
dot.junit.opcodes.add_int_2addr.Main_testN5;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_1 ;add-int/2addr;Normal #5;Arguments = 0x7ffffffe, 2
dot.junit.opcodes.add_int_2addr.Main_testN6;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_1 ;add-int/2addr;Normal #6;Arguments = -1, 1
dot.junit.opcodes.add_int_2addr.Main_testN7;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_5 ;add-int/2addr;Normal #7;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this sum of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.add_int_2addr.Main_testVFE1;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_2 ;add-int/2addr;Verifier #1; Constraint B1, types of arguments - int, double
dot.junit.opcodes.add_int_2addr.Main_testVFE2;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_3 ;add-int/2addr;Verifier #2; Constraint B1, types of arguments - long, int
dot.junit.opcodes.add_int_2addr.Main_testVFE3;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_4 ;add-int/2addr;Verifier #3; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.add_int_2addr.Main_testVFE4;dot.junit.opcodes.add_int_2addr.d.T_add_int_2addr_6 ;add-int/2addr;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.add_int_lit16.Main_testB1;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_7 ;add-int/lit16;Boundary #1;Arguments = 0 + Short.MAX_VALUE
dot.junit.opcodes.add_int_lit16.Main_testB2;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_8 ;add-int/lit16;Boundary #2;Arguments = Integer.MAX_VALUE + Short.MAX_VALUE
dot.junit.opcodes.add_int_lit16.Main_testB3;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_9 ;add-int/lit16;Boundary #3;Arguments = Integer.MAX_VALUE + 1
dot.junit.opcodes.add_int_lit16.Main_testB4;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_10 ;add-int/lit16;Boundary #4;Arguments = Integer.MIN_VALUE + 1
dot.junit.opcodes.add_int_lit16.Main_testB5;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_11 ;add-int/lit16;Boundary #5;Arguments = 0 + 0
dot.junit.opcodes.add_int_lit16.Main_testB6;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_12 ;add-int/lit16;Boundary #6;Arguments = Short.MIN_VALUE + Short.MIN_VALUE
dot.junit.opcodes.add_int_lit16.Main_testN1;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_1 ;add-int/lit16;Normal #1;Arguments = 8 + 4
dot.junit.opcodes.add_int_lit16.Main_testN2;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_2 ;add-int/lit16;Normal #2;Arguments = 0 + 255
dot.junit.opcodes.add_int_lit16.Main_testN3;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_3 ;add-int/lit16;Normal #3;Arguments = 0 + (-32768)
dot.junit.opcodes.add_int_lit16.Main_testN4;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_4 ;add-int/lit16;Normal #4;Arguments = (-2147483647) + 0
dot.junit.opcodes.add_int_lit16.Main_testN5;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_5 ;add-int/lit16;Normal #5;Arguments = 0x7ffffffe + 2
dot.junit.opcodes.add_int_lit16.Main_testN6;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_6 ;add-int/lit16;Normal #6;Arguments = -1 + 1
dot.junit.opcodes.add_int_lit16.Main_testN7;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_16 ;add-int/lit16;Normal #7;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this sum of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.add_int_lit16.Main_testVFE1;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_13 ;add-int/lit16;Verifier #1; Constraint B1, types of arguments - int, double
dot.junit.opcodes.add_int_lit16.Main_testVFE2;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_14 ;add-int/lit16;Verifier #2; Constraint B1, types of arguments - long, int
dot.junit.opcodes.add_int_lit16.Main_testVFE3;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_15 ;add-int/lit16;Verifier #3; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.add_int_lit16.Main_testVFE4;dot.junit.opcodes.add_int_lit16.d.T_add_int_lit16_17 ;add-int/lit16;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.add_int_lit8.Main_testB1;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_7 ;add-int/lit8;Boundary #1;Arguments = 0 + Byte.MAX_VALUE
dot.junit.opcodes.add_int_lit8.Main_testB2;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_8 ;add-int/lit8;Boundary #2;Arguments = Integer.MAX_VALUE + Byte.MAX_VALUE
dot.junit.opcodes.add_int_lit8.Main_testB3;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_9 ;add-int/lit8;Boundary #3;Arguments = Integer.MAX_VALUE + 1
dot.junit.opcodes.add_int_lit8.Main_testB4;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_10 ;add-int/lit8;Boundary #4;Arguments = Integer.MIN_VALUE + 1
dot.junit.opcodes.add_int_lit8.Main_testB5;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_11 ;add-int/lit8;Boundary #5;Arguments = 0 + 0
dot.junit.opcodes.add_int_lit8.Main_testB6;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_12 ;add-int/lit8;Boundary #6;Arguments = Short.MIN_VALUE + Byte.MIN_VALUE
dot.junit.opcodes.add_int_lit8.Main_testN1;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_1 ;add-int/lit8;Normal #1;Arguments = 8 + 4
dot.junit.opcodes.add_int_lit8.Main_testN2;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_2 ;add-int/lit8;Normal #2;Arguments = Byte.MIN_VALUE + Byte.MAX_VALUE
dot.junit.opcodes.add_int_lit8.Main_testN3;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_3 ;add-int/lit8;Normal #3;Arguments = 0 + (-128)
dot.junit.opcodes.add_int_lit8.Main_testN4;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_4 ;add-int/lit8;Normal #4;Arguments = (-2147483647) + 0
dot.junit.opcodes.add_int_lit8.Main_testN5;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_5 ;add-int/lit8;Normal #5;Arguments = 0x7ffffffe + 2
dot.junit.opcodes.add_int_lit8.Main_testN6;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_6 ;add-int/lit8;Normal #6;Arguments = -1 + 1
dot.junit.opcodes.add_int_lit8.Main_testN7;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_16 ;add-int/lit8;Normal #7;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this sum of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.add_int_lit8.Main_testVFE1;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_13 ;add-int/lit8;Verifier #1; Constraint B1, types of arguments - int, double
dot.junit.opcodes.add_int_lit8.Main_testVFE2;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_14 ;add-int/lit8;Verifier #2; Constraint B1, types of arguments - long, int
dot.junit.opcodes.add_int_lit8.Main_testVFE3;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_15 ;add-int/lit8;Verifier #3; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.add_int_lit8.Main_testVFE4;dot.junit.opcodes.add_int_lit8.d.T_add_int_lit8_17 ;add-int/lit8;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.add_int.Main_testB1;dot.junit.opcodes.add_int.d.T_add_int_1 ;add-int;Boundary #1;Arguments = 0, Integer.MAX_VALUE
dot.junit.opcodes.add_int.Main_testB2;dot.junit.opcodes.add_int.d.T_add_int_1 ;add-int;Boundary #2;Arguments = Integer.MAX_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.add_int.Main_testB3;dot.junit.opcodes.add_int.d.T_add_int_1 ;add-int;Boundary #3;Arguments = Integer.MAX_VALUE, 1
dot.junit.opcodes.add_int.Main_testB4;dot.junit.opcodes.add_int.d.T_add_int_1 ;add-int;Boundary #4;Arguments = Integer.MIN_VALUE, 1
dot.junit.opcodes.add_int.Main_testB5;dot.junit.opcodes.add_int.d.T_add_int_1 ;add-int;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.add_int.Main_testB6;dot.junit.opcodes.add_int.d.T_add_int_1 ;add-int;Boundary #6;Arguments = Integer.MIN_VALUE, Integer.MIN_VALUE
dot.junit.opcodes.add_int.Main_testN1;dot.junit.opcodes.add_int.d.T_add_int_1 ;add-int;Normal #1;Arguments = 8, 4
dot.junit.opcodes.add_int.Main_testN2;dot.junit.opcodes.add_int.d.T_add_int_1 ;add-int;Normal #2;Arguments = 0, 255
dot.junit.opcodes.add_int.Main_testN3;dot.junit.opcodes.add_int.d.T_add_int_1 ;add-int;Normal #3;Arguments = 0, -65536
dot.junit.opcodes.add_int.Main_testN4;dot.junit.opcodes.add_int.d.T_add_int_1 ;add-int;Normal #4;Arguments = 0, -2147483647
dot.junit.opcodes.add_int.Main_testN5;dot.junit.opcodes.add_int.d.T_add_int_1 ;add-int;Normal #5;Arguments = 0x7ffffffe, 2
dot.junit.opcodes.add_int.Main_testN6;dot.junit.opcodes.add_int.d.T_add_int_1 ;add-int;Normal #6;Arguments = -1, 1
dot.junit.opcodes.add_int.Main_testN7;dot.junit.opcodes.add_int.d.T_add_int_5 ;add-int;Normal #7;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this sum of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.add_int.Main_testVFE1;dot.junit.opcodes.add_int.d.T_add_int_2 ;add-int;Verifier #1; Constraint B1, types of arguments - int, double
dot.junit.opcodes.add_int.Main_testVFE2;dot.junit.opcodes.add_int.d.T_add_int_3 ;add-int;Verifier #2; Constraint B1, types of arguments - long, int
dot.junit.opcodes.add_int.Main_testVFE3;dot.junit.opcodes.add_int.d.T_add_int_4 ;add-int;Verifier #3; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.add_int.Main_testVFE4;dot.junit.opcodes.add_int.d.T_add_int_6 ;add-int;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.add_long_2addr.Main_testB1;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_1 ;add-long/2addr;Boundary #1;Arguments = 0 + Long.MAX_VALUE
dot.junit.opcodes.add_long_2addr.Main_testB2;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_1 ;add-long/2addr;Boundary #2;Arguments = 0 + Long.MIN_VALUE
dot.junit.opcodes.add_long_2addr.Main_testB3;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_1 ;add-long/2addr;Boundary #3;Arguments = 0 + 0
dot.junit.opcodes.add_long_2addr.Main_testB4;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_1 ;add-long/2addr;Boundary #4;Arguments = Long.MAX_VALUE + Long.MAX_VALUE
dot.junit.opcodes.add_long_2addr.Main_testB5;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_1 ;add-long/2addr;Boundary #5;Arguments = Long.MAX_VALUE + Long.MIN_VALUE
dot.junit.opcodes.add_long_2addr.Main_testB6;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_1 ;add-long/2addr;Boundary #6;Arguments = Long.MIN_VALUE + Long.MIN_VALUE
dot.junit.opcodes.add_long_2addr.Main_testB7;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_1 ;add-long/2addr;Boundary #7;Arguments = Long.MIN_VALUE + 1
dot.junit.opcodes.add_long_2addr.Main_testB8;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_1 ;add-long/2addr;Boundary #8;Arguments = Long.MAX_VALUE + 1
dot.junit.opcodes.add_long_2addr.Main_testN1;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_1 ;add-long/2addr;Normal #1;Arguments = 12345678l, 87654321l
dot.junit.opcodes.add_long_2addr.Main_testN2;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_1 ;add-long/2addr;Normal #2;Arguments = 0l, 87654321l
dot.junit.opcodes.add_long_2addr.Main_testN3;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_1 ;add-long/2addr;Normal #3;Arguments = -12345678l, 0l
dot.junit.opcodes.add_long_2addr.Main_testN4;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_6 ;add-long/2addr;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally,     * so this sum of long and double makes no sense but shall not crash the VM.
dot.junit.opcodes.add_long_2addr.Main_testVFE2;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_2 ;add-long/2addr;Verifier #2; Constraint A24, number of registers
dot.junit.opcodes.add_long_2addr.Main_testVFE3;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_3 ;add-long/2addr;Verifier #3; Constraint B1, types of arguments - long / integer
dot.junit.opcodes.add_long_2addr.Main_testVFE4;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_4 ;add-long/2addr;Verifier #4; Constraint B1, types of arguments - long / float
dot.junit.opcodes.add_long_2addr.Main_testVFE5;dot.junit.opcodes.add_long_2addr.d.T_add_long_2addr_5 ;add-long/2addr;Verifier #5; Constraint B1, types of arguments - reference / long
dot.junit.opcodes.add_long.Main_testB1;dot.junit.opcodes.add_long.d.T_add_long_1 ;add-long;Boundary #1;Arguments = 0 + Long.MAX_VALUE
dot.junit.opcodes.add_long.Main_testB2;dot.junit.opcodes.add_long.d.T_add_long_1 ;add-long;Boundary #2;Arguments = 0 + Long.MIN_VALUE
dot.junit.opcodes.add_long.Main_testB3;dot.junit.opcodes.add_long.d.T_add_long_1 ;add-long;Boundary #3;Arguments = 0 + 0
dot.junit.opcodes.add_long.Main_testB4;dot.junit.opcodes.add_long.d.T_add_long_1 ;add-long;Boundary #4;Arguments = Long.MAX_VALUE + Long.MAX_VALUE
dot.junit.opcodes.add_long.Main_testB5;dot.junit.opcodes.add_long.d.T_add_long_1 ;add-long;Boundary #5;Arguments = Long.MAX_VALUE + Long.MIN_VALUE
dot.junit.opcodes.add_long.Main_testB6;dot.junit.opcodes.add_long.d.T_add_long_1 ;add-long;Boundary #6;Arguments = Long.MIN_VALUE + Long.MIN_VALUE
dot.junit.opcodes.add_long.Main_testB7;dot.junit.opcodes.add_long.d.T_add_long_1 ;add-long;Boundary #7;Arguments = Long.MIN_VALUE + 1
dot.junit.opcodes.add_long.Main_testB8;dot.junit.opcodes.add_long.d.T_add_long_1 ;add-long;Boundary #8;Arguments = Long.MAX_VALUE + 1
dot.junit.opcodes.add_long.Main_testN1;dot.junit.opcodes.add_long.d.T_add_long_1 ;add-long;Normal #1;Arguments = 12345678l, 87654321l
dot.junit.opcodes.add_long.Main_testN2;dot.junit.opcodes.add_long.d.T_add_long_1 ;add-long;Normal #2;Arguments = 0l, 87654321l
dot.junit.opcodes.add_long.Main_testN3;dot.junit.opcodes.add_long.d.T_add_long_1 ;add-long;Normal #3;Arguments = -12345678l, 0l
dot.junit.opcodes.add_long.Main_testN4;dot.junit.opcodes.add_long.d.T_add_long_6 ;add-long;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this sum of long and double makes no sense but shall not crash the VM.
dot.junit.opcodes.add_long.Main_testVFE1;dot.junit.opcodes.add_long.d.T_add_long_2 ;add-long;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.add_long.Main_testVFE2;dot.junit.opcodes.add_long.d.T_add_long_3 ;add-long;Verifier #2; Constraint B1, types of arguments - long / integer
dot.junit.opcodes.add_long.Main_testVFE3;dot.junit.opcodes.add_long.d.T_add_long_4 ;add-long;Verifier #3; Constraint B1, types of arguments - long / float
dot.junit.opcodes.add_long.Main_testVFE4;dot.junit.opcodes.add_long.d.T_add_long_5 ;add-long;Verifier #4; Constraint B1, types of arguments - reference / long
dot.junit.opcodes.aget_boolean.Main_testE1;dot.junit.opcodes.aget_boolean.d.T_aget_boolean_1 ;aget-boolean;Exception #1;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.aget_boolean.Main_testE2;dot.junit.opcodes.aget_boolean.d.T_aget_boolean_1 ;aget-boolean;Exception #2;Expected NullPointerException
dot.junit.opcodes.aget_boolean.Main_testE3;dot.junit.opcodes.aget_boolean.d.T_aget_boolean_1 ;aget-boolean;Exception #3;Expected ArrayIndexOutOfBoundsException (negative index)
dot.junit.opcodes.aget_boolean.Main_testN1;dot.junit.opcodes.aget_boolean.d.T_aget_boolean_1 ;aget-boolean;Normal #1;Get boolean from array
dot.junit.opcodes.aget_boolean.Main_testN2;dot.junit.opcodes.aget_boolean.d.T_aget_boolean_1 ;aget-boolean;Normal #2;Get boolean from array
dot.junit.opcodes.aget_boolean.Main_testN3;dot.junit.opcodes.aget_boolean.d.T_aget_boolean_8 ;aget-boolean;Normal #3;Type of index argument - float. Dalvik doens't distinguish 32-bits types internally, so this array[float] makes no sense but shall not crash the VM.
dot.junit.opcodes.aget_boolean.Main_testVFE1;dot.junit.opcodes.aget_boolean.d.T_aget_boolean_2 ;aget-boolean;Verifier #1; Constraint B1, types of arguments - array, double
dot.junit.opcodes.aget_boolean.Main_testVFE2;dot.junit.opcodes.aget_boolean.d.T_aget_boolean_3 ;aget-boolean;Verifier #2; Constraint B1, types of arguments - array, long
dot.junit.opcodes.aget_boolean.Main_testVFE3;dot.junit.opcodes.aget_boolean.d.T_aget_boolean_4 ;aget-boolean;Verifier #3; Constraint B1, types of arguments - Object, int
dot.junit.opcodes.aget_boolean.Main_testVFE4;dot.junit.opcodes.aget_boolean.d.T_aget_boolean_5 ;aget-boolean;Verifier #4; Constraint B1, types of arguments - double[], int
dot.junit.opcodes.aget_boolean.Main_testVFE5;dot.junit.opcodes.aget_boolean.d.T_aget_boolean_6 ;aget-boolean;Verifier #5; Constraint B1, types of arguments - long[], int
dot.junit.opcodes.aget_boolean.Main_testVFE6;dot.junit.opcodes.aget_boolean.d.T_aget_boolean_7 ;aget-boolean;Verifier #6; Constraint B1, types of arguments - array, reference
dot.junit.opcodes.aget_boolean.Main_testVFE7;dot.junit.opcodes.aget_boolean.d.T_aget_boolean_9 ;aget-boolean;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.aget_byte.Main_testE1;dot.junit.opcodes.aget_byte.d.T_aget_byte_1 ;aget-byte;Exception #1;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.aget_byte.Main_testE2;dot.junit.opcodes.aget_byte.d.T_aget_byte_1 ;aget-byte;Exception #2;Expected NullPointerException
dot.junit.opcodes.aget_byte.Main_testE3;dot.junit.opcodes.aget_byte.d.T_aget_byte_1 ;aget-byte;Exception #3;Expected ArrayIndexOutOfBoundsException (negative index)
dot.junit.opcodes.aget_byte.Main_testN1;dot.junit.opcodes.aget_byte.d.T_aget_byte_1 ;aget-byte;Normal #1;Get byte from array
dot.junit.opcodes.aget_byte.Main_testN2;dot.junit.opcodes.aget_byte.d.T_aget_byte_1 ;aget-byte;Normal #2;Get byte from array
dot.junit.opcodes.aget_byte.Main_testN3;dot.junit.opcodes.aget_byte.d.T_aget_byte_8 ;aget-byte;Normal #3;Type of index argument - float. Dalvik doens't distinguish 32-bits types internally, so this array[float] makes no sense but shall not crash the VM.
dot.junit.opcodes.aget_byte.Main_testVFE1;dot.junit.opcodes.aget_byte.d.T_aget_byte_2 ;aget-byte;Verifier #1; Constraint B1, types of arguments - array, double
dot.junit.opcodes.aget_byte.Main_testVFE2;dot.junit.opcodes.aget_byte.d.T_aget_byte_3 ;aget-byte;Verifier #2; Constraint B1, types of arguments - array, long
dot.junit.opcodes.aget_byte.Main_testVFE3;dot.junit.opcodes.aget_byte.d.T_aget_byte_4 ;aget-byte;Verifier #3; Constraint B1, types of arguments - Object, short
dot.junit.opcodes.aget_byte.Main_testVFE4;dot.junit.opcodes.aget_byte.d.T_aget_byte_5 ;aget-byte;Verifier #4; Constraint B1, types of arguments - double[], int
dot.junit.opcodes.aget_byte.Main_testVFE5;dot.junit.opcodes.aget_byte.d.T_aget_byte_6 ;aget-byte;Verifier #5; Constraint B1, types of arguments - int[], int
dot.junit.opcodes.aget_byte.Main_testVFE6;dot.junit.opcodes.aget_byte.d.T_aget_byte_7 ;aget-byte;Verifier #6; Constraint B1, types of arguments - array, reference
dot.junit.opcodes.aget_byte.Main_testVFE7;dot.junit.opcodes.aget_byte.d.T_aget_byte_9 ;aget-byte;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.aget_char.Main_testE1;dot.junit.opcodes.aget_char.d.T_aget_char_1 ;aget-char;Exception #1;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.aget_char.Main_testE2;dot.junit.opcodes.aget_char.d.T_aget_char_1 ;aget-char;Exception #2;Expected NullPointerException
dot.junit.opcodes.aget_char.Main_testE3;dot.junit.opcodes.aget_char.d.T_aget_char_1 ;aget-char;Exception #3;Expected ArrayIndexOutOfBoundsException (negative index)
dot.junit.opcodes.aget_char.Main_testN1;dot.junit.opcodes.aget_char.d.T_aget_char_1 ;aget-char;Normal #1;Get char from array
dot.junit.opcodes.aget_char.Main_testN2;dot.junit.opcodes.aget_char.d.T_aget_char_1 ;aget-char;Normal #2;Get char from array
dot.junit.opcodes.aget_char.Main_testN3;dot.junit.opcodes.aget_char.d.T_aget_char_8 ;aget-char;Normal #3;Type of index argument - float. Dalvik doens't distinguish 32-bits types internally, so this array[float] makes no sense but shall not crash the VM.
dot.junit.opcodes.aget_char.Main_testVFE1;dot.junit.opcodes.aget_char.d.T_aget_char_2 ;aget-char;Verifier #1; Constraint B1, types of arguments - array, double
dot.junit.opcodes.aget_char.Main_testVFE2;dot.junit.opcodes.aget_char.d.T_aget_char_3 ;aget-char;Verifier #2; Constraint B1, types of arguments - array, long
dot.junit.opcodes.aget_char.Main_testVFE3;dot.junit.opcodes.aget_char.d.T_aget_char_4 ;aget-char;Verifier #3; Constraint B1, types of arguments - Object, char
dot.junit.opcodes.aget_char.Main_testVFE4;dot.junit.opcodes.aget_char.d.T_aget_char_5 ;aget-char;Verifier #4; Constraint B1, types of arguments - double[], char
dot.junit.opcodes.aget_char.Main_testVFE5;dot.junit.opcodes.aget_char.d.T_aget_char_6 ;aget-char;Verifier #5; Constraint B1, types of arguments - int[], int
dot.junit.opcodes.aget_char.Main_testVFE6;dot.junit.opcodes.aget_char.d.T_aget_char_7 ;aget-char;Verifier #6; Constraint B1, types of arguments - array, reference
dot.junit.opcodes.aget_char.Main_testVFE7;dot.junit.opcodes.aget_char.d.T_aget_char_9 ;aget-char;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.aget_object.Main_testE1;dot.junit.opcodes.aget_object.d.T_aget_object_1 ;aget-object;Exception #1;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.aget_object.Main_testE2;dot.junit.opcodes.aget_object.d.T_aget_object_1 ;aget-object;Exception #2;Expected ArrayIndexOutOfBoundsException (negative index)
dot.junit.opcodes.aget_object.Main_testE3;dot.junit.opcodes.aget_object.d.T_aget_object_1 ;aget-object;Exception #3;Expected NullPointerException
dot.junit.opcodes.aget_object.Main_testN1;dot.junit.opcodes.aget_object.d.T_aget_object_1 ;aget-object;Normal #1;Get reference from array
dot.junit.opcodes.aget_object.Main_testN2;dot.junit.opcodes.aget_object.d.T_aget_object_1 ;aget-object;Normal #2;Get reference from array
dot.junit.opcodes.aget_object.Main_testN3;dot.junit.opcodes.aget_object.d.T_aget_object_8 ;aget-object;Normal #3;Type of index argument - float. Dalvik doens't distinguish 32-bits types internally, so this array[float] makes no sense but shall not crash the VM.
dot.junit.opcodes.aget_object.Main_testVFE1;dot.junit.opcodes.aget_object.d.T_aget_object_2 ;aget-object;Verifier #1; Constraint B1, types of arguments - array, double
dot.junit.opcodes.aget_object.Main_testVFE2;dot.junit.opcodes.aget_object.d.T_aget_object_3 ;aget-object;Verifier #2; Constraint B1, types of arguments - array, long
dot.junit.opcodes.aget_object.Main_testVFE3;dot.junit.opcodes.aget_object.d.T_aget_object_4 ;aget-object;Verifier #3; Constraint B1, types of arguments - Object, int
dot.junit.opcodes.aget_object.Main_testVFE4;dot.junit.opcodes.aget_object.d.T_aget_object_5 ;aget-object;Verifier #4; Constraint B1, types of arguments - float[], int
dot.junit.opcodes.aget_object.Main_testVFE5;dot.junit.opcodes.aget_object.d.T_aget_object_6 ;aget-object;Verifier #5; Constraint B1, types of arguments - long[], int
dot.junit.opcodes.aget_object.Main_testVFE6;dot.junit.opcodes.aget_object.d.T_aget_object_7 ;aget-object;Verifier #6; Constraint B1, types of arguments - array, reference
dot.junit.opcodes.aget_object.Main_testVFE7;dot.junit.opcodes.aget_object.d.T_aget_object_9 ;aget-object;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.aget_short.Main_testE1;dot.junit.opcodes.aget_short.d.T_aget_short_1 ;aget-short;Exception #1;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.aget_short.Main_testE2;dot.junit.opcodes.aget_short.d.T_aget_short_1 ;aget-short;Exception #2;Expected NullPointerException
dot.junit.opcodes.aget_short.Main_testE3;dot.junit.opcodes.aget_short.d.T_aget_short_1 ;aget-short;Exception #3;Expected ArrayIndexOutOfBoundsException (negative index)
dot.junit.opcodes.aget_short.Main_testN1;dot.junit.opcodes.aget_short.d.T_aget_short_1 ;aget-short;Normal #1;Get short from array
dot.junit.opcodes.aget_short.Main_testN2;dot.junit.opcodes.aget_short.d.T_aget_short_1 ;aget-short;Normal #2;Get short from array
dot.junit.opcodes.aget_short.Main_testN3;dot.junit.opcodes.aget_short.d.T_aget_short_8 ;aget-short;Normal #3;Type of index argument - float. Dalvik doens't distinguish 32-bits types internally, so this array[float] makes no sense but shall not crash the VM.
dot.junit.opcodes.aget_short.Main_testVFE1;dot.junit.opcodes.aget_short.d.T_aget_short_2 ;aget-short;Verifier #1; Constraint B1, types of arguments - array, double
dot.junit.opcodes.aget_short.Main_testVFE2;dot.junit.opcodes.aget_short.d.T_aget_short_3 ;aget-short;Verifier #2; Constraint B1, types of arguments - array, long
dot.junit.opcodes.aget_short.Main_testVFE3;dot.junit.opcodes.aget_short.d.T_aget_short_4 ;aget-short;Verifier #3; Constraint B1, types of arguments - Object, int
dot.junit.opcodes.aget_short.Main_testVFE4;dot.junit.opcodes.aget_short.d.T_aget_short_5 ;aget-short;Verifier #4; Constraint B1, types of arguments - double[], int
dot.junit.opcodes.aget_short.Main_testVFE5;dot.junit.opcodes.aget_short.d.T_aget_short_6 ;aget-short;Verifier #5; Constraint B1, types of arguments - int[], int
dot.junit.opcodes.aget_short.Main_testVFE6;dot.junit.opcodes.aget_short.d.T_aget_short_7 ;aget-short;Verifier #6; Constraint B1, types of arguments - array, reference
dot.junit.opcodes.aget_short.Main_testVFE7;dot.junit.opcodes.aget_short.d.T_aget_short_9 ;aget-short;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.aget.Main_testE1;dot.junit.opcodes.aget.d.T_aget_1 ;aget;Exception #1;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.aget.Main_testE2;dot.junit.opcodes.aget.d.T_aget_1 ;aget;Exception #2;Expected NullPointerException
dot.junit.opcodes.aget.Main_testE3;dot.junit.opcodes.aget.d.T_aget_1 ;aget;Exception #3;Expected ArrayIndexOutOfBoundsException (negative index)
dot.junit.opcodes.aget.Main_testN1;dot.junit.opcodes.aget.d.T_aget_1 ;aget;Normal #1;Get int from array
dot.junit.opcodes.aget.Main_testN2;dot.junit.opcodes.aget.d.T_aget_1 ;aget;Normal #2;Get int from array
dot.junit.opcodes.aget.Main_testN3;dot.junit.opcodes.aget.d.T_aget_8 ;aget;Normal #3;Type of index argument - float. Dalvik doens't distinguish 32-bits types internally, so this array[float] makes no sense but shall not crash the VM.
dot.junit.opcodes.aget.Main_testVFE1;dot.junit.opcodes.aget.d.T_aget_2 ;aget;Verifier #1; Constraint B1, types of arguments - array, double
dot.junit.opcodes.aget.Main_testVFE2;dot.junit.opcodes.aget.d.T_aget_3 ;aget;Verifier #2; Constraint B1, types of arguments - array, long
dot.junit.opcodes.aget.Main_testVFE3;dot.junit.opcodes.aget.d.T_aget_4 ;aget;Verifier #3; Constraint B1, types of arguments - Object, int
dot.junit.opcodes.aget.Main_testVFE4;dot.junit.opcodes.aget.d.T_aget_5 ;aget;Verifier #4; Constraint B1, types of arguments - double[], int
dot.junit.opcodes.aget.Main_testVFE5;dot.junit.opcodes.aget.d.T_aget_6 ;aget;Verifier #5; Constraint B1, types of arguments - long[], int
dot.junit.opcodes.aget.Main_testVFE6;dot.junit.opcodes.aget.d.T_aget_7 ;aget;Verifier #6; Constraint B1, types of arguments - array, reference
dot.junit.opcodes.aget.Main_testVFE7;dot.junit.opcodes.aget.d.T_aget_9 ;aget;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.aget_wide.Main_testE1;dot.junit.opcodes.aget_wide.d.T_aget_wide_1 ;aget-wide;Exception #1;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.aget_wide.Main_testE2;dot.junit.opcodes.aget_wide.d.T_aget_wide_1 ;aget-wide;Exception #2;Expected NullPointerException
dot.junit.opcodes.aget_wide.Main_testE3;dot.junit.opcodes.aget_wide.d.T_aget_wide_1 ;aget-wide;Exception #3;Expected ArrayIndexOutOfBoundsException (negative index)
dot.junit.opcodes.aget_wide.Main_testN1;dot.junit.opcodes.aget_wide.d.T_aget_wide_1 ;aget-wide;Normal #1;Get long from array
dot.junit.opcodes.aget_wide.Main_testN2;dot.junit.opcodes.aget_wide.d.T_aget_wide_1 ;aget-wide;Normal #2;Get long from array
dot.junit.opcodes.aget_wide.Main_testN3;dot.junit.opcodes.aget_wide.d.T_aget_wide_2 ;aget-wide;Normal #3;Get double from array
dot.junit.opcodes.aget_wide.Main_testN4;dot.junit.opcodes.aget_wide.d.T_aget_wide_10 ;aget-wide;Normal #4;Type of index argument - float. Dalvik doens't distinguish 32-bits types internally, so this array[float] makes no sense but shall not crash the VM.
dot.junit.opcodes.aget_wide.Main_testVFE1;dot.junit.opcodes.aget_wide.d.T_aget_wide_3 ;aget-wide;Verifier #1; Constraint B1, types of arguments - array, double
dot.junit.opcodes.aget_wide.Main_testVFE2;dot.junit.opcodes.aget_wide.d.T_aget_wide_5 ;aget-wide;Verifier #2; Constraint B1, types of arguments - array, long
dot.junit.opcodes.aget_wide.Main_testVFE3;dot.junit.opcodes.aget_wide.d.T_aget_wide_6 ;aget-wide;Verifier #3; Constraint B1, types of arguments - Object, int
dot.junit.opcodes.aget_wide.Main_testVFE4;dot.junit.opcodes.aget_wide.d.T_aget_wide_7 ;aget-wide;Verifier #4; Constraint B1, types of arguments - int[], int
dot.junit.opcodes.aget_wide.Main_testVFE5;dot.junit.opcodes.aget_wide.d.T_aget_wide_8 ;aget-wide;Verifier #5; Constraint B1, types of arguments - array, reference
dot.junit.opcodes.aget_wide.Main_testVFE6;dot.junit.opcodes.aget_wide.d.T_aget_wide_9 ;aget-wide;Verifier #6; Constraint A23, number of registers
dot.junit.opcodes.aget_wide.Main_testVFE7;dot.junit.opcodes.aget_wide.d.T_aget_wide_11 ;aget-wide;Verifier #7; Constraint A24, number of registers
dot.junit.opcodes.and_int_2addr.Main_testB1;dot.junit.opcodes.and_int_2addr.d.T_and_int_2addr_1 ;and-int/2addr;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.and_int_2addr.Main_testB2;dot.junit.opcodes.and_int_2addr.d.T_and_int_2addr_1 ;and-int/2addr;Boundary #2;Arguments = Integer.MAX_VALUE & Integer.MIN_VALUE
dot.junit.opcodes.and_int_2addr.Main_testN1;dot.junit.opcodes.and_int_2addr.d.T_and_int_2addr_1 ;and-int/2addr;Normal #1;Arguments = 15, 8
dot.junit.opcodes.and_int_2addr.Main_testN2;dot.junit.opcodes.and_int_2addr.d.T_and_int_2addr_1 ;and-int/2addr;Normal #2;Arguments = 0xfffffff8, 0xfffffff1
dot.junit.opcodes.and_int_2addr.Main_testN3;dot.junit.opcodes.and_int_2addr.d.T_and_int_2addr_1 ;and-int/2addr;Normal #3;Arguments = 0xcafe & -1
dot.junit.opcodes.and_int_2addr.Main_testN4;dot.junit.opcodes.and_int_2addr.d.T_and_int_2addr_5 ;and-int/2addr;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this (float & int) makes no sense but shall not crash the VM.
dot.junit.opcodes.and_int_2addr.Main_testVFE2;dot.junit.opcodes.and_int_2addr.d.T_and_int_2addr_2 ;and-int/2addr;Verifier #2; Constraint B1, types of arguments - double & int
dot.junit.opcodes.and_int_2addr.Main_testVFE3;dot.junit.opcodes.and_int_2addr.d.T_and_int_2addr_3 ;and-int/2addr;Verifier #3; Constraint B1, types of arguments - long & int
dot.junit.opcodes.and_int_2addr.Main_testVFE4;dot.junit.opcodes.and_int_2addr.d.T_and_int_2addr_4 ;and-int/2addr;Verifier #4; Constraint B1, types of arguments - int & reference
dot.junit.opcodes.and_int_2addr.Main_testVFE5;dot.junit.opcodes.and_int_2addr.d.T_and_int_2addr_6 ;and-int/2addr;Verifier #5; Constraint A23, number of registers
dot.junit.opcodes.and_int_lit16.Main_testB1;dot.junit.opcodes.and_int_lit16.d.T_and_int_lit16_4 ;and-int/lit16;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.and_int_lit16.Main_testB2;dot.junit.opcodes.and_int_lit16.d.T_and_int_lit16_5 ;and-int/lit16;Boundary #2;Arguments = Short.MAX_VALUE & Short.MIN_VALUE
dot.junit.opcodes.and_int_lit16.Main_testN1;dot.junit.opcodes.and_int_lit16.d.T_and_int_lit16_1 ;and-int/lit16;Normal #1;Arguments = 15 & 8
dot.junit.opcodes.and_int_lit16.Main_testN2;dot.junit.opcodes.and_int_lit16.d.T_and_int_lit16_2 ;and-int/lit16;Normal #2;Arguments = 0xfffffff8 & -8
dot.junit.opcodes.and_int_lit16.Main_testN3;dot.junit.opcodes.and_int_lit16.d.T_and_int_lit16_3 ;and-int/lit16;Normal #3;Arguments = 0xcafe & -1
dot.junit.opcodes.and_int_lit16.Main_testN4;dot.junit.opcodes.and_int_lit16.d.T_and_int_lit16_9 ;and-int/lit16;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this (float & int) makes no sense but shall not crash the VM.
dot.junit.opcodes.and_int_lit16.Main_testVFE1;dot.junit.opcodes.and_int_lit16.d.T_and_int_lit16_6 ;and-int/lit16;Verifier #1; Constraint B1, types of arguments - double & int
dot.junit.opcodes.and_int_lit16.Main_testVFE2;dot.junit.opcodes.and_int_lit16.d.T_and_int_lit16_7 ;and-int/lit16;Verifier #2; Constraint B1, types of arguments - long & int
dot.junit.opcodes.and_int_lit16.Main_testVFE3;dot.junit.opcodes.and_int_lit16.d.T_and_int_lit16_8 ;and-int/lit16;Verifier #3; Constraint B1, types of arguments - int & reference
dot.junit.opcodes.and_int_lit16.Main_testVFE5;dot.junit.opcodes.and_int_lit16.d.T_and_int_lit16_10 ;and-int/lit16;Verifier #5; Constraint A23, number of registers
dot.junit.opcodes.and_int_lit8.Main_testB1;dot.junit.opcodes.and_int_lit8.d.T_and_int_lit8_4 ;and-int/lit8;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.and_int_lit8.Main_testB2;dot.junit.opcodes.and_int_lit8.d.T_and_int_lit8_5 ;and-int/lit8;Boundary #2;Arguments = Short.MAX_VALUE & Short.MIN_VALUE
dot.junit.opcodes.and_int_lit8.Main_testN1;dot.junit.opcodes.and_int_lit8.d.T_and_int_lit8_1 ;and-int/lit8;Normal #1;Arguments = 15 & 8
dot.junit.opcodes.and_int_lit8.Main_testN2;dot.junit.opcodes.and_int_lit8.d.T_and_int_lit8_2 ;and-int/lit8;Normal #2;Arguments = 0xfffffff8 & -8
dot.junit.opcodes.and_int_lit8.Main_testN3;dot.junit.opcodes.and_int_lit8.d.T_and_int_lit8_3 ;and-int/lit8;Normal #3;Arguments = 0xcafe & -1
dot.junit.opcodes.and_int_lit8.Main_testN4;dot.junit.opcodes.and_int_lit8.d.T_and_int_lit8_9 ;and-int/lit8;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this (float & int) makes no sense but shall not crash the VM.
dot.junit.opcodes.and_int_lit8.Main_testVFE1;dot.junit.opcodes.and_int_lit8.d.T_and_int_lit8_6 ;and-int/lit8;Verifier #1; Constraint B1, types of arguments - double & int
dot.junit.opcodes.and_int_lit8.Main_testVFE2;dot.junit.opcodes.and_int_lit8.d.T_and_int_lit8_7 ;and-int/lit8;Verifier #2; Constraint B1, types of arguments - long & int
dot.junit.opcodes.and_int_lit8.Main_testVFE3;dot.junit.opcodes.and_int_lit8.d.T_and_int_lit8_8 ;and-int/lit8;Verifier #3; Constraint B1, types of arguments - int & reference
dot.junit.opcodes.and_int_lit8.Main_testVFE5;dot.junit.opcodes.and_int_lit8.d.T_and_int_lit8_10 ;and-int/lit8;Verifier #5; Constraint A23, number of registers
dot.junit.opcodes.and_int.Main_testB1;dot.junit.opcodes.and_int.d.T_and_int_1 ;and-int;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.and_int.Main_testB2;dot.junit.opcodes.and_int.d.T_and_int_1 ;and-int;Boundary #2;Arguments = Integer.MAX_VALUE & Integer.MIN_VALUE
dot.junit.opcodes.and_int.Main_testN1;dot.junit.opcodes.and_int.d.T_and_int_1 ;and-int;Normal #1;Arguments = 15, 8
dot.junit.opcodes.and_int.Main_testN2;dot.junit.opcodes.and_int.d.T_and_int_1 ;and-int;Normal #2;Arguments = 0xfffffff8, 0xfffffff1
dot.junit.opcodes.and_int.Main_testN3;dot.junit.opcodes.and_int.d.T_and_int_1 ;and-int;Normal #3;Arguments = 0xcafe & -1
dot.junit.opcodes.and_int.Main_testN4;dot.junit.opcodes.and_int.d.T_and_int_5 ;and-int;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this (float & int) makes no sense but shall not crash the VM.
dot.junit.opcodes.and_int.Main_testVFE2;dot.junit.opcodes.and_int.d.T_and_int_2 ;and-int;Verifier #2; Constraint B1, types of arguments - double & int
dot.junit.opcodes.and_int.Main_testVFE3;dot.junit.opcodes.and_int.d.T_and_int_3 ;and-int;Verifier #3; Constraint B1, types of arguments - long & int
dot.junit.opcodes.and_int.Main_testVFE4;dot.junit.opcodes.and_int.d.T_and_int_4 ;and-int;Verifier #4; Constraint B1, types of arguments - int & reference
dot.junit.opcodes.and_int.Main_testVFE5;dot.junit.opcodes.and_int.d.T_and_int_6 ;and-int;Verifier #5; Constraint A23, number of registers
dot.junit.opcodes.and_long_2addr.Main_testB1;dot.junit.opcodes.and_long_2addr.d.T_and_long_2addr_1 ;and-long/2addr;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.and_long_2addr.Main_testB2;dot.junit.opcodes.and_long_2addr.d.T_and_long_2addr_1 ;and-long/2addr;Boundary #2;Arguments = Long.MAX_VALUE & Long.MIN_VALUE
dot.junit.opcodes.and_long_2addr.Main_testN1;dot.junit.opcodes.and_long_2addr.d.T_and_long_2addr_1 ;and-long/2addr;Normal #1;Arguments = 0xfffffff8aal, 0xfffffff1aal
dot.junit.opcodes.and_long_2addr.Main_testN2;dot.junit.opcodes.and_long_2addr.d.T_and_long_2addr_1 ;and-long/2addr;Normal #2;Arguments = 987654321, 123456789
dot.junit.opcodes.and_long_2addr.Main_testN3;dot.junit.opcodes.and_long_2addr.d.T_and_long_2addr_1 ;and-long/2addr;Normal #3;Arguments = 0xABCDEF & -1
dot.junit.opcodes.and_long_2addr.Main_testN4;dot.junit.opcodes.and_long_2addr.d.T_and_long_2addr_6 ;and-long/2addr;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this (long & double) makes no sense but shall not crash the VM.
dot.junit.opcodes.and_long_2addr.Main_testVFE1;dot.junit.opcodes.and_long_2addr.d.T_and_long_2addr_2 ;and-long/2addr;Verifier #1; Constraint B1, types of arguments - float & long
dot.junit.opcodes.and_long_2addr.Main_testVFE2;dot.junit.opcodes.and_long_2addr.d.T_and_long_2addr_3 ;and-long/2addr;Verifier #2; Constraint B1, types of arguments - int & long
dot.junit.opcodes.and_long_2addr.Main_testVFE3;dot.junit.opcodes.and_long_2addr.d.T_and_long_2addr_4 ;and-long/2addr;Verifier #3; Constraint B1, types of arguments - reference & long
dot.junit.opcodes.and_long_2addr.Main_testVFE4;dot.junit.opcodes.and_long_2addr.d.T_and_long_2addr_5 ;and-long/2addr;Verifier #4; Constraint A24, number of registers
dot.junit.opcodes.and_long.Main_testB1;dot.junit.opcodes.and_long.d.T_and_long_1 ;and-long;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.and_long.Main_testB2;dot.junit.opcodes.and_long.d.T_and_long_1 ;and-long;Boundary #2;Arguments = Long.MAX_VALUE & Long.MIN_VALUE
dot.junit.opcodes.and_long.Main_testN1;dot.junit.opcodes.and_long.d.T_and_long_1 ;and-long;Normal #1;Arguments = 0xfffffff8aal, 0xfffffff1aal
dot.junit.opcodes.and_long.Main_testN2;dot.junit.opcodes.and_long.d.T_and_long_1 ;and-long;Normal #2;Arguments = 987654321, 123456789
dot.junit.opcodes.and_long.Main_testN3;dot.junit.opcodes.and_long.d.T_and_long_1 ;and-long;Normal #3;Arguments = 0xABCDEF & -1
dot.junit.opcodes.and_long.Main_testN4;dot.junit.opcodes.and_long.d.T_and_long_6 ;and-long;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this (long & double) makes no sense but shall not crash the VM.
dot.junit.opcodes.and_long.Main_testVFE1;dot.junit.opcodes.and_long.d.T_and_long_2 ;and-long;Verifier #1; Constraint B1, types of arguments - float & long
dot.junit.opcodes.and_long.Main_testVFE2;dot.junit.opcodes.and_long.d.T_and_long_3 ;and-long;Verifier #2; Constraint B1, types of arguments - int & long
dot.junit.opcodes.and_long.Main_testVFE3;dot.junit.opcodes.and_long.d.T_and_long_4 ;and-long;Verifier #3; Constraint B1, types of arguments - reference & long
dot.junit.opcodes.and_long.Main_testVFE4;dot.junit.opcodes.and_long.d.T_and_long_5 ;and-long;Verifier #4; Constraint A24, number of registers
dot.junit.opcodes.aput_boolean.Main_testE1;dot.junit.opcodes.aput_boolean.d.T_aput_boolean_1 ;aput-boolean;Exception #1;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.aput_boolean.Main_testE2;dot.junit.opcodes.aput_boolean.d.T_aput_boolean_1 ;aput-boolean;Exception #2;Expected NullPointerException
dot.junit.opcodes.aput_boolean.Main_testE3;dot.junit.opcodes.aput_boolean.d.T_aput_boolean_1 ;aput-boolean;Exception #3;Expected ArrayIndexOutOfBoundsException (negative index)
dot.junit.opcodes.aput_boolean.Main_testN1;dot.junit.opcodes.aput_boolean.d.T_aput_boolean_1 ;aput-boolean;Normal #1;Put boolean into array
dot.junit.opcodes.aput_boolean.Main_testN2;dot.junit.opcodes.aput_boolean.d.T_aput_boolean_1 ;aput-boolean;Normal #2;Put boolean into array
dot.junit.opcodes.aput_boolean.Main_testN3;dot.junit.opcodes.aput_boolean.d.T_aput_boolean_8 ;aput-boolean;Normal #3;Type of index argument - float. Dalvik doens't distinguish 32-bits types internally, so this array[float]=value makes no sense but shall not crash the VM.
dot.junit.opcodes.aput_boolean.Main_testVFE1;dot.junit.opcodes.aput_boolean.d.T_aput_boolean_2 ;aput-boolean;Verifier #1; Constraint B1, types of arguments - array, double, int
dot.junit.opcodes.aput_boolean.Main_testVFE2;dot.junit.opcodes.aput_boolean.d.T_aput_boolean_3 ;aput-boolean;Verifier #2; Constraint B1, types of arguments - array, int, long
dot.junit.opcodes.aput_boolean.Main_testVFE3;dot.junit.opcodes.aput_boolean.d.T_aput_boolean_4 ;aput-boolean;Verifier #3; Constraint B1, types of arguments - object, int, int
dot.junit.opcodes.aput_boolean.Main_testVFE4;dot.junit.opcodes.aput_boolean.d.T_aput_boolean_5 ;aput-boolean;Verifier #4; Constraint B1, types of arguments - double[], int, int
dot.junit.opcodes.aput_boolean.Main_testVFE5;dot.junit.opcodes.aput_boolean.d.T_aput_boolean_6 ;aput-boolean;Verifier #5; Constraint B1, types of arguments - long[], int, int
dot.junit.opcodes.aput_boolean.Main_testVFE6;dot.junit.opcodes.aput_boolean.d.T_aput_boolean_7 ;aput-boolean;Verifier #6; Constraint B1, types of arguments - array, reference, int
dot.junit.opcodes.aput_boolean.Main_testVFE7;dot.junit.opcodes.aput_boolean.d.T_aput_boolean_9 ;aput-boolean;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.aput_boolean.Main_testVFE9;dot.junit.opcodes.aput_boolean.d.T_aput_boolean_10 ;aput-boolean;Verifier #9; Constraint B15, put value 2 into boolean array
dot.junit.opcodes.aput_byte.Main_testE1;dot.junit.opcodes.aput_byte.d.T_aput_byte_1 ;aput-byte;Exception #1;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.aput_byte.Main_testE2;dot.junit.opcodes.aput_byte.d.T_aput_byte_1 ;aput-byte;Exception #2;Expected NullPointerException
dot.junit.opcodes.aput_byte.Main_testE3;dot.junit.opcodes.aput_byte.d.T_aput_byte_1 ;aput-byte;Exception #3;Expected ArrayIndexOutOfBoundsException (negative index)
dot.junit.opcodes.aput_byte.Main_testN1;dot.junit.opcodes.aput_byte.d.T_aput_byte_1 ;aput-byte;Normal #1;Put byte into array
dot.junit.opcodes.aput_byte.Main_testN2;dot.junit.opcodes.aput_byte.d.T_aput_byte_1 ;aput-byte;Normal #2;Put byte into array
dot.junit.opcodes.aput_byte.Main_testN3;dot.junit.opcodes.aput_byte.d.T_aput_byte_8 ;aput-byte;Normal #3;Type of index argument - float. Dalvik doens't distinguish 32-bits types internally, so this array[float]=value makes no sense but shall not crash the VM.
dot.junit.opcodes.aput_byte.Main_testVFE1;dot.junit.opcodes.aput_byte.d.T_aput_byte_2 ;aput-byte;Verifier #1; Constraint B1, types of arguments - array, double, short
dot.junit.opcodes.aput_byte.Main_testVFE2;dot.junit.opcodes.aput_byte.d.T_aput_byte_3 ;aput-byte;Verifier #2; Constraint B1, types of arguments - array, int, long
dot.junit.opcodes.aput_byte.Main_testVFE3;dot.junit.opcodes.aput_byte.d.T_aput_byte_4 ;aput-byte;Verifier #3; Constraint B1, types of arguments - object, int, short
dot.junit.opcodes.aput_byte.Main_testVFE4;dot.junit.opcodes.aput_byte.d.T_aput_byte_5 ;aput-byte;Verifier #4; Constraint B1, types of arguments - double[], int, short
dot.junit.opcodes.aput_byte.Main_testVFE5;dot.junit.opcodes.aput_byte.d.T_aput_byte_6 ;aput-byte;Verifier #5; Constraint B1, types of arguments - long[], int, short
dot.junit.opcodes.aput_byte.Main_testVFE6;dot.junit.opcodes.aput_byte.d.T_aput_byte_7 ;aput-byte;Verifier #6; Constraint B1, types of arguments - array, reference, short
dot.junit.opcodes.aput_byte.Main_testVFE7;dot.junit.opcodes.aput_byte.d.T_aput_byte_9 ;aput-byte;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.aput_byte.Main_testVFE8;dot.junit.opcodes.aput_byte.d.T_aput_byte_10 ;aput-byte;Verifier #8; Constraint B15, put value 128 into byte array
dot.junit.opcodes.aput_char.Main_testE1;dot.junit.opcodes.aput_char.d.T_aput_char_1 ;aput-char;Exception #1;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.aput_char.Main_testE2;dot.junit.opcodes.aput_char.d.T_aput_char_1 ;aput-char;Exception #2;Expected NullPointerException
dot.junit.opcodes.aput_char.Main_testE3;dot.junit.opcodes.aput_char.d.T_aput_char_1 ;aput-char;Exception #3;Expected ArrayIndexOutOfBoundsException (negative index)
dot.junit.opcodes.aput_char.Main_testN1;dot.junit.opcodes.aput_char.d.T_aput_char_1 ;aput-char;Normal #1;Put char into array
dot.junit.opcodes.aput_char.Main_testN2;dot.junit.opcodes.aput_char.d.T_aput_char_1 ;aput-char;Normal #2;Put char into array
dot.junit.opcodes.aput_char.Main_testN3;dot.junit.opcodes.aput_char.d.T_aput_char_8 ;aput-char;Normal #3;Type of index argument - float. Dalvik doens't distinguish 32-bits types internally, so this array[float]=value makes no sense but shall not crash the VM.
dot.junit.opcodes.aput_char.Main_testVFE1;dot.junit.opcodes.aput_char.d.T_aput_char_2 ;aput-char;Verifier #1; Constraint B1, types of arguments - array, double, char
dot.junit.opcodes.aput_char.Main_testVFE2;dot.junit.opcodes.aput_char.d.T_aput_char_3 ;aput-char;Verifier #2; Constraint B1, types of arguments - array, int, long
dot.junit.opcodes.aput_char.Main_testVFE3;dot.junit.opcodes.aput_char.d.T_aput_char_4 ;aput-char;Verifier #3; Constraint B1, types of arguments - object, int, char
dot.junit.opcodes.aput_char.Main_testVFE4;dot.junit.opcodes.aput_char.d.T_aput_char_5 ;aput-char;Verifier #4; Constraint B1, types of arguments - double[], int, char
dot.junit.opcodes.aput_char.Main_testVFE5;dot.junit.opcodes.aput_char.d.T_aput_char_6 ;aput-char;Verifier #5; Constraint B1, types of arguments - long[], int, char
dot.junit.opcodes.aput_char.Main_testVFE6;dot.junit.opcodes.aput_char.d.T_aput_char_7 ;aput-char;Verifier #6; Constraint B1, types of arguments - array, reference, char
dot.junit.opcodes.aput_char.Main_testVFE7;dot.junit.opcodes.aput_char.d.T_aput_char_9 ;aput-char;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.aput_char.Main_testVFE9;dot.junit.opcodes.aput_char.d.T_aput_char_10 ;aput-char;Verifier #9; Constraint B15, put value 65536 into char array
dot.junit.opcodes.aput_object.Main_testE1;dot.junit.opcodes.aput_object.d.T_aput_object_1 ;aput-object;Exception #1;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.aput_object.Main_testE2;dot.junit.opcodes.aput_object.d.T_aput_object_1 ;aput-object;Exception #2;Expected ArrayIndexOutOfBoundsException (negative index)
dot.junit.opcodes.aput_object.Main_testE3;dot.junit.opcodes.aput_object.d.T_aput_object_1 ;aput-object;Exception #3;Expected NullPointerException
dot.junit.opcodes.aput_object.Main_testE4;dot.junit.opcodes.aput_object.d.T_aput_object_4 ;aput-object;Exception #4;Expected ArrayStoreException
dot.junit.opcodes.aput_object.Main_testN1;dot.junit.opcodes.aput_object.d.T_aput_object_1 ;aput-object;Normal #1;Put reference into array
dot.junit.opcodes.aput_object.Main_testN2;dot.junit.opcodes.aput_object.d.T_aput_object_1 ;aput-object;Normal #2;Put reference into array
dot.junit.opcodes.aput_object.Main_testN3;dot.junit.opcodes.aput_object.d.T_aput_object_2 ;aput-object;Normal #3;Put reference into array
dot.junit.opcodes.aput_object.Main_testN4;dot.junit.opcodes.aput_object.d.T_aput_object_3 ;aput-object;Normal #4;Check assignement compatibility rules
dot.junit.opcodes.aput_object.Main_testN5;dot.junit.opcodes.aput_object.d.T_aput_object_12 ;aput-object;Normal #5;Type of index argument - float. Dalvik doens't distinguish 32-bits types internally, so this array[float]=value makes no sense but shall not crash the VM.
dot.junit.opcodes.aput_object.Main_testVFE1;dot.junit.opcodes.aput_object.d.T_aput_object_5 ;aput-object;Verifier #1; Constraint B1, types of arguments - array, double, String
dot.junit.opcodes.aput_object.Main_testVFE2;dot.junit.opcodes.aput_object.d.T_aput_object_6 ;aput-object;Verifier #2; Constraint B1, types of arguments - array, int, long
dot.junit.opcodes.aput_object.Main_testVFE3;dot.junit.opcodes.aput_object.d.T_aput_object_7 ;aput-object;Verifier #3; Constraint B1, types of arguments - object, int, String
dot.junit.opcodes.aput_object.Main_testVFE4;dot.junit.opcodes.aput_object.d.T_aput_object_8 ;aput-object;Verifier #4; Constraint B1, types of arguments - float[], int, String
dot.junit.opcodes.aput_object.Main_testVFE5;dot.junit.opcodes.aput_object.d.T_aput_object_9 ;aput-object;Verifier #5; Constraint B1, types of arguments - long[], int, String
dot.junit.opcodes.aput_object.Main_testVFE6;dot.junit.opcodes.aput_object.d.T_aput_object_10 ;aput-object;Verifier #6; Constraint B1, types of arguments - array, reference, String
dot.junit.opcodes.aput_object.Main_testVFE7;dot.junit.opcodes.aput_object.d.T_aput_object_11 ;aput-object;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.aput_object.Main_testVFE8;dot.junit.opcodes.aput_object.d.T_aput_object_13 ;aput-object;Verifier #8; Constraint B15, put integer into array of references
dot.junit.opcodes.aput_short.Main_testE1;dot.junit.opcodes.aput_short.d.T_aput_short_1 ;aput-short;Exception #1;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.aput_short.Main_testE2;dot.junit.opcodes.aput_short.d.T_aput_short_1 ;aput-short;Exception #2;Expected NullPointerException
dot.junit.opcodes.aput_short.Main_testE3;dot.junit.opcodes.aput_short.d.T_aput_short_1 ;aput-short;Exception #3;Expected ArrayIndexOutOfBoundsException (negative index)
dot.junit.opcodes.aput_short.Main_testN1;dot.junit.opcodes.aput_short.d.T_aput_short_1 ;aput-short;Normal #1;Put short into array
dot.junit.opcodes.aput_short.Main_testN2;dot.junit.opcodes.aput_short.d.T_aput_short_1 ;aput-short;Normal #2;Put short into array
dot.junit.opcodes.aput_short.Main_testN3;dot.junit.opcodes.aput_short.d.T_aput_short_8 ;aput-short;Normal #3;Type of index argument - float. Dalvik doens't distinguish 32-bits types internally, so this array[float]=value makes no sense but shall not crash the VM.
dot.junit.opcodes.aput_short.Main_testVFE1;dot.junit.opcodes.aput_short.d.T_aput_short_2 ;aput-short;Verifier #1; Constraint B1, types of arguments - array, double, int
dot.junit.opcodes.aput_short.Main_testVFE2;dot.junit.opcodes.aput_short.d.T_aput_short_3 ;aput-short;Verifier #2; Constraint B1, types of arguments - array, int, long
dot.junit.opcodes.aput_short.Main_testVFE3;dot.junit.opcodes.aput_short.d.T_aput_short_4 ;aput-short;Verifier #3; Constraint B1, types of arguments - object, int, int
dot.junit.opcodes.aput_short.Main_testVFE4;dot.junit.opcodes.aput_short.d.T_aput_short_5 ;aput-short;Verifier #4; Constraint B1, types of arguments - double[], int, int
dot.junit.opcodes.aput_short.Main_testVFE5;dot.junit.opcodes.aput_short.d.T_aput_short_6 ;aput-short;Verifier #5; Constraint B1, types of arguments - long[], int, int
dot.junit.opcodes.aput_short.Main_testVFE6;dot.junit.opcodes.aput_short.d.T_aput_short_7 ;aput-short;Verifier #6; Constraint B1, types of arguments - array, reference, int
dot.junit.opcodes.aput_short.Main_testVFE7;dot.junit.opcodes.aput_short.d.T_aput_short_9 ;aput-short;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.aput_short.Main_testVFE8;dot.junit.opcodes.aput_short.d.T_aput_short_10 ;aput-short;Verifier #8; Constraint B15, put value 32768 into array of shorts
dot.junit.opcodes.aput.Main_testE1;dot.junit.opcodes.aput.d.T_aput_1 ;aput;Exception #1;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.aput.Main_testE2;dot.junit.opcodes.aput.d.T_aput_1 ;aput;Exception #2;Expected NullPointerException
dot.junit.opcodes.aput.Main_testE3;dot.junit.opcodes.aput.d.T_aput_1 ;aput;Exception #3;Expected ArrayIndexOutOfBoundsException (negative index)
dot.junit.opcodes.aput.Main_testN1;dot.junit.opcodes.aput.d.T_aput_1 ;aput;Normal #1;Put int into array
dot.junit.opcodes.aput.Main_testN2;dot.junit.opcodes.aput.d.T_aput_1 ;aput;Normal #2;Put int into array
dot.junit.opcodes.aput.Main_testN3;dot.junit.opcodes.aput.d.T_aput_8 ;aput;Normal #3;Type of index argument - float. Dalvik doens't distinguish 32-bits types internally, so this array[float]=value makes no sense but shall not crash the VM.
dot.junit.opcodes.aput.Main_testVFE1;dot.junit.opcodes.aput.d.T_aput_2 ;aput;Verifier #1; Constraint B1, types of arguments - array, double, int
dot.junit.opcodes.aput.Main_testVFE2;dot.junit.opcodes.aput.d.T_aput_3 ;aput;Verifier #2; Constraint B1, types of arguments - array, int, long
dot.junit.opcodes.aput.Main_testVFE3;dot.junit.opcodes.aput.d.T_aput_4 ;aput;Verifier #3; Constraint B1, types of arguments - object, int, int
dot.junit.opcodes.aput.Main_testVFE4;dot.junit.opcodes.aput.d.T_aput_5 ;aput;Verifier #4; Constraint B1, types of arguments - double[], int, int
dot.junit.opcodes.aput.Main_testVFE5;dot.junit.opcodes.aput.d.T_aput_6 ;aput;Verifier #5; Constraint B1, types of arguments - long[], int, int
dot.junit.opcodes.aput.Main_testVFE6;dot.junit.opcodes.aput.d.T_aput_7 ;aput;Verifier #6; Constraint B1, types of arguments - array, reference, int
dot.junit.opcodes.aput.Main_testVFE7;dot.junit.opcodes.aput.d.T_aput_9 ;aput;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.aput_wide.Main_testE1;dot.junit.opcodes.aput_wide.d.T_aput_wide_1 ;aput-wide;Exception #1;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.aput_wide.Main_testE2;dot.junit.opcodes.aput_wide.d.T_aput_wide_1 ;aput-wide;Exception #2;Expected NullPointerException
dot.junit.opcodes.aput_wide.Main_testE3;dot.junit.opcodes.aput_wide.d.T_aput_wide_1 ;aput-wide;Exception #3;Expected ArrayIndexOutOfBoundsException (negative index)
dot.junit.opcodes.aput_wide.Main_testN1;dot.junit.opcodes.aput_wide.d.T_aput_wide_1 ;aput-wide;Normal #1;Put long into array
dot.junit.opcodes.aput_wide.Main_testN2;dot.junit.opcodes.aput_wide.d.T_aput_wide_1 ;aput-wide;Normal #2;Put long into array
dot.junit.opcodes.aput_wide.Main_testN3;dot.junit.opcodes.aput_wide.d.T_aput_wide_2 ;aput-wide;Normal #3;Put double into array
dot.junit.opcodes.aput_wide.Main_testN4;dot.junit.opcodes.aput_wide.d.T_aput_wide_9 ;aput-wide;Normal #4;Type of index argument - float. Dalvik doens't distinguish 64-bits types internally, so this array[float]=value makes no sense but shall not crash the VM.
dot.junit.opcodes.aput_wide.Main_testN5;dot.junit.opcodes.aput_wide.d.T_aput_wide_6 ;aput-wide;Normal #5;Try to put long into double[]. Dalvik doens't distinguish 64-bits types internally, so this operation makes no sense but shall not crash the VM.
dot.junit.opcodes.aput_wide.Main_testVFE1;dot.junit.opcodes.aput_wide.d.T_aput_wide_3 ;aput-wide;Verifier #1; Constraint B1, types of arguments - array, double, long
dot.junit.opcodes.aput_wide.Main_testVFE2;dot.junit.opcodes.aput_wide.d.T_aput_wide_4 ;aput-wide;Verifier #2; Constraint B1, types of arguments - array, int, int
dot.junit.opcodes.aput_wide.Main_testVFE3;dot.junit.opcodes.aput_wide.d.T_aput_wide_5 ;aput-wide;Verifier #3; Constraint B1, types of arguments - object, int, long
dot.junit.opcodes.aput_wide.Main_testVFE5;dot.junit.opcodes.aput_wide.d.T_aput_wide_7 ;aput-wide;Verifier #5; Constraint B1, types of arguments - int[], int, long
dot.junit.opcodes.aput_wide.Main_testVFE6;dot.junit.opcodes.aput_wide.d.T_aput_wide_8 ;aput-wide;Verifier #6; Constraint B1, types of arguments - array, reference, long
dot.junit.opcodes.aput_wide.Main_testVFE7;dot.junit.opcodes.aput_wide.d.T_aput_wide_10 ;aput-wide;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.array_length.Main_testN1;dot.junit.opcodes.array_length.d.T_array_length_1 ;array-length;Normal #1;Get length of array of references
dot.junit.opcodes.array_length.Main_testN2;dot.junit.opcodes.array_length.d.T_array_length_4 ;array-length;Normal #2;Get length of array of doubles
dot.junit.opcodes.array_length.Main_testNPE1;dot.junit.opcodes.array_length.d.T_array_length_1 ;array-length;Normal #PE1;Expected NullPointerException
dot.junit.opcodes.array_length.Main_testVFE1;dot.junit.opcodes.array_length.d.T_array_length_2 ;array-length;Verifier #1; Constraint B1, types of arguments - Object
dot.junit.opcodes.array_length.Main_testVFE2;dot.junit.opcodes.array_length.d.T_array_length_3 ;array-length;Verifier #2; Constraint B1, types of arguments - int
dot.junit.opcodes.array_length.Main_testVFE3;dot.junit.opcodes.array_length.d.T_array_length_5 ;array-length;Verifier #3; Constraint A23, number of registers
dot.junit.opcodes.check_cast.Main_testE1;dot.junit.opcodes.check_cast.d.T_check_cast_1 ;check-cast;Exception #1;Expected ClassCastException
dot.junit.opcodes.check_cast.Main_testN1;dot.junit.opcodes.check_cast.d.T_check_cast_1 ;check-cast;Normal #1;(String)(Object)String
dot.junit.opcodes.check_cast.Main_testN2;dot.junit.opcodes.check_cast.d.T_check_cast_1 ;check-cast;Normal #2;(String)(Object)null
dot.junit.opcodes.check_cast.Main_testN4;dot.junit.opcodes.check_cast.d.T_check_cast_2 ;check-cast;Normal #4;Check assignment compatibility rules
dot.junit.opcodes.check_cast.Main_testVFE1;dot.junit.opcodes.check_cast.d.T_check_cast_4 ;check-cast;Verifier #1; Constraint A18, constant pool index
dot.junit.opcodes.check_cast.Main_testVFE2;dot.junit.opcodes.check_cast.d.T_check_cast_5 ;check-cast;Verifier #2; Constraint B1, type of argument - int
dot.junit.opcodes.check_cast.Main_testVFE3;dot.junit.opcodes.check_cast.d.T_check_cast_8 ;check-cast;Verifier #3; Constraint B1, type of argument - long
dot.junit.opcodes.check_cast.Main_testVFE4;dot.junit.opcodes.check_cast.d.T_check_cast_6 ;check-cast;Verifier #4; Constraint B1, number of registers
dot.junit.opcodes.check_cast.Main_testVFE5;dot.junit.opcodes.check_cast.TestStubs dot.junit.opcodes.check_cast.d.T_check_cast_3 ;check-cast;Verifier #5; Constraint n/a, Attempt to access inaccessible class, expect throws IllegalAccessError
dot.junit.opcodes.check_cast.Main_testVFE6;dot.junit.opcodes.check_cast.d.T_check_cast_7 ;check-cast;Verifier #6; Constraint n/a, Attempt to access undefined class, expect throws NoClassDefFoundError on first access
dot.junit.opcodes.check_cast.Main_testVFE7;dot.junit.opcodes.check_cast.d.T_check_cast_9 ;check-cast;Verifier #7; Constraint A18, constant pool type
dot.junit.opcodes.cmpg_double.Main_testB1;dot.junit.opcodes.cmpg_double.d.T_cmpg_double_1 ;cmpg-double;Boundary #1;Arguments = Double.NaN, Double.MAX_VALUE
dot.junit.opcodes.cmpg_double.Main_testB2;dot.junit.opcodes.cmpg_double.d.T_cmpg_double_1 ;cmpg-double;Boundary #2;Arguments = +0, -0
dot.junit.opcodes.cmpg_double.Main_testB3;dot.junit.opcodes.cmpg_double.d.T_cmpg_double_1 ;cmpg-double;Boundary #3;Arguments = Double.NEGATIVE_INFINITY, Double.MIN_VALUE
dot.junit.opcodes.cmpg_double.Main_testB4;dot.junit.opcodes.cmpg_double.d.T_cmpg_double_1 ;cmpg-double;Boundary #4;Arguments = Double.POSITIVE_INFINITY, Double.MAX_VALUE
dot.junit.opcodes.cmpg_double.Main_testB5;dot.junit.opcodes.cmpg_double.d.T_cmpg_double_1 ;cmpg-double;Boundary #5;Arguments = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
dot.junit.opcodes.cmpg_double.Main_testN1;dot.junit.opcodes.cmpg_double.d.T_cmpg_double_1 ;cmpg-double;Normal #1;Arguments = 3.14d, 2.7d
dot.junit.opcodes.cmpg_double.Main_testN2;dot.junit.opcodes.cmpg_double.d.T_cmpg_double_1 ;cmpg-double;Normal #2;Arguments = -3.14d, 2.7d
dot.junit.opcodes.cmpg_double.Main_testN3;dot.junit.opcodes.cmpg_double.d.T_cmpg_double_1 ;cmpg-double;Normal #3;Arguments = 3.14, 3.14
dot.junit.opcodes.cmpg_double.Main_testN4;dot.junit.opcodes.cmpg_double.d.T_cmpg_double_3 ;cmpg-double;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this comparison of long and double makes no sense but shall not crash the VM.
dot.junit.opcodes.cmpg_double.Main_testVFE1;dot.junit.opcodes.cmpg_double.d.T_cmpg_double_2 ;cmpg-double;Verifier #1; Constraint B1, types of arguments - double, float
dot.junit.opcodes.cmpg_double.Main_testVFE2;dot.junit.opcodes.cmpg_double.d.T_cmpg_double_5 ;cmpg-double;Verifier #2; Constraint A24, number of registers
dot.junit.opcodes.cmpg_double.Main_testVFE3;dot.junit.opcodes.cmpg_double.d.T_cmpg_double_4 ;cmpg-double;Verifier #3; Constraint B1, types of arguments - double, reference
dot.junit.opcodes.cmpg_double.Main_testVFE4;dot.junit.opcodes.cmpg_double.d.T_cmpg_double_6 ;cmpg-double;Verifier #4; Constraint B1, types of arguments - int, int
dot.junit.opcodes.cmpg_float.Main_testB1;dot.junit.opcodes.cmpg_float.d.T_cmpg_float_1 ;cmpg-float;Boundary #1;Arguments = Float.NaN, Float.MAX_VALUE
dot.junit.opcodes.cmpg_float.Main_testB2;dot.junit.opcodes.cmpg_float.d.T_cmpg_float_1 ;cmpg-float;Boundary #2;Arguments = +0, -0
dot.junit.opcodes.cmpg_float.Main_testB3;dot.junit.opcodes.cmpg_float.d.T_cmpg_float_1 ;cmpg-float;Boundary #3;Arguments = Float.NEGATIVE_INFINITY, Float.MIN_VALUE
dot.junit.opcodes.cmpg_float.Main_testB4;dot.junit.opcodes.cmpg_float.d.T_cmpg_float_1 ;cmpg-float;Boundary #4;Arguments = Float.POSITIVE_INFINITY, Float.MAX_VALUE
dot.junit.opcodes.cmpg_float.Main_testB5;dot.junit.opcodes.cmpg_float.d.T_cmpg_float_1 ;cmpg-float;Boundary #5;Arguments = Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY
dot.junit.opcodes.cmpg_float.Main_testN1;dot.junit.opcodes.cmpg_float.d.T_cmpg_float_1 ;cmpg-float;Normal #1;Arguments = 3.14f, 2.7f
dot.junit.opcodes.cmpg_float.Main_testN2;dot.junit.opcodes.cmpg_float.d.T_cmpg_float_1 ;cmpg-float;Normal #2;Arguments = -3.14f, 2.7f
dot.junit.opcodes.cmpg_float.Main_testN3;dot.junit.opcodes.cmpg_float.d.T_cmpg_float_1 ;cmpg-float;Normal #3;Arguments = 3.14, 3.14
dot.junit.opcodes.cmpg_float.Main_testN4;dot.junit.opcodes.cmpg_float.d.T_cmpg_float_6 ;cmpg-float;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this comparison of int and float makes no sense but shall not crash the VM.
dot.junit.opcodes.cmpg_float.Main_testVFE1;dot.junit.opcodes.cmpg_float.d.T_cmpg_float_2 ;cmpg-float;Verifier #1; Constraint B1, types of arguments - float, double
dot.junit.opcodes.cmpg_float.Main_testVFE2;dot.junit.opcodes.cmpg_float.d.T_cmpg_float_3 ;cmpg-float;Verifier #2; Constraint B1, types of arguments - long, float
dot.junit.opcodes.cmpg_float.Main_testVFE3;dot.junit.opcodes.cmpg_float.d.T_cmpg_float_4 ;cmpg-float;Verifier #3; Constraint B1, types of arguments - reference, float
dot.junit.opcodes.cmpg_float.Main_testVFE4;dot.junit.opcodes.cmpg_float.d.T_cmpg_float_5 ;cmpg-float;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.cmpl_double.Main_testB1;dot.junit.opcodes.cmpl_double.d.T_cmpl_double_1 ;cmpl-double;Boundary #1;Arguments = Double.NaN, Double.MAX_VALUE
dot.junit.opcodes.cmpl_double.Main_testB2;dot.junit.opcodes.cmpl_double.d.T_cmpl_double_1 ;cmpl-double;Boundary #2;Arguments = +0, -0
dot.junit.opcodes.cmpl_double.Main_testB3;dot.junit.opcodes.cmpl_double.d.T_cmpl_double_1 ;cmpl-double;Boundary #3;Arguments = Double.NEGATIVE_INFINITY, Double.MIN_VALUE
dot.junit.opcodes.cmpl_double.Main_testB4;dot.junit.opcodes.cmpl_double.d.T_cmpl_double_1 ;cmpl-double;Boundary #4;Arguments = Double.POSITIVE_INFINITY, Double.MAX_VALUE
dot.junit.opcodes.cmpl_double.Main_testB5;dot.junit.opcodes.cmpl_double.d.T_cmpl_double_1 ;cmpl-double;Boundary #5;Arguments = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
dot.junit.opcodes.cmpl_double.Main_testN1;dot.junit.opcodes.cmpl_double.d.T_cmpl_double_1 ;cmpl-double;Normal #1;Arguments = 3.14d, 2.7d
dot.junit.opcodes.cmpl_double.Main_testN2;dot.junit.opcodes.cmpl_double.d.T_cmpl_double_1 ;cmpl-double;Normal #2;Arguments = -3.14d, 2.7d
dot.junit.opcodes.cmpl_double.Main_testN3;dot.junit.opcodes.cmpl_double.d.T_cmpl_double_1 ;cmpl-double;Normal #3;Arguments = 3.14, 3.14
dot.junit.opcodes.cmpl_double.Main_testN4;dot.junit.opcodes.cmpl_double.d.T_cmpl_double_3 ;cmpl-double;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this comparison of long and double makes no sense but shall not crash the VM.
dot.junit.opcodes.cmpl_double.Main_testVFE1;dot.junit.opcodes.cmpl_double.d.T_cmpl_double_2 ;cmpl-double;Verifier #1; Constraint B1, types of arguments - double, float
dot.junit.opcodes.cmpl_double.Main_testVFE2;dot.junit.opcodes.cmpl_double.d.T_cmpl_double_5 ;cmpl-double;Verifier #2; Constraint A24, number of registers
dot.junit.opcodes.cmpl_double.Main_testVFE3;dot.junit.opcodes.cmpl_double.d.T_cmpl_double_4 ;cmpl-double;Verifier #3; Constraint B1, types of arguments - double, reference
dot.junit.opcodes.cmpl_double.Main_testVFE4;dot.junit.opcodes.cmpl_double.d.T_cmpl_double_6 ;cmpl-double;Verifier #4; Constraint B1, types of arguments - int, int
dot.junit.opcodes.cmpl_float.Main_testB1;dot.junit.opcodes.cmpl_float.d.T_cmpl_float_1 ;cmpl-float;Boundary #1;Arguments = Float.NaN, Float.MAX_VALUE
dot.junit.opcodes.cmpl_float.Main_testB2;dot.junit.opcodes.cmpl_float.d.T_cmpl_float_1 ;cmpl-float;Boundary #2;Arguments = +0, -0
dot.junit.opcodes.cmpl_float.Main_testB3;dot.junit.opcodes.cmpl_float.d.T_cmpl_float_1 ;cmpl-float;Boundary #3;Arguments = Float.NEGATIVE_INFINITY, Float.MIN_VALUE
dot.junit.opcodes.cmpl_float.Main_testB4;dot.junit.opcodes.cmpl_float.d.T_cmpl_float_1 ;cmpl-float;Boundary #4;Arguments = Float.POSITIVE_INFINITY, Float.MAX_VALUE
dot.junit.opcodes.cmpl_float.Main_testB5;dot.junit.opcodes.cmpl_float.d.T_cmpl_float_1 ;cmpl-float;Boundary #5;Arguments = Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY
dot.junit.opcodes.cmpl_float.Main_testN1;dot.junit.opcodes.cmpl_float.d.T_cmpl_float_1 ;cmpl-float;Normal #1;Arguments = 3.14f, 2.7f
dot.junit.opcodes.cmpl_float.Main_testN2;dot.junit.opcodes.cmpl_float.d.T_cmpl_float_1 ;cmpl-float;Normal #2;Arguments = -3.14f, 2.7f
dot.junit.opcodes.cmpl_float.Main_testN3;dot.junit.opcodes.cmpl_float.d.T_cmpl_float_1 ;cmpl-float;Normal #3;Arguments = 3.14, 3.14
dot.junit.opcodes.cmpl_float.Main_testN4;dot.junit.opcodes.cmpl_float.d.T_cmpl_float_6 ;cmpl-float;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this comparison of int and float makes no sense but shall not crash the VM.
dot.junit.opcodes.cmpl_float.Main_testVFE1;dot.junit.opcodes.cmpl_float.d.T_cmpl_float_2 ;cmpl-float;Verifier #1; Constraint B1, types of arguments - float, double
dot.junit.opcodes.cmpl_float.Main_testVFE2;dot.junit.opcodes.cmpl_float.d.T_cmpl_float_3 ;cmpl-float;Verifier #2; Constraint B1, types of arguments - long, float
dot.junit.opcodes.cmpl_float.Main_testVFE3;dot.junit.opcodes.cmpl_float.d.T_cmpl_float_4 ;cmpl-float;Verifier #3; Constraint B1, types of arguments - reference, float
dot.junit.opcodes.cmpl_float.Main_testVFE4;dot.junit.opcodes.cmpl_float.d.T_cmpl_float_5 ;cmpl-float;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.cmp_long.Main_testB1;dot.junit.opcodes.cmp_long.d.T_cmp_long_1 ;cmp-long;Boundary #1;Arguments = Long.MAX_VALUE > Long.MIN_VALUE
dot.junit.opcodes.cmp_long.Main_testB2;dot.junit.opcodes.cmp_long.d.T_cmp_long_1 ;cmp-long;Boundary #2;Arguments = Long.MIN_VALUE < Long.MAX_VALUE
dot.junit.opcodes.cmp_long.Main_testB3;dot.junit.opcodes.cmp_long.d.T_cmp_long_1 ;cmp-long;Boundary #3;Arguments = 1 > 0
dot.junit.opcodes.cmp_long.Main_testB4;dot.junit.opcodes.cmp_long.d.T_cmp_long_1 ;cmp-long;Boundary #4;Arguments = 0 > -1
dot.junit.opcodes.cmp_long.Main_testB5;dot.junit.opcodes.cmp_long.d.T_cmp_long_1 ;cmp-long;Boundary #5;Arguments = -1 < 0
dot.junit.opcodes.cmp_long.Main_testB6;dot.junit.opcodes.cmp_long.d.T_cmp_long_1 ;cmp-long;Boundary #6;Arguments = 0 = 0
dot.junit.opcodes.cmp_long.Main_testN1;dot.junit.opcodes.cmp_long.d.T_cmp_long_1 ;cmp-long;Normal #1;Arguments = 111234567891l > 111234567890l
dot.junit.opcodes.cmp_long.Main_testN2;dot.junit.opcodes.cmp_long.d.T_cmp_long_1 ;cmp-long;Normal #2;Arguments = 112234567890 = 112234567890
dot.junit.opcodes.cmp_long.Main_testN3;dot.junit.opcodes.cmp_long.d.T_cmp_long_1 ;cmp-long;Normal #3;Arguments = 112234567890 < 998876543210
dot.junit.opcodes.cmp_long.Main_testN4;dot.junit.opcodes.cmp_long.d.T_cmp_long_2 ;cmp-long;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this comparison of long and double makes no sense but shall not crash the VM.
dot.junit.opcodes.cmp_long.Main_testVFE1;dot.junit.opcodes.cmp_long.d.T_cmp_long_3 ;cmp-long;Verifier #1; Constraint B1, types of arguments - float, long
dot.junit.opcodes.cmp_long.Main_testVFE2;dot.junit.opcodes.cmp_long.d.T_cmp_long_4 ;cmp-long;Verifier #2; Constraint B1, types of arguments - int, long
dot.junit.opcodes.cmp_long.Main_testVFE3;dot.junit.opcodes.cmp_long.d.T_cmp_long_5 ;cmp-long;Verifier #3; Constraint B1, types of arguments - reference, long
dot.junit.opcodes.cmp_long.Main_testVFE4;dot.junit.opcodes.cmp_long.d.T_cmp_long_6 ;cmp-long;Verifier #4; Constraint A24, number of registers
dot.junit.opcodes.const_16.Main_testN2;dot.junit.opcodes.const_16.d.T_const_16_1 ;const/16;Normal #2;Const/16 v254, -20000
dot.junit.opcodes.const_16.Main_testVFE1;dot.junit.opcodes.const_16.d.T_const_16_3 ;const/16;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.const_16.Main_testVFE2;dot.junit.opcodes.const_16.d.T_const_16_4 ;const/16;Verifier #2; Constraint B11, When writing to a register that is one half of a register  pair, but not touching the other half, the old register pair gets broken up, and the  other register involved in it becomes undefined
dot.junit.opcodes.const_4.Main_testN2;dot.junit.opcodes.const_4.d.T_const_4_1 ;const/4;Normal #2;Const/4 v15, -4
dot.junit.opcodes.const_4.Main_testVFE1;dot.junit.opcodes.const_4.d.T_const_4_3 ;const/4;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.const_4.Main_testVFE2;dot.junit.opcodes.const_4.d.T_const_4_4 ;const/4;Verifier #2; Constraint B11, When writing to a register that is one half of a register  pair, but not touching the other half, the old register pair gets broken up, and the  other register involved in it becomes undefined
dot.junit.opcodes.const_class.Main_testE1;dot.junit.opcodes.const_class.d.T_const_class_6 ;const-class;Exception #1;Class definition not found
dot.junit.opcodes.const_class.Main_testE2;dot.junit.opcodes.const_class.TestStubs dot.junit.opcodes.const_class.d.T_const_class_7 ;const-class;Exception #2;Class is not accessible
dot.junit.opcodes.const_class.Main_testN1;dot.junit.opcodes.const_class.d.T_const_class_1 ;const-class;Normal #1;Const-class v254, java/lang/String
dot.junit.opcodes.const_class.Main_testN2;dot.junit.opcodes.const_class.d.T_const_class_2 ;const-class;Normal #2;Const-class v254, I
dot.junit.opcodes.const_class.Main_testVFE1;dot.junit.opcodes.const_class.d.T_const_class_3 ;const-class;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.const_class.Main_testVFE2;dot.junit.opcodes.const_class.d.T_const_class_4 ;const-class;Verifier #2; Constraint B11, When writing to a register that is one half of a register  pair, but not touching the other half, the old register pair gets broken up, and the  other register involved in it becomes undefined
dot.junit.opcodes.const_class.Main_testVFE3;dot.junit.opcodes.const_class.d.T_const_class_5 ;const-class;Verifier #3; Constraint A18, constant pool index
dot.junit.opcodes.const_high16.Main_testN1;dot.junit.opcodes.const_high16.d.T_const_high16_1 ;const/high16;Normal #1;Const/high16 v254, 0x12340000
dot.junit.opcodes.const_high16.Main_testVFE1;dot.junit.opcodes.const_high16.d.T_const_high16_3 ;const/high16;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.const_high16.Main_testVFE2;dot.junit.opcodes.const_high16.d.T_const_high16_4 ;const/high16;Verifier #2; Constraint B11, When writing to a register that is one half of a register  pair, but not touching the other half, the old register pair gets broken up, and the  other register involved in it becomes undefined
dot.junit.opcodes.const_string_jumbo.Main_testN1;dot.junit.opcodes.const_string_jumbo.d.T_const_string_jumbo_1 ;const-string/jumbo;Normal #1;Const-string/jumbo v254, "android jumbo"
dot.junit.opcodes.const_string_jumbo.Main_testVFE1;dot.junit.opcodes.const_string_jumbo.d.T_const_string_jumbo_3 ;const-string/jumbo;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.const_string_jumbo.Main_testVFE2;dot.junit.opcodes.const_string_jumbo.d.T_const_string_jumbo_4 ;const-string/jumbo;Verifier #2; Constraint B11, When writing to a register that is one half of a register  pair, but not touching the other half, the old register pair gets broken up, and the  other register involved in it becomes undefined
dot.junit.opcodes.const_string_jumbo.Main_testVFE3;dot.junit.opcodes.const_string_jumbo.d.T_const_string_jumbo_5 ;const-string/jumbo;Verifier #3; Constraint A9, constant pool index
dot.junit.opcodes.const_string.Main_testN1;dot.junit.opcodes.const_string.d.T_const_string_1 ;const-string;Normal #1;Const-string v254, "android"
dot.junit.opcodes.const_string.Main_testVFE1;dot.junit.opcodes.const_string.d.T_const_string_3 ;const-string;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.const_string.Main_testVFE2;dot.junit.opcodes.const_string.d.T_const_string_4 ;const-string;Verifier #2; Constraint B11, When writing to a register that is one half of a register  pair, but not touching the other half, the old register pair gets broken up, and the  other register involved in it becomes undefined
dot.junit.opcodes.const_string.Main_testVFE3;dot.junit.opcodes.const_string.d.T_const_string_5 ;const-string;Verifier #3; Constraint A9, constant pool index
dot.junit.opcodes.const_wide_16.Main_testN1;dot.junit.opcodes.const_wide_16.d.T_const_wide_16_1 ;const-wide/16;Normal #1;Const-wide/16 v253, 20000
dot.junit.opcodes.const_wide_16.Main_testVFE1;dot.junit.opcodes.const_wide_16.d.T_const_wide_16_3 ;const-wide/16;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.const_wide_16.Main_testVFE2;dot.junit.opcodes.const_wide_16.d.T_const_wide_16_4 ;const-wide/16;Verifier #2; Constraint B11, When writing to a register that is one half of a register  pair, but not touching the other half, the old register pair gets broken up, and the  other register involved in it becomes undefined
dot.junit.opcodes.const_wide_32.Main_testN1;dot.junit.opcodes.const_wide_32.d.T_const_wide_32_1 ;const-wide/32;Normal #1;Const-wide/32 v253, 20000000
dot.junit.opcodes.const_wide_32.Main_testVFE1;dot.junit.opcodes.const_wide_32.d.T_const_wide_32_3 ;const-wide/32;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.const_wide_32.Main_testVFE2;dot.junit.opcodes.const_wide_32.d.T_const_wide_32_4 ;const-wide/32;Verifier #2; Constraint B11, When writing to a register that is one half of a register  pair, but not touching the other half, the old register pair gets broken up, and the  other register involved in it becomes undefined
dot.junit.opcodes.const_wide_high16.Main_testN2;dot.junit.opcodes.const_wide_high16.d.T_const_wide_high16_1 ;const-wide/high16;Normal #2;Const-wide/high16 v252, 0x1234000000000000
dot.junit.opcodes.const_wide_high16.Main_testVFE1;dot.junit.opcodes.const_wide_high16.d.T_const_wide_high16_3 ;const-wide/high16;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.const_wide_high16.Main_testVFE2;dot.junit.opcodes.const_wide_high16.d.T_const_wide_high16_4 ;const-wide/high16;Verifier #2; Constraint B11, When writing to a register that is one half of a register  pair, but not touching the other half, the old register pair gets broken up, and the  other register involved in it becomes undefined
dot.junit.opcodes.const_wide.Main_testN1;dot.junit.opcodes.const_wide.d.T_const_wide_1 ;const-wide;Normal #1;Const-wide v1, 1.2345678901232324E51
dot.junit.opcodes.const_wide.Main_testN2;dot.junit.opcodes.const_wide.d.T_const_wide_2 ;const-wide;Normal #2;Const-wide v253, 20000000000
dot.junit.opcodes.const_wide.Main_testVFE1;dot.junit.opcodes.const_wide.d.T_const_wide_3 ;const-wide;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.const_wide.Main_testVFE2;dot.junit.opcodes.const_wide.d.T_const_wide_4 ;const-wide;Verifier #2; Constraint B11, When writing to a register that is one half of a register  pair, but not touching the other half, the old register pair gets broken up, and the  other register involved in it becomes undefined
dot.junit.opcodes.div_double_2addr.Main_testB2;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_1 ;div-double/2addr;Boundary #2;Arguments = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
dot.junit.opcodes.div_double_2addr.Main_testB3;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_1 ;div-double/2addr;Boundary #3;Arguments = Double.POSITIVE_INFINITY, -2.7d
dot.junit.opcodes.div_double_2addr.Main_testB4;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_1 ;div-double/2addr;Boundary #4;Arguments = -2.7d, Double.NEGATIVE_INFINITY
dot.junit.opcodes.div_double_2addr.Main_testB5;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_1 ;div-double/2addr;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.div_double_2addr.Main_testB6;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_1 ;div-double/2addr;Boundary #6;Arguments = 0, -2.7
dot.junit.opcodes.div_double_2addr.Main_testB7;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_1 ;div-double/2addr;Boundary #7;Arguments = -2.7, 0
dot.junit.opcodes.div_double_2addr.Main_testB8;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_1 ;div-double/2addr;Boundary #8;Arguments = 1, Double.MAX_VALUE
dot.junit.opcodes.div_double_2addr.Main_testB9;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_1 ;div-double/2addr;Boundary #9;Arguments = Double.MAX_VALUE, -1E-9f
dot.junit.opcodes.div_double_2addr.Main_testN1;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_1 ;div-double/2addr;Normal #1;Arguments = 2.7d, 3.14d
dot.junit.opcodes.div_double_2addr.Main_testN2;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_1 ;div-double/2addr;Normal #2;Dividend = 0
dot.junit.opcodes.div_double_2addr.Main_testN3;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_1 ;div-double/2addr;Normal #3;Dividend is negative
dot.junit.opcodes.div_double_2addr.Main_testN4;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_1 ;div-double/2addr;Normal #4;Dividend is negative
dot.junit.opcodes.div_double_2addr.Main_testN5;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_3 ;div-double/2addr;Normal #5;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this division of long and double makes no sense but shall not crash the VM.
dot.junit.opcodes.div_double_2addr.Main_testVFE1;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_2 ;div-double/2addr;Verifier #1; Constraint B1, types of arguments - float / double
dot.junit.opcodes.div_double_2addr.Main_testVFE2;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_5 ;div-double/2addr;Verifier #2; Constraint A24, number of registers
dot.junit.opcodes.div_double_2addr.Main_testVFE3;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_4 ;div-double/2addr;Verifier #3; Constraint B1, types of arguments - double / reference
dot.junit.opcodes.div_double_2addr.Main_testVFE4;dot.junit.opcodes.div_double_2addr.d.T_div_double_2addr_6 ;div-double/2addr;Verifier #4; Constraint B1, types of arguments - int / int
dot.junit.opcodes.div_double.Main_testB2;dot.junit.opcodes.div_double.d.T_div_double_1 ;div-double;Boundary #2;Arguments = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
dot.junit.opcodes.div_double.Main_testB3;dot.junit.opcodes.div_double.d.T_div_double_1 ;div-double;Boundary #3;Arguments = Double.POSITIVE_INFINITY, -2.7d
dot.junit.opcodes.div_double.Main_testB4;dot.junit.opcodes.div_double.d.T_div_double_1 ;div-double;Boundary #4;Arguments = -2.7d, Double.NEGATIVE_INFINITY
dot.junit.opcodes.div_double.Main_testB5;dot.junit.opcodes.div_double.d.T_div_double_1 ;div-double;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.div_double.Main_testB6;dot.junit.opcodes.div_double.d.T_div_double_1 ;div-double;Boundary #6;Arguments = 0, -2.7
dot.junit.opcodes.div_double.Main_testB7;dot.junit.opcodes.div_double.d.T_div_double_1 ;div-double;Boundary #7;Arguments = -2.7, 0
dot.junit.opcodes.div_double.Main_testB8;dot.junit.opcodes.div_double.d.T_div_double_1 ;div-double;Boundary #8;Arguments = 1, Double.MAX_VALUE
dot.junit.opcodes.div_double.Main_testB9;dot.junit.opcodes.div_double.d.T_div_double_1 ;div-double;Boundary #9;Arguments = Double.MAX_VALUE, -1E-9f
dot.junit.opcodes.div_double.Main_testN1;dot.junit.opcodes.div_double.d.T_div_double_1 ;div-double;Normal #1;Arguments = 2.7d, 3.14d
dot.junit.opcodes.div_double.Main_testN2;dot.junit.opcodes.div_double.d.T_div_double_1 ;div-double;Normal #2;Dividend = 0
dot.junit.opcodes.div_double.Main_testN3;dot.junit.opcodes.div_double.d.T_div_double_1 ;div-double;Normal #3;Dividend is negative
dot.junit.opcodes.div_double.Main_testN4;dot.junit.opcodes.div_double.d.T_div_double_1 ;div-double;Normal #4;Dividend is negative
dot.junit.opcodes.div_double.Main_testN5;dot.junit.opcodes.div_double.d.T_div_double_3 ;div-double;Normal #5;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this division of long and double makes no sense but shall not crash the VM.
dot.junit.opcodes.div_double.Main_testVFE1;dot.junit.opcodes.div_double.d.T_div_double_2 ;div-double;Verifier #1; Constraint B1, types of arguments - float / double
dot.junit.opcodes.div_double.Main_testVFE2;dot.junit.opcodes.div_double.d.T_div_double_5 ;div-double;Verifier #2; Constraint A24, number of registers
dot.junit.opcodes.div_double.Main_testVFE3;dot.junit.opcodes.div_double.d.T_div_double_4 ;div-double;Verifier #3; Constraint B1, types of arguments - double / reference
dot.junit.opcodes.div_double.Main_testVFE4;dot.junit.opcodes.div_double.d.T_div_double_6 ;div-double;Verifier #4; Constraint B1, types of arguments - int / int
dot.junit.opcodes.div_float_2addr.Main_testB1;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_1 ;div-float/2addr;Boundary #1;Arguments = Float.MAX_VALUE, Float.NaN
dot.junit.opcodes.div_float_2addr.Main_testB2;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_1 ;div-float/2addr;Boundary #2;Arguments = Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY
dot.junit.opcodes.div_float_2addr.Main_testB3;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_1 ;div-float/2addr;Boundary #3;Arguments = Float.POSITIVE_INFINITY, -2.7f
dot.junit.opcodes.div_float_2addr.Main_testB4;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_1 ;div-float/2addr;Boundary #4;Arguments = -2.7f, Float.NEGATIVE_INFINITY
dot.junit.opcodes.div_float_2addr.Main_testB5;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_1 ;div-float/2addr;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.div_float_2addr.Main_testB6;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_1 ;div-float/2addr;Boundary #6;Arguments = 0, -2.7
dot.junit.opcodes.div_float_2addr.Main_testB7;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_1 ;div-float/2addr;Boundary #7;Arguments = -2.7, 0
dot.junit.opcodes.div_float_2addr.Main_testB8;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_1 ;div-float/2addr;Boundary #8;Arguments = 1, Float.MAX_VALUE
dot.junit.opcodes.div_float_2addr.Main_testB9;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_1 ;div-float/2addr;Boundary #9;Arguments = Float.MAX_VALUE, -1E-9f
dot.junit.opcodes.div_float_2addr.Main_testN1;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_1 ;div-float/2addr;Normal #1;Arguments = 2.7f, 3.14f
dot.junit.opcodes.div_float_2addr.Main_testN2;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_1 ;div-float/2addr;Normal #2;Dividend = 0
dot.junit.opcodes.div_float_2addr.Main_testN3;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_1 ;div-float/2addr;Normal #3;Dividend is negative
dot.junit.opcodes.div_float_2addr.Main_testN4;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_5 ;div-float/2addr;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this division of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.div_float_2addr.Main_testVFE1;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_2 ;div-float/2addr;Verifier #1; Constraint B1, types of arguments - float / double
dot.junit.opcodes.div_float_2addr.Main_testVFE2;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_3 ;div-float/2addr;Verifier #2; Constraint B1, types of arguments - long / float
dot.junit.opcodes.div_float_2addr.Main_testVFE3;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_4 ;div-float/2addr;Verifier #3; Constraint B1, types of arguments - reference / float
dot.junit.opcodes.div_float_2addr.Main_testVFE4;dot.junit.opcodes.div_float_2addr.d.T_div_float_2addr_6 ;div-float/2addr;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.div_float.Main_testB1;dot.junit.opcodes.div_float.d.T_div_float_1 ;div-float;Boundary #1;Arguments = Float.MAX_VALUE, Float.NaN
dot.junit.opcodes.div_float.Main_testB2;dot.junit.opcodes.div_float.d.T_div_float_1 ;div-float;Boundary #2;Arguments = Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY
dot.junit.opcodes.div_float.Main_testB3;dot.junit.opcodes.div_float.d.T_div_float_1 ;div-float;Boundary #3;Arguments = Float.POSITIVE_INFINITY, -2.7f
dot.junit.opcodes.div_float.Main_testB4;dot.junit.opcodes.div_float.d.T_div_float_1 ;div-float;Boundary #4;Arguments = -2.7f, Float.NEGATIVE_INFINITY
dot.junit.opcodes.div_float.Main_testB5;dot.junit.opcodes.div_float.d.T_div_float_1 ;div-float;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.div_float.Main_testB6;dot.junit.opcodes.div_float.d.T_div_float_1 ;div-float;Boundary #6;Arguments = 0, -2.7
dot.junit.opcodes.div_float.Main_testB7;dot.junit.opcodes.div_float.d.T_div_float_1 ;div-float;Boundary #7;Arguments = -2.7, 0
dot.junit.opcodes.div_float.Main_testB8;dot.junit.opcodes.div_float.d.T_div_float_1 ;div-float;Boundary #8;Arguments = 1, Float.MAX_VALUE
dot.junit.opcodes.div_float.Main_testB9;dot.junit.opcodes.div_float.d.T_div_float_1 ;div-float;Boundary #9;Arguments = Float.MAX_VALUE, -1E-9f
dot.junit.opcodes.div_float.Main_testN1;dot.junit.opcodes.div_float.d.T_div_float_1 ;div-float;Normal #1;Arguments = 2.7f, 3.14f
dot.junit.opcodes.div_float.Main_testN2;dot.junit.opcodes.div_float.d.T_div_float_1 ;div-float;Normal #2;Dividend = 0
dot.junit.opcodes.div_float.Main_testN3;dot.junit.opcodes.div_float.d.T_div_float_1 ;div-float;Normal #3;Dividend is negative
dot.junit.opcodes.div_float.Main_testN4;dot.junit.opcodes.div_float.d.T_div_float_5 ;div-float;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this division of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.div_float.Main_testVFE1;dot.junit.opcodes.div_float.d.T_div_float_2 ;div-float;Verifier #1; Constraint B1, types of arguments - float / double
dot.junit.opcodes.div_float.Main_testVFE2;dot.junit.opcodes.div_float.d.T_div_float_3 ;div-float;Verifier #2; Constraint B1, types of arguments - long / float
dot.junit.opcodes.div_float.Main_testVFE3;dot.junit.opcodes.div_float.d.T_div_float_4 ;div-float;Verifier #3; Constraint B1, types of arguments - reference / float
dot.junit.opcodes.div_float.Main_testVFE4;dot.junit.opcodes.div_float.d.T_div_float_6 ;div-float;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.div_int_2addr.Main_testB1;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_1 ;div-int/2addr;Boundary #1;Arguments = Integer.MIN_VALUE, -1
dot.junit.opcodes.div_int_2addr.Main_testB2;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_1 ;div-int/2addr;Boundary #2;Arguments = Integer.MIN_VALUE, 1
dot.junit.opcodes.div_int_2addr.Main_testB3;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_1 ;div-int/2addr;Boundary #3;Arguments = Integer.MAX_VALUE, 1
dot.junit.opcodes.div_int_2addr.Main_testB4;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_1 ;div-int/2addr;Boundary #4;Arguments = Integer.MIN_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.div_int_2addr.Main_testB5;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_1 ;div-int/2addr;Boundary #5;Arguments = 1, Integer.MAX_VALUE
dot.junit.opcodes.div_int_2addr.Main_testB6;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_1 ;div-int/2addr;Boundary #6;Arguments = 1, Integer.MIN_VALUE
dot.junit.opcodes.div_int_2addr.Main_testE1;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_1 ;div-int/2addr;Exception #1;Divisor is 0
dot.junit.opcodes.div_int_2addr.Main_testN1;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_1 ;div-int/2addr;Normal #1;Arguments = 8, 4
dot.junit.opcodes.div_int_2addr.Main_testN2;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_1 ;div-int/2addr;Normal #2;Rounding
dot.junit.opcodes.div_int_2addr.Main_testN3;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_1 ;div-int/2addr;Normal #3;Dividend = 0
dot.junit.opcodes.div_int_2addr.Main_testN4;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_1 ;div-int/2addr;Normal #4;Dividend is negative
dot.junit.opcodes.div_int_2addr.Main_testN5;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_1 ;div-int/2addr;Normal #5;Divisor is negative
dot.junit.opcodes.div_int_2addr.Main_testN6;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_1 ;div-int/2addr;Normal #6;Both Dividend and divisor are negative
dot.junit.opcodes.div_int_2addr.Main_testN7;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_5 ;div-int/2addr;Normal #7;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this division of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.div_int_2addr.Main_testVFE1;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_2 ;div-int/2addr;Verifier #1; Constraint B1, types of arguments - int, double
dot.junit.opcodes.div_int_2addr.Main_testVFE2;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_3 ;div-int/2addr;Verifier #2; Constraint B1, types of arguments - long, int
dot.junit.opcodes.div_int_2addr.Main_testVFE3;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_4 ;div-int/2addr;Verifier #3; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.div_int_2addr.Main_testVFE4;dot.junit.opcodes.div_int_2addr.d.T_div_int_2addr_6 ;div-int/2addr;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.div_int_lit16.Main_testB1;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_7 ;div-int/lit16;Boundary #1;Arguments = Integer.MIN_VALUE / -1
dot.junit.opcodes.div_int_lit16.Main_testB2;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_8 ;div-int/lit16;Boundary #2;Arguments = Integer.MIN_VALUE / 1
dot.junit.opcodes.div_int_lit16.Main_testB3;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_9 ;div-int/lit16;Boundary #3;Arguments = Integer.MAX_VALUE / 1
dot.junit.opcodes.div_int_lit16.Main_testB4;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_10 ;div-int/lit16;Boundary #4;Arguments = Integer.MIN_VALUE / Short.MAX_VALUE
dot.junit.opcodes.div_int_lit16.Main_testB5;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_11 ;div-int/lit16;Boundary #5;Arguments = 1 / Short.MAX_VALUE
dot.junit.opcodes.div_int_lit16.Main_testB6;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_12 ;div-int/lit16;Boundary #6;Arguments = 1 / Short.MIN_VALUE
dot.junit.opcodes.div_int_lit16.Main_testE1;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_13 ;div-int/lit16;Exception #1;Divisor is 0
dot.junit.opcodes.div_int_lit16.Main_testN1;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_1 ;div-int/lit16;Normal #1;Arguments = 8 / 4
dot.junit.opcodes.div_int_lit16.Main_testN2;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_2 ;div-int/lit16;Normal #2;Rounding
dot.junit.opcodes.div_int_lit16.Main_testN3;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_3 ;div-int/lit16;Normal #3;Dividend = 0
dot.junit.opcodes.div_int_lit16.Main_testN4;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_4 ;div-int/lit16;Normal #4;Dividend is negative
dot.junit.opcodes.div_int_lit16.Main_testN5;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_5 ;div-int/lit16;Normal #5;Divisor is negative
dot.junit.opcodes.div_int_lit16.Main_testN6;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_6 ;div-int/lit16;Normal #6;Both Dividend and divisor are negative
dot.junit.opcodes.div_int_lit16.Main_testN7;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_17 ;div-int/lit16;Normal #7;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this division of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.div_int_lit16.Main_testVFE1;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_14 ;div-int/lit16;Verifier #1; Constraint B1, types of arguments - int / double
dot.junit.opcodes.div_int_lit16.Main_testVFE2;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_15 ;div-int/lit16;Verifier #2; Constraint B1, types of arguments - long / int
dot.junit.opcodes.div_int_lit16.Main_testVFE3;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_16 ;div-int/lit16;Verifier #3; Constraint B1, types of arguments - reference / int
dot.junit.opcodes.div_int_lit16.Main_testVFE4;dot.junit.opcodes.div_int_lit16.d.T_div_int_lit16_18 ;div-int/lit16;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.div_int_lit8.Main_testB1;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_7 ;div-int/lit8;Boundary #1;Arguments = Integer.MIN_VALUE / -1
dot.junit.opcodes.div_int_lit8.Main_testB2;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_8 ;div-int/lit8;Boundary #2;Arguments = Integer.MIN_VALUE / 1
dot.junit.opcodes.div_int_lit8.Main_testB3;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_9 ;div-int/lit8;Boundary #3;Arguments = Integer.MAX_VALUE / 1
dot.junit.opcodes.div_int_lit8.Main_testB4;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_10 ;div-int/lit8;Boundary #4;Arguments = Integer.MIN_VALUE / Byte.MAX_VALUE
dot.junit.opcodes.div_int_lit8.Main_testB5;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_11 ;div-int/lit8;Boundary #5;Arguments = 1 / Byte.MAX_VALUE
dot.junit.opcodes.div_int_lit8.Main_testB6;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_12 ;div-int/lit8;Boundary #6;Arguments = 1 / Byte.MIN_VALUE
dot.junit.opcodes.div_int_lit8.Main_testE1;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_13 ;div-int/lit8;Exception #1;Divisor is 0
dot.junit.opcodes.div_int_lit8.Main_testN1;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_1 ;div-int/lit8;Normal #1;Arguments = 8 / 4
dot.junit.opcodes.div_int_lit8.Main_testN2;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_2 ;div-int/lit8;Normal #2;Rounding
dot.junit.opcodes.div_int_lit8.Main_testN3;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_3 ;div-int/lit8;Normal #3;Dividend = 0
dot.junit.opcodes.div_int_lit8.Main_testN4;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_4 ;div-int/lit8;Normal #4;Dividend is negative
dot.junit.opcodes.div_int_lit8.Main_testN5;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_5 ;div-int/lit8;Normal #5;Divisor is negative
dot.junit.opcodes.div_int_lit8.Main_testN6;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_6 ;div-int/lit8;Normal #6;Both Dividend and divisor are negative
dot.junit.opcodes.div_int_lit8.Main_testN7;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_17 ;div-int/lit8;Normal #7;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this division of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.div_int_lit8.Main_testVFE1;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_14 ;div-int/lit8;Verifier #1; Constraint B1, types of arguments - int / double
dot.junit.opcodes.div_int_lit8.Main_testVFE2;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_15 ;div-int/lit8;Verifier #2; Constraint B1, types of arguments - long / int
dot.junit.opcodes.div_int_lit8.Main_testVFE3;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_16 ;div-int/lit8;Verifier #3; Constraint B1, types of arguments - reference / int
dot.junit.opcodes.div_int_lit8.Main_testVFE4;dot.junit.opcodes.div_int_lit8.d.T_div_int_lit8_18 ;div-int/lit8;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.div_int.Main_testB1;dot.junit.opcodes.div_int.d.T_div_int_1 ;div-int;Boundary #1;Arguments = Integer.MIN_VALUE, -1
dot.junit.opcodes.div_int.Main_testB2;dot.junit.opcodes.div_int.d.T_div_int_1 ;div-int;Boundary #2;Arguments = Integer.MIN_VALUE, 1
dot.junit.opcodes.div_int.Main_testB3;dot.junit.opcodes.div_int.d.T_div_int_1 ;div-int;Boundary #3;Arguments = Integer.MAX_VALUE, 1
dot.junit.opcodes.div_int.Main_testB4;dot.junit.opcodes.div_int.d.T_div_int_1 ;div-int;Boundary #4;Arguments = Integer.MIN_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.div_int.Main_testB5;dot.junit.opcodes.div_int.d.T_div_int_1 ;div-int;Boundary #5;Arguments = 1, Integer.MAX_VALUE
dot.junit.opcodes.div_int.Main_testB6;dot.junit.opcodes.div_int.d.T_div_int_1 ;div-int;Boundary #6;Arguments = 1, Integer.MIN_VALUE
dot.junit.opcodes.div_int.Main_testE1;dot.junit.opcodes.div_int.d.T_div_int_1 ;div-int;Exception #1;Divisor is 0
dot.junit.opcodes.div_int.Main_testN1;dot.junit.opcodes.div_int.d.T_div_int_1 ;div-int;Normal #1;Arguments = 8, 4
dot.junit.opcodes.div_int.Main_testN2;dot.junit.opcodes.div_int.d.T_div_int_1 ;div-int;Normal #2;Rounding
dot.junit.opcodes.div_int.Main_testN3;dot.junit.opcodes.div_int.d.T_div_int_1 ;div-int;Normal #3;Dividend = 0
dot.junit.opcodes.div_int.Main_testN4;dot.junit.opcodes.div_int.d.T_div_int_1 ;div-int;Normal #4;Dividend is negative
dot.junit.opcodes.div_int.Main_testN5;dot.junit.opcodes.div_int.d.T_div_int_1 ;div-int;Normal #5;Divisor is negative
dot.junit.opcodes.div_int.Main_testN6;dot.junit.opcodes.div_int.d.T_div_int_1 ;div-int;Normal #6;Both Dividend and divisor are negative
dot.junit.opcodes.div_int.Main_testN7;dot.junit.opcodes.div_int.d.T_div_int_5 ;div-int;Normal #7;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this division of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.div_int.Main_testVFE1;dot.junit.opcodes.div_int.d.T_div_int_2 ;div-int;Verifier #1; Constraint B1, types of arguments - int / double
dot.junit.opcodes.div_int.Main_testVFE2;dot.junit.opcodes.div_int.d.T_div_int_3 ;div-int;Verifier #2; Constraint B1, types of arguments - long / int
dot.junit.opcodes.div_int.Main_testVFE3;dot.junit.opcodes.div_int.d.T_div_int_4 ;div-int;Verifier #3; Constraint B1, types of arguments - reference / int
dot.junit.opcodes.div_int.Main_testVFE4;dot.junit.opcodes.div_int.d.T_div_int_6 ;div-int;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.div_long_2addr.Main_testB1;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_1 ;div-long/2addr;Boundary #1;Arguments = Long.MIN_VALUE, -1
dot.junit.opcodes.div_long_2addr.Main_testB2;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_1 ;div-long/2addr;Boundary #2;Arguments = Long.MIN_VALUE, 1
dot.junit.opcodes.div_long_2addr.Main_testB3;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_1 ;div-long/2addr;Boundary #3;Arguments = Long.MAX_VALUE, 1
dot.junit.opcodes.div_long_2addr.Main_testB4;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_1 ;div-long/2addr;Boundary #4;Arguments = Long.MIN_VALUE, Long.MAX_VALUE
dot.junit.opcodes.div_long_2addr.Main_testB5;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_1 ;div-long/2addr;Boundary #5;Arguments = 1, Long.MAX_VALUE
dot.junit.opcodes.div_long_2addr.Main_testB6;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_1 ;div-long/2addr;Boundary #6;Arguments = 1, Long.MIN_VALUE
dot.junit.opcodes.div_long_2addr.Main_testE1;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_1 ;div-long/2addr;Exception #1;Divisor is 0
dot.junit.opcodes.div_long_2addr.Main_testN1;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_1 ;div-long/2addr;Normal #1;Arguments = 100000000000l, 40000000000l
dot.junit.opcodes.div_long_2addr.Main_testN2;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_1 ;div-long/2addr;Normal #2;Rounding
dot.junit.opcodes.div_long_2addr.Main_testN3;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_1 ;div-long/2addr;Normal #3;Dividend = 0
dot.junit.opcodes.div_long_2addr.Main_testN4;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_1 ;div-long/2addr;Normal #4;Dividend is negative
dot.junit.opcodes.div_long_2addr.Main_testN5;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_1 ;div-long/2addr;Normal #5;Divisor is negative
dot.junit.opcodes.div_long_2addr.Main_testN6;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_1 ;div-long/2addr;Normal #6;Both Dividend and divisor are negative
dot.junit.opcodes.div_long_2addr.Main_testN7;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_2 ;div-long/2addr;Normal #7;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this division of long and double makes no sense but shall not crash the VM.
dot.junit.opcodes.div_long_2addr.Main_testVFE1;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_6 ;div-long/2addr;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.div_long_2addr.Main_testVFE2;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_3 ;div-long/2addr;Verifier #2; Constraint B1, types of arguments - int / long
dot.junit.opcodes.div_long_2addr.Main_testVFE3;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_4 ;div-long/2addr;Verifier #3; Constraint B1, types of arguments - float / long
dot.junit.opcodes.div_long_2addr.Main_testVFE4;dot.junit.opcodes.div_long_2addr.d.T_div_long_2addr_5 ;div-long/2addr;Verifier #4; Constraint B1, types of arguments - reference / long
dot.junit.opcodes.div_long.Main_testB1;dot.junit.opcodes.div_long.d.T_div_long_1 ;div-long;Boundary #1;Arguments = Long.MIN_VALUE, -1
dot.junit.opcodes.div_long.Main_testB2;dot.junit.opcodes.div_long.d.T_div_long_1 ;div-long;Boundary #2;Arguments = Long.MIN_VALUE, 1
dot.junit.opcodes.div_long.Main_testB3;dot.junit.opcodes.div_long.d.T_div_long_1 ;div-long;Boundary #3;Arguments = Long.MAX_VALUE, 1
dot.junit.opcodes.div_long.Main_testB4;dot.junit.opcodes.div_long.d.T_div_long_1 ;div-long;Boundary #4;Arguments = Long.MIN_VALUE, Long.MAX_VALUE
dot.junit.opcodes.div_long.Main_testB5;dot.junit.opcodes.div_long.d.T_div_long_1 ;div-long;Boundary #5;Arguments = 1, Long.MAX_VALUE
dot.junit.opcodes.div_long.Main_testB6;dot.junit.opcodes.div_long.d.T_div_long_1 ;div-long;Boundary #6;Arguments = 1, Long.MIN_VALUE
dot.junit.opcodes.div_long.Main_testE1;dot.junit.opcodes.div_long.d.T_div_long_1 ;div-long;Exception #1;Divisor is 0
dot.junit.opcodes.div_long.Main_testN1;dot.junit.opcodes.div_long.d.T_div_long_1 ;div-long;Normal #1;Arguments = 100000000000l, 40000000000l
dot.junit.opcodes.div_long.Main_testN2;dot.junit.opcodes.div_long.d.T_div_long_1 ;div-long;Normal #2;Rounding
dot.junit.opcodes.div_long.Main_testN3;dot.junit.opcodes.div_long.d.T_div_long_1 ;div-long;Normal #3;Dividend = 0
dot.junit.opcodes.div_long.Main_testN4;dot.junit.opcodes.div_long.d.T_div_long_1 ;div-long;Normal #4;Dividend is negative
dot.junit.opcodes.div_long.Main_testN5;dot.junit.opcodes.div_long.d.T_div_long_1 ;div-long;Normal #5;Divisor is negative
dot.junit.opcodes.div_long.Main_testN6;dot.junit.opcodes.div_long.d.T_div_long_1 ;div-long;Normal #6;Both Dividend and divisor are negative
dot.junit.opcodes.div_long.Main_testN7;dot.junit.opcodes.div_long.d.T_div_long_2 ;div-long;Normal #7;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this division of long and double makes no sense but shall not crash the VM.
dot.junit.opcodes.div_long.Main_testVFE1;dot.junit.opcodes.div_long.d.T_div_long_6 ;div-long;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.div_long.Main_testVFE2;dot.junit.opcodes.div_long.d.T_div_long_3 ;div-long;Verifier #2; Constraint B1, types of arguments - int / long
dot.junit.opcodes.div_long.Main_testVFE3;dot.junit.opcodes.div_long.d.T_div_long_4 ;div-long;Verifier #3; Constraint B1, types of arguments - float / long
dot.junit.opcodes.div_long.Main_testVFE4;dot.junit.opcodes.div_long.d.T_div_long_5 ;div-long;Verifier #4; Constraint B1, types of arguments - reference / long
dot.junit.opcodes.double_to_float.Main_testB1;dot.junit.opcodes.double_to_float.d.T_double_to_float_1 ;double-to-float;Boundary #1;Argument = Double.MAX_VALUE
dot.junit.opcodes.double_to_float.Main_testB2;dot.junit.opcodes.double_to_float.d.T_double_to_float_1 ;double-to-float;Boundary #2;Argument = Double.MIN_VALUE
dot.junit.opcodes.double_to_float.Main_testB3;dot.junit.opcodes.double_to_float.d.T_double_to_float_1 ;double-to-float;Boundary #3;Argument = -0
dot.junit.opcodes.double_to_float.Main_testB4;dot.junit.opcodes.double_to_float.d.T_double_to_float_1 ;double-to-float;Boundary #4;Argument = NaN
dot.junit.opcodes.double_to_float.Main_testB5;dot.junit.opcodes.double_to_float.d.T_double_to_float_1 ;double-to-float;Boundary #5;Argument = POSITIVE_INFINITY
dot.junit.opcodes.double_to_float.Main_testB6;dot.junit.opcodes.double_to_float.d.T_double_to_float_1 ;double-to-float;Boundary #6;Argument = NEGATIVE_INFINITY
dot.junit.opcodes.double_to_float.Main_testB7;dot.junit.opcodes.double_to_float.d.T_double_to_float_1 ;double-to-float;Boundary #7;Argument = -Double.MIN_VALUE
dot.junit.opcodes.double_to_float.Main_testN1;dot.junit.opcodes.double_to_float.d.T_double_to_float_1 ;double-to-float;Normal #1;Argument = 2.71
dot.junit.opcodes.double_to_float.Main_testN2;dot.junit.opcodes.double_to_float.d.T_double_to_float_1 ;double-to-float;Normal #2;Argument = 1
dot.junit.opcodes.double_to_float.Main_testN3;dot.junit.opcodes.double_to_float.d.T_double_to_float_1 ;double-to-float;Normal #3;Argument = -1
dot.junit.opcodes.double_to_float.Main_testN4;dot.junit.opcodes.double_to_float.d.T_double_to_float_3 ;double-to-float;Normal #4;Type of argument - long. Dalvik doens't distinguish 64-bits types internally, so this conversion of long to float makes no sense but shall not crash the VM.
dot.junit.opcodes.double_to_float.Main_testVFE2;dot.junit.opcodes.double_to_float.d.T_double_to_float_2 ;double-to-float;Verifier #2; Constraint B1, type of argument - float
dot.junit.opcodes.double_to_float.Main_testVFE3;dot.junit.opcodes.double_to_float.d.T_double_to_float_5 ;double-to-float;Verifier #3; Constraint A24, number of registers
dot.junit.opcodes.double_to_float.Main_testVFE4;dot.junit.opcodes.double_to_float.d.T_double_to_float_4 ;double-to-float;Verifier #4; Constraint B1, type of argument - reference
dot.junit.opcodes.double_to_float.Main_testVFE5;dot.junit.opcodes.double_to_float.d.T_double_to_float_6 ;double-to-float;Verifier #5; Constraint B1, type of argument - int
dot.junit.opcodes.double_to_int.Main_testB1;dot.junit.opcodes.double_to_int.d.T_double_to_int_1 ;double-to-int;Boundary #1;Argument = -0
dot.junit.opcodes.double_to_int.Main_testB2;dot.junit.opcodes.double_to_int.d.T_double_to_int_1 ;double-to-int;Boundary #2;Argument = Double.MAX_VALUE
dot.junit.opcodes.double_to_int.Main_testB3;dot.junit.opcodes.double_to_int.d.T_double_to_int_1 ;double-to-int;Boundary #3;Argument = Double.MIN_VALUE
dot.junit.opcodes.double_to_int.Main_testB4;dot.junit.opcodes.double_to_int.d.T_double_to_int_1 ;double-to-int;Boundary #4;Argument = NaN
dot.junit.opcodes.double_to_int.Main_testB5;dot.junit.opcodes.double_to_int.d.T_double_to_int_1 ;double-to-int;Boundary #5;Argument = POSITIVE_INFINITY
dot.junit.opcodes.double_to_int.Main_testB6;dot.junit.opcodes.double_to_int.d.T_double_to_int_1 ;double-to-int;Boundary #6;Argument = NEGATIVE_INFINITY
dot.junit.opcodes.double_to_int.Main_testN1;dot.junit.opcodes.double_to_int.d.T_double_to_int_1 ;double-to-int;Normal #1;Argument = 2.9999999d
dot.junit.opcodes.double_to_int.Main_testN2;dot.junit.opcodes.double_to_int.d.T_double_to_int_1 ;double-to-int;Normal #2;Argument = 1
dot.junit.opcodes.double_to_int.Main_testN3;dot.junit.opcodes.double_to_int.d.T_double_to_int_1 ;double-to-int;Normal #3;Argument = -1
dot.junit.opcodes.double_to_int.Main_testN4;dot.junit.opcodes.double_to_int.d.T_double_to_int_3 ;double-to-int;Normal #4;Type of argument - long. Dalvik doens't distinguish 64-bits types internally, so this conversion of long to int makes no sense but shall not crash the VM.
dot.junit.opcodes.double_to_int.Main_testVFE2;dot.junit.opcodes.double_to_int.d.T_double_to_int_2 ;double-to-int;Verifier #2; Constraint B1, type of argument - float
dot.junit.opcodes.double_to_int.Main_testVFE3;dot.junit.opcodes.double_to_int.d.T_double_to_int_5 ;double-to-int;Verifier #3; Constraint A24, number of registers
dot.junit.opcodes.double_to_int.Main_testVFE4;dot.junit.opcodes.double_to_int.d.T_double_to_int_4 ;double-to-int;Verifier #4; Constraint B1, type of argument - reference
dot.junit.opcodes.double_to_int.Main_testVFE5;dot.junit.opcodes.double_to_int.d.T_double_to_int_6 ;double-to-int;Verifier #5; Constraint B1, type of argument - reference
dot.junit.opcodes.double_to_long.Main_testB1;dot.junit.opcodes.double_to_long.d.T_double_to_long_1 ;double-to-long;Boundary #1;Argument = Double.MAX_VALUE
dot.junit.opcodes.double_to_long.Main_testB2;dot.junit.opcodes.double_to_long.d.T_double_to_long_1 ;double-to-long;Boundary #2;Argument = Double.MIN_VALUE
dot.junit.opcodes.double_to_long.Main_testB3;dot.junit.opcodes.double_to_long.d.T_double_to_long_1 ;double-to-long;Boundary #3;Argument = -0
dot.junit.opcodes.double_to_long.Main_testB4;dot.junit.opcodes.double_to_long.d.T_double_to_long_1 ;double-to-long;Boundary #4;Argument = NaN
dot.junit.opcodes.double_to_long.Main_testB5;dot.junit.opcodes.double_to_long.d.T_double_to_long_1 ;double-to-long;Boundary #5;Argument = POSITIVE_INFINITY
dot.junit.opcodes.double_to_long.Main_testB6;dot.junit.opcodes.double_to_long.d.T_double_to_long_1 ;double-to-long;Boundary #6;Argument = NEGATIVE_INFINITY
dot.junit.opcodes.double_to_long.Main_testN1;dot.junit.opcodes.double_to_long.d.T_double_to_long_1 ;double-to-long;Normal #1;Argument = 2.9999999
dot.junit.opcodes.double_to_long.Main_testN2;dot.junit.opcodes.double_to_long.d.T_double_to_long_1 ;double-to-long;Normal #2;Argument = 1
dot.junit.opcodes.double_to_long.Main_testN3;dot.junit.opcodes.double_to_long.d.T_double_to_long_1 ;double-to-long;Normal #3;Argument = -1
dot.junit.opcodes.double_to_long.Main_testN4;dot.junit.opcodes.double_to_long.d.T_double_to_long_3 ;double-to-long;Normal #4;Type of argument - long. Dalvik doens't distinguish 64-bits types internally, so this conversion of long to long makes no sense but shall not crash the VM.
dot.junit.opcodes.double_to_long.Main_testVFE1;dot.junit.opcodes.double_to_long.d.T_double_to_long_2 ;double-to-long;Verifier #1; Constraint B1, type of argument - float
dot.junit.opcodes.double_to_long.Main_testVFE2;dot.junit.opcodes.double_to_long.d.T_double_to_long_5 ;double-to-long;Verifier #2; Constraint A24, number of registers
dot.junit.opcodes.double_to_long.Main_testVFE3;dot.junit.opcodes.double_to_long.d.T_double_to_long_4 ;double-to-long;Verifier #3; Constraint B1, type of argument - reference
dot.junit.opcodes.double_to_long.Main_testVFE4;dot.junit.opcodes.double_to_long.d.T_double_to_long_6 ;double-to-long;Verifier #4; Constraint B1, type of argument - int
dot.junit.opcodes.fill_array_data.Main_testE1;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_1 ;fill-array-data;Exception #1;Expected NullPointerException
dot.junit.opcodes.fill_array_data.Main_testE2;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_1 ;fill-array-data;Exception #2;Expected ArrayIndexOutOfBoundsException
dot.junit.opcodes.fill_array_data.Main_testN1;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_1 ;fill-array-data;Normal #1;Array of ints
dot.junit.opcodes.fill_array_data.Main_testN2;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_2 ;fill-array-data;Normal #2;Array of doubles
dot.junit.opcodes.fill_array_data.Main_testN3;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_1 ;fill-array-data;Normal #3;If there are less elements in the table than the array provides space for,  the remaining array elements stay untouched.
dot.junit.opcodes.fill_array_data.Main_testVFE1;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_3 ;fill-array-data;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.fill_array_data.Main_testVFE10;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_12 ;fill-array-data;Verifier #10; Constraint B22, packed-switch-data pseudo-instructions must not be reachable by control flow
dot.junit.opcodes.fill_array_data.Main_testVFE11;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_13 ;fill-array-data;Verifier #11; Constraint n/a, table has wrong ident code
dot.junit.opcodes.fill_array_data.Main_testVFE2;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_4 ;fill-array-data;Verifier #2; Constraint B1, type of argument - double
dot.junit.opcodes.fill_array_data.Main_testVFE3;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_5 ;fill-array-data;Verifier #3; Constraint B1, type of argument - long
dot.junit.opcodes.fill_array_data.Main_testVFE4;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_6 ;fill-array-data;Verifier #4; Constraint B1, type of argument - reference (not array)
dot.junit.opcodes.fill_array_data.Main_testVFE5;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_7 ;fill-array-data;Verifier #5; Constraint B1, array of Objects
dot.junit.opcodes.fill_array_data.Main_testVFE6;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_8 ;fill-array-data;Verifier #6; Constraint B1, array type and data size shall be consistent
dot.junit.opcodes.fill_array_data.Main_testVFE7;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_9 ;fill-array-data;Verifier #7; Constraint n/a, offset to table shall be inside method
dot.junit.opcodes.fill_array_data.Main_testVFE9;dot.junit.opcodes.fill_array_data.d.T_fill_array_data_11 ;fill-array-data;Verifier #9; Constraint n/a, the size and the list must be consistent.
dot.junit.opcodes.filled_new_array_range.Main_testN1;dot.junit.opcodes.filled_new_array_range.d.T_filled_new_array_range_1 ;filled-new-array/range;Normal #1;Array of ints
dot.junit.opcodes.filled_new_array_range.Main_testN2;dot.junit.opcodes.filled_new_array_range.d.T_filled_new_array_range_2 ;filled-new-array/range;Normal #2;Array of objects
dot.junit.opcodes.filled_new_array_range.Main_testVFE1;dot.junit.opcodes.filled_new_array_range.d.T_filled_new_array_range_3 ;filled-new-array/range;Verifier #1; Constraint A18, invalid constant pool index
dot.junit.opcodes.filled_new_array_range.Main_testVFE2;dot.junit.opcodes.filled_new_array_range.d.T_filled_new_array_range_4 ;filled-new-array/range;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.filled_new_array_range.Main_testVFE3;dot.junit.opcodes.filled_new_array_range.d.T_filled_new_array_range_5 ;filled-new-array/range;Verifier #3; Constraint B1, try to pass obj ref instead of int
dot.junit.opcodes.filled_new_array_range.Main_testVFE4;dot.junit.opcodes.filled_new_array_range.d.T_filled_new_array_range_6 ;filled-new-array/range;Verifier #4; Constraint B1, try to pass long instead of int
dot.junit.opcodes.filled_new_array_range.Main_testVFE5;dot.junit.opcodes.filled_new_array_range.d.T_filled_new_array_range_7 ;filled-new-array/range;Verifier #5; Constraint B1, try to create non-array type
dot.junit.opcodes.filled_new_array_range.Main_testVFE6;dot.junit.opcodes.filled_new_array_range.d.T_filled_new_array_range_8 ;filled-new-array/range;Verifier #6; Constraint B1, invalid arg count
dot.junit.opcodes.filled_new_array_range.Main_testVFE7;dot.junit.opcodes.filled_new_array_range.d.T_filled_new_array_range_9 ;filled-new-array/range;Verifier #7; Constraint n/a, attempt to instantiate String[] and fill it with reference to assignment-incompatible class
dot.junit.opcodes.filled_new_array_range.Main_testVFE8;dot.junit.opcodes.filled_new_array_range.d.T_filled_new_array_range_10 ;filled-new-array/range;Verifier #8; Constraint n/a, attempt to instantiate array of non-existent class
dot.junit.opcodes.filled_new_array_range.Main_testVFE9;dot.junit.opcodes.filled_new_array_range.TestStubs dot.junit.opcodes.filled_new_array_range.d.T_filled_new_array_range_11 ;filled-new-array/range;Verifier #9; Constraint n/a, attempt to instantiate array of inaccessible class
dot.junit.opcodes.filled_new_array.Main_testN1;dot.junit.opcodes.filled_new_array.d.T_filled_new_array_1 ;filled-new-array;Normal #1;Array of ints
dot.junit.opcodes.filled_new_array.Main_testN2;dot.junit.opcodes.filled_new_array.d.T_filled_new_array_2 ;filled-new-array;Normal #2;Array of objects
dot.junit.opcodes.filled_new_array.Main_testVFE1;dot.junit.opcodes.filled_new_array.d.T_filled_new_array_3 ;filled-new-array;Verifier #1; Constraint A17, invalid constant pool index
dot.junit.opcodes.filled_new_array.Main_testVFE2;dot.junit.opcodes.filled_new_array.d.T_filled_new_array_4 ;filled-new-array;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.filled_new_array.Main_testVFE3;dot.junit.opcodes.filled_new_array.d.T_filled_new_array_5 ;filled-new-array;Verifier #3; Constraint B1, try to pass obj ref instead of int
dot.junit.opcodes.filled_new_array.Main_testVFE4;dot.junit.opcodes.filled_new_array.d.T_filled_new_array_6 ;filled-new-array;Verifier #4; Constraint B1, try to pass long instead of int
dot.junit.opcodes.filled_new_array.Main_testVFE5;dot.junit.opcodes.filled_new_array.d.T_filled_new_array_7 ;filled-new-array;Verifier #5; Constraint B1, try to create non-array type
dot.junit.opcodes.filled_new_array.Main_testVFE6;dot.junit.opcodes.filled_new_array.d.T_filled_new_array_8 ;filled-new-array;Verifier #6; Constraint B1, invalid arg count
dot.junit.opcodes.filled_new_array.Main_testVFE7;dot.junit.opcodes.filled_new_array.d.T_filled_new_array_9 ;filled-new-array;Verifier #7; Constraint n/a, attempt to instantiate String[] and fill it with reference to assignment-incompatible class
dot.junit.opcodes.filled_new_array.Main_testVFE8;dot.junit.opcodes.filled_new_array.d.T_filled_new_array_10 ;filled-new-array;Verifier #8; Constraint n/a, attempt to instantiate array of non-existent class
dot.junit.opcodes.filled_new_array.Main_testVFE9;dot.junit.opcodes.filled_new_array.d.T_filled_new_array_11 dot.junit.opcodes.filled_new_array.TestStubs ;filled-new-array;Verifier #9; Constraint n/a, attempt to instantiate array of inaccessible class
dot.junit.opcodes.float_to_double.Main_testB1;dot.junit.opcodes.float_to_double.d.T_float_to_double_1 ;float-to-double;Boundary #1;Argument = Float.MAX_VALUE
dot.junit.opcodes.float_to_double.Main_testB2;dot.junit.opcodes.float_to_double.d.T_float_to_double_1 ;float-to-double;Boundary #2;Argument = Float.MIN_VALUE
dot.junit.opcodes.float_to_double.Main_testB3;dot.junit.opcodes.float_to_double.d.T_float_to_double_1 ;float-to-double;Boundary #3;Argument = -0
dot.junit.opcodes.float_to_double.Main_testB4;dot.junit.opcodes.float_to_double.d.T_float_to_double_1 ;float-to-double;Boundary #4;Argument = NaN
dot.junit.opcodes.float_to_double.Main_testB5;dot.junit.opcodes.float_to_double.d.T_float_to_double_1 ;float-to-double;Boundary #5;Argument = POSITIVE_INFINITY
dot.junit.opcodes.float_to_double.Main_testB6;dot.junit.opcodes.float_to_double.d.T_float_to_double_1 ;float-to-double;Boundary #6;Argument = NEGATIVE_INFINITY
dot.junit.opcodes.float_to_double.Main_testN1;dot.junit.opcodes.float_to_double.d.T_float_to_double_1 ;float-to-double;Normal #1;Argument = 0.5
dot.junit.opcodes.float_to_double.Main_testN2;dot.junit.opcodes.float_to_double.d.T_float_to_double_1 ;float-to-double;Normal #2;Argument = 1
dot.junit.opcodes.float_to_double.Main_testN3;dot.junit.opcodes.float_to_double.d.T_float_to_double_1 ;float-to-double;Normal #3;Argument = -1
dot.junit.opcodes.float_to_double.Main_testN4;dot.junit.opcodes.float_to_double.d.T_float_to_double_7 ;float-to-double;Normal #4;Type of argument - int. Dalvik doens't distinguish 32-bits types internally, so this conversion of int to double makes no sense but shall not crash the VM.
dot.junit.opcodes.float_to_double.Main_testVFE1;dot.junit.opcodes.float_to_double.d.T_float_to_double_2 ;float-to-double;Verifier #1; Constraint B1, type of argument - double
dot.junit.opcodes.float_to_double.Main_testVFE2;dot.junit.opcodes.float_to_double.d.T_float_to_double_3 ;float-to-double;Verifier #2; Constraint B1, type of argument - long
dot.junit.opcodes.float_to_double.Main_testVFE3;dot.junit.opcodes.float_to_double.d.T_float_to_double_4 ;float-to-double;Verifier #3; Constraint A24, number of registers
dot.junit.opcodes.float_to_double.Main_testVFE4;dot.junit.opcodes.float_to_double.d.T_float_to_double_5 ;float-to-double;Verifier #4; Constraint B1, type of argument - reference
dot.junit.opcodes.float_to_double.Main_testVFE5;dot.junit.opcodes.float_to_double.d.T_float_to_double_6 ;float-to-double;Verifier #5; Constraint A23, number of registers
dot.junit.opcodes.float_to_int.Main_testB1;dot.junit.opcodes.float_to_int.d.T_float_to_int_1 ;float-to-int;Boundary #1;Argument = -0f
dot.junit.opcodes.float_to_int.Main_testB2;dot.junit.opcodes.float_to_int.d.T_float_to_int_1 ;float-to-int;Boundary #2;Argument = Float.MAX_VALUE
dot.junit.opcodes.float_to_int.Main_testB3;dot.junit.opcodes.float_to_int.d.T_float_to_int_1 ;float-to-int;Boundary #3;Argument = Float.MIN_VALUE
dot.junit.opcodes.float_to_int.Main_testB4;dot.junit.opcodes.float_to_int.d.T_float_to_int_1 ;float-to-int;Boundary #4;Argument = NaN
dot.junit.opcodes.float_to_int.Main_testB5;dot.junit.opcodes.float_to_int.d.T_float_to_int_1 ;float-to-int;Boundary #5;Argument = POSITIVE_INFINITY
dot.junit.opcodes.float_to_int.Main_testB6;dot.junit.opcodes.float_to_int.d.T_float_to_int_1 ;float-to-int;Boundary #6;Argument = NEGATIVE_INFINITY
dot.junit.opcodes.float_to_int.Main_testN1;dot.junit.opcodes.float_to_int.d.T_float_to_int_1 ;float-to-int;Normal #1;Argument = 2.999999f
dot.junit.opcodes.float_to_int.Main_testN2;dot.junit.opcodes.float_to_int.d.T_float_to_int_1 ;float-to-int;Normal #2;Argument = 1
dot.junit.opcodes.float_to_int.Main_testN3;dot.junit.opcodes.float_to_int.d.T_float_to_int_1 ;float-to-int;Normal #3;Argument = -1
dot.junit.opcodes.float_to_int.Main_testN4;dot.junit.opcodes.float_to_int.d.T_float_to_int_5 ;float-to-int;Normal #4;Type of argument - int. Dalvik doens't distinguish 32-bits types internally, so this conversion of int to int makes no sense but shall not crash the VM.
dot.junit.opcodes.float_to_int.Main_testVFE2;dot.junit.opcodes.float_to_int.d.T_float_to_int_2 ;float-to-int;Verifier #2; Constraint B1, type of argument - double
dot.junit.opcodes.float_to_int.Main_testVFE3;dot.junit.opcodes.float_to_int.d.T_float_to_int_3 ;float-to-int;Verifier #3; Constraint B1, type of argument - long
dot.junit.opcodes.float_to_int.Main_testVFE4;dot.junit.opcodes.float_to_int.d.T_float_to_int_4 ;float-to-int;Verifier #4; Constraint B1, type of argument - reference
dot.junit.opcodes.float_to_int.Main_testVFE5;dot.junit.opcodes.float_to_int.d.T_float_to_int_6 ;float-to-int;Verifier #5; Constraint A23, number of registers
dot.junit.opcodes.float_to_long.Main_testB1;dot.junit.opcodes.float_to_long.d.T_float_to_long_1 ;float-to-long;Boundary #1;Argument = Float.MAX_VALUE
dot.junit.opcodes.float_to_long.Main_testB2;dot.junit.opcodes.float_to_long.d.T_float_to_long_1 ;float-to-long;Boundary #2;Argument = Float.MIN_VALUE
dot.junit.opcodes.float_to_long.Main_testB3;dot.junit.opcodes.float_to_long.d.T_float_to_long_1 ;float-to-long;Boundary #3;Argument = 0
dot.junit.opcodes.float_to_long.Main_testB4;dot.junit.opcodes.float_to_long.d.T_float_to_long_1 ;float-to-long;Boundary #4;Argument = NaN
dot.junit.opcodes.float_to_long.Main_testB5;dot.junit.opcodes.float_to_long.d.T_float_to_long_1 ;float-to-long;Boundary #5;Argument = POSITIVE_INFINITY
dot.junit.opcodes.float_to_long.Main_testB6;dot.junit.opcodes.float_to_long.d.T_float_to_long_1 ;float-to-long;Boundary #6;Argument = NEGATIVE_INFINITY
dot.junit.opcodes.float_to_long.Main_testN1;dot.junit.opcodes.float_to_long.d.T_float_to_long_1 ;float-to-long;Normal #1;Argument = 2.999999f
dot.junit.opcodes.float_to_long.Main_testN2;dot.junit.opcodes.float_to_long.d.T_float_to_long_1 ;float-to-long;Normal #2;Argument = 1
dot.junit.opcodes.float_to_long.Main_testN3;dot.junit.opcodes.float_to_long.d.T_float_to_long_1 ;float-to-long;Normal #3;Argument = -1
dot.junit.opcodes.float_to_long.Main_testN4;dot.junit.opcodes.float_to_long.d.T_float_to_long_7 ;float-to-long;Normal #4;Type of argument - int. Dalvik doens't distinguish 32-bits types internally, so this conversion of int to long makes no sense but shall not crash the VM.
dot.junit.opcodes.float_to_long.Main_testVFE1;dot.junit.opcodes.float_to_long.d.T_float_to_long_2 ;float-to-long;Verifier #1; Constraint B1, number of arguments
dot.junit.opcodes.float_to_long.Main_testVFE2;dot.junit.opcodes.float_to_long.d.T_float_to_long_2 ;float-to-long;Verifier #2; Constraint B1, type of argument - double
dot.junit.opcodes.float_to_long.Main_testVFE3;dot.junit.opcodes.float_to_long.d.T_float_to_long_3 ;float-to-long;Verifier #3; Constraint B1, type of argument - long
dot.junit.opcodes.float_to_long.Main_testVFE4;dot.junit.opcodes.float_to_long.d.T_float_to_long_4 ;float-to-long;Verifier #4; Constraint A24, number of registers
dot.junit.opcodes.float_to_long.Main_testVFE5;dot.junit.opcodes.float_to_long.d.T_float_to_long_5 ;float-to-long;Verifier #5; Constraint B1, type of argument - reference
dot.junit.opcodes.float_to_long.Main_testVFE6;dot.junit.opcodes.float_to_long.d.T_float_to_long_6 ;float-to-long;Verifier #6; Constraint A23, number of registers
dot.junit.opcodes.goto_16.Main_testN1;dot.junit.opcodes.goto_16.d.T_goto_16_1 ;goto/16;Normal #1;Check forward and backward goto. This test also tests constraint C17 allowing to have         * backward goto as a last opcode in the method.
dot.junit.opcodes.goto_16.Main_testVFE1;dot.junit.opcodes.goto_16.d.T_goto_16_3 ;goto/16;Verifier #1; Constraint A6, branch target is inside instruction
dot.junit.opcodes.goto_16.Main_testVFE2;dot.junit.opcodes.goto_16.d.T_goto_16_2 ;goto/16;Verifier #2; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.goto_16.Main_testVFE3;dot.junit.opcodes.goto_16.d.T_goto_16_4 ;goto/16;Verifier #3; Constraint n/a, zero offset
dot.junit.opcodes.goto_32.Main_testN1;dot.junit.opcodes.goto_32.d.T_goto_32_1 ;goto/32;Normal #1;Check forward and backward goto. This test also tests constraint C17 allowing to have         * backward goto as a last opcode in the method.
dot.junit.opcodes.goto_32.Main_testVFE1;dot.junit.opcodes.goto_32.d.T_goto_32_2 ;goto/32;Verifier #1; Constraint A6, branch target is inside instruction
dot.junit.opcodes.goto_32.Main_testVFE2;dot.junit.opcodes.goto_32.d.T_goto_32_3 ;goto/32;Verifier #2; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.goto_32.Main_testVFE3;dot.junit.opcodes.goto_32.d.T_goto_32_4 ;goto/32;Verifier #3; Constraint n/a, zero offset - no exception expected
dot.junit.opcodes.if_eq.Main_testB1;dot.junit.opcodes.if_eq.d.T_if_eq_1 ;if-eq;Boundary #1;Arguments = Integer.MAX_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.if_eq.Main_testB2;dot.junit.opcodes.if_eq.d.T_if_eq_1 ;if-eq;Boundary #2;Arguments = Integer.MIN_VALUE, Integer.MIN_VALUE
dot.junit.opcodes.if_eq.Main_testB3;dot.junit.opcodes.if_eq.d.T_if_eq_1 ;if-eq;Boundary #3;Arguments = 0, 1234567
dot.junit.opcodes.if_eq.Main_testB4;dot.junit.opcodes.if_eq.d.T_if_eq_1 ;if-eq;Boundary #4;Arguments = 0, 0
dot.junit.opcodes.if_eq.Main_testB5;dot.junit.opcodes.if_eq.d.T_if_eq_2 ;if-eq;Boundary #5;Compare reference with null
dot.junit.opcodes.if_eq.Main_testN1;dot.junit.opcodes.if_eq.d.T_if_eq_1 ;if-eq;Normal #1;Arguments = 5, 6
dot.junit.opcodes.if_eq.Main_testN2;dot.junit.opcodes.if_eq.d.T_if_eq_1 ;if-eq;Normal #2;Arguments = 0x0f0e0d0c, 0x0f0e0d0c
dot.junit.opcodes.if_eq.Main_testN3;dot.junit.opcodes.if_eq.d.T_if_eq_1 ;if-eq;Normal #3;Arguments = 5, -5
dot.junit.opcodes.if_eq.Main_testN4;dot.junit.opcodes.if_eq.d.T_if_eq_1 ;if-eq;Normal #4;Arguments = 0x01001234, 0x1234
dot.junit.opcodes.if_eq.Main_testN5;dot.junit.opcodes.if_eq.d.T_if_eq_2 ;if-eq;Normal #5;Compare references
dot.junit.opcodes.if_eq.Main_testN6;dot.junit.opcodes.if_eq.d.T_if_eq_2 ;if-eq;Normal #6;Compare references
dot.junit.opcodes.if_eq.Main_testN7;dot.junit.opcodes.if_eq.d.T_if_eq_4 ;if-eq;Normal #7;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this operation of int and float makes no sense but shall not crash the VM.
dot.junit.opcodes.if_eq.Main_testVFE1;dot.junit.opcodes.if_eq.d.T_if_eq_5 ;if-eq;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.if_eq.Main_testVFE2;dot.junit.opcodes.if_eq.d.T_if_eq_7 ;if-eq;Verifier #2; Constraint B1, types of arguments - int, double
dot.junit.opcodes.if_eq.Main_testVFE3;dot.junit.opcodes.if_eq.d.T_if_eq_8 ;if-eq;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.if_eq.Main_testVFE4;dot.junit.opcodes.if_eq.d.T_if_eq_9 ;if-eq;Verifier #4; Constraint B1, types of arguments - int, reference
dot.junit.opcodes.if_eq.Main_testVFE5;dot.junit.opcodes.if_eq.d.T_if_eq_10 ;if-eq;Verifier #5; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.if_eq.Main_testVFE6;dot.junit.opcodes.if_eq.d.T_if_eq_11 ;if-eq;Verifier #6; Constraint A6, branch target shall not be "inside" instruction
dot.junit.opcodes.if_eq.Main_testVFE7;dot.junit.opcodes.if_eq.d.T_if_eq_12 ;if-eq;Verifier #7; Constraint n/a, zero offset
dot.junit.opcodes.if_eqz.Main_testB1;dot.junit.opcodes.if_eqz.d.T_if_eqz_1 ;if-eqz;Boundary #1;Arguments = Integer.MAX_VALUE
dot.junit.opcodes.if_eqz.Main_testB2;dot.junit.opcodes.if_eqz.d.T_if_eqz_1 ;if-eqz;Boundary #2;Arguments = Integer.MIN_VALUE
dot.junit.opcodes.if_eqz.Main_testB3;dot.junit.opcodes.if_eqz.d.T_if_eqz_3 ;if-eqz;Boundary #3;Arguments = Float.MAX_VALUE
dot.junit.opcodes.if_eqz.Main_testB4;dot.junit.opcodes.if_eqz.d.T_if_eqz_3 ;if-eqz;Boundary #4;Arguments = Float.MIN_VALUE
dot.junit.opcodes.if_eqz.Main_testB5;dot.junit.opcodes.if_eqz.d.T_if_eqz_1 ;if-eqz;Boundary #5;Arguments = 0
dot.junit.opcodes.if_eqz.Main_testB6;dot.junit.opcodes.if_eqz.d.T_if_eqz_4 ;if-eqz;Boundary #6;Compare with null
dot.junit.opcodes.if_eqz.Main_testN1;dot.junit.opcodes.if_eqz.d.T_if_eqz_1 ;if-eqz;Normal #1;Argument = 5 and -5
dot.junit.opcodes.if_eqz.Main_testN2;dot.junit.opcodes.if_eqz.d.T_if_eqz_2 ;if-eqz;Normal #2;Arguments = not null
dot.junit.opcodes.if_eqz.Main_testN3;dot.junit.opcodes.if_eqz.d.T_if_eqz_3 ;if-eqz;Normal #3;Types of arguments - float. Dalvik doens't distinguish 32-bits types internally, so this operation of float makes no sense but shall not crash the VM.
dot.junit.opcodes.if_eqz.Main_testVFE1;dot.junit.opcodes.if_eqz.d.T_if_eqz_5 ;if-eqz;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.if_eqz.Main_testVFE2;dot.junit.opcodes.if_eqz.d.T_if_eqz_6 ;if-eqz;Verifier #2; Constraint B1, types of arguments - double
dot.junit.opcodes.if_eqz.Main_testVFE3;dot.junit.opcodes.if_eqz.d.T_if_eqz_7 ;if-eqz;Verifier #3; Constraint B1, types of arguments - long
dot.junit.opcodes.if_eqz.Main_testVFE4;dot.junit.opcodes.if_eqz.d.T_if_eqz_9 ;if-eqz;Verifier #4; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.if_eqz.Main_testVFE5;dot.junit.opcodes.if_eqz.d.T_if_eqz_10 ;if-eqz;Verifier #5; Constraint A6, branch target shall not be "inside" instruction
dot.junit.opcodes.if_eqz.Main_testVFE6;dot.junit.opcodes.if_eqz.d.T_if_eqz_11 ;if-eqz;Verifier #6; Constraint n/a, branch must not be 0
dot.junit.opcodes.if_ge.Main_testB1;dot.junit.opcodes.if_ge.d.T_if_ge_1 ;if-ge;Boundary #1;Arguments = Integer.MAX_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.if_ge.Main_testB2;dot.junit.opcodes.if_ge.d.T_if_ge_1 ;if-ge;Boundary #2;Arguments = Integer.MIN_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.if_ge.Main_testB3;dot.junit.opcodes.if_ge.d.T_if_ge_1 ;if-ge;Boundary #3;Arguments = Integer.MAX_VALUE, Integer.MIN_VALUE
dot.junit.opcodes.if_ge.Main_testB4;dot.junit.opcodes.if_ge.d.T_if_ge_1 ;if-ge;Boundary #4;Arguments = 0, Integer.MIN_VALUE
dot.junit.opcodes.if_ge.Main_testB5;dot.junit.opcodes.if_ge.d.T_if_ge_1 ;if-ge;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.if_ge.Main_testN1;dot.junit.opcodes.if_ge.d.T_if_ge_1 ;if-ge;Normal #1;Case: 5 < 6
dot.junit.opcodes.if_ge.Main_testN2;dot.junit.opcodes.if_ge.d.T_if_ge_1 ;if-ge;Normal #2;Case: 0x0f0e0d0c = 0x0f0e0d0c
dot.junit.opcodes.if_ge.Main_testN3;dot.junit.opcodes.if_ge.d.T_if_ge_1 ;if-ge;Normal #3;Case: 5 > -5
dot.junit.opcodes.if_ge.Main_testN4;dot.junit.opcodes.if_ge.d.T_if_ge_3 ;if-ge;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this operation of int and float makes no sense but shall not crash the VM.
dot.junit.opcodes.if_ge.Main_testVFE1;dot.junit.opcodes.if_ge.d.T_if_ge_4 ;if-ge;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.if_ge.Main_testVFE2;dot.junit.opcodes.if_ge.d.T_if_ge_5 ;if-ge;Verifier #2; Constraint B1, types of arguments - int, double
dot.junit.opcodes.if_ge.Main_testVFE3;dot.junit.opcodes.if_ge.d.T_if_ge_6 ;if-ge;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.if_ge.Main_testVFE4;dot.junit.opcodes.if_ge.d.T_if_ge_7 ;if-ge;Verifier #4; Constraint B1, types of arguments - int, reference
dot.junit.opcodes.if_ge.Main_testVFE6;dot.junit.opcodes.if_ge.d.T_if_ge_9 ;if-ge;Verifier #6; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.if_ge.Main_testVFE7;dot.junit.opcodes.if_ge.d.T_if_ge_10 ;if-ge;Verifier #7; Constraint A6, branch target shall not be "inside" instruction
dot.junit.opcodes.if_ge.Main_testVFE8;dot.junit.opcodes.if_ge.d.T_if_ge_11 ;if-ge;Verifier #8; Constraint n/a, branch target shall 0
dot.junit.opcodes.if_gez.Main_testB1;dot.junit.opcodes.if_gez.d.T_if_gez_1 ;if-gez;Boundary #1;Arguments = Integer.MAX_VALUE
dot.junit.opcodes.if_gez.Main_testB2;dot.junit.opcodes.if_gez.d.T_if_gez_1 ;if-gez;Boundary #2;Arguments = Integer.MIN_VALUE
dot.junit.opcodes.if_gez.Main_testB3;dot.junit.opcodes.if_gez.d.T_if_gez_1 ;if-gez;Boundary #3;Arguments = 0
dot.junit.opcodes.if_gez.Main_testN1;dot.junit.opcodes.if_gez.d.T_if_gez_1 ;if-gez;Normal #1;Argument = 5
dot.junit.opcodes.if_gez.Main_testN2;dot.junit.opcodes.if_gez.d.T_if_gez_1 ;if-gez;Normal #2;Argument = -5
dot.junit.opcodes.if_gez.Main_testN3;dot.junit.opcodes.if_gez.d.T_if_gez_2 ;if-gez;Normal #3;Types of arguments - float. Dalvik doens't distinguish 32-bits types internally, so this operation of float makes no sense but shall not crash the VM.
dot.junit.opcodes.if_gez.Main_testVFE1;dot.junit.opcodes.if_gez.d.T_if_gez_3 ;if-gez;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.if_gez.Main_testVFE2;dot.junit.opcodes.if_gez.d.T_if_gez_4 ;if-gez;Verifier #2; Constraint B1, types of arguments - double
dot.junit.opcodes.if_gez.Main_testVFE3;dot.junit.opcodes.if_gez.d.T_if_gez_5 ;if-gez;Verifier #3; Constraint B1, types of arguments - long
dot.junit.opcodes.if_gez.Main_testVFE4;dot.junit.opcodes.if_gez.d.T_if_gez_6 ;if-gez;Verifier #4; Constraint B1, types of arguments - reference
dot.junit.opcodes.if_gez.Main_testVFE5;dot.junit.opcodes.if_gez.d.T_if_gez_8 ;if-gez;Verifier #5; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.if_gez.Main_testVFE6;dot.junit.opcodes.if_gez.d.T_if_gez_9 ;if-gez;Verifier #6; Constraint A6, branch target shall not be "inside" instruction
dot.junit.opcodes.if_gez.Main_testVFE7;dot.junit.opcodes.if_gez.d.T_if_gez_10 ;if-gez;Verifier #7; Constraint n/a, branch must not be 0
dot.junit.opcodes.if_gt.Main_testB1;dot.junit.opcodes.if_gt.d.T_if_gt_1 ;if-gt;Boundary #1;Arguments = Integer.MAX_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.if_gt.Main_testB2;dot.junit.opcodes.if_gt.d.T_if_gt_1 ;if-gt;Boundary #2;Arguments = Integer.MIN_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.if_gt.Main_testB3;dot.junit.opcodes.if_gt.d.T_if_gt_1 ;if-gt;Boundary #3;Arguments = Integer.MAX_VALUE, Integer.MIN_VALUE
dot.junit.opcodes.if_gt.Main_testB4;dot.junit.opcodes.if_gt.d.T_if_gt_1 ;if-gt;Boundary #4;Arguments = 0, Integer.MIN_VALUE
dot.junit.opcodes.if_gt.Main_testB5;dot.junit.opcodes.if_gt.d.T_if_gt_1 ;if-gt;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.if_gt.Main_testN1;dot.junit.opcodes.if_gt.d.T_if_gt_1 ;if-gt;Normal #1;Case: 5 < 6
dot.junit.opcodes.if_gt.Main_testN2;dot.junit.opcodes.if_gt.d.T_if_gt_1 ;if-gt;Normal #2;Case: 0x0f0e0d0c = 0x0f0e0d0c
dot.junit.opcodes.if_gt.Main_testN3;dot.junit.opcodes.if_gt.d.T_if_gt_1 ;if-gt;Normal #3;Case: 5 > -5
dot.junit.opcodes.if_gt.Main_testN4;dot.junit.opcodes.if_gt.d.T_if_gt_3 ;if-gt;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this operation of int and float makes no sense but shall not crash the VM.
dot.junit.opcodes.if_gt.Main_testVFE1;dot.junit.opcodes.if_gt.d.T_if_gt_4 ;if-gt;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.if_gt.Main_testVFE2;dot.junit.opcodes.if_gt.d.T_if_gt_5 ;if-gt;Verifier #2; Constraint B1, types of arguments - int, double
dot.junit.opcodes.if_gt.Main_testVFE3;dot.junit.opcodes.if_gt.d.T_if_gt_6 ;if-gt;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.if_gt.Main_testVFE4;dot.junit.opcodes.if_gt.d.T_if_gt_7 ;if-gt;Verifier #4; Constraint B1, types of arguments - int, reference
dot.junit.opcodes.if_gt.Main_testVFE5;dot.junit.opcodes.if_gt.d.T_if_gt_9 ;if-gt;Verifier #5; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.if_gt.Main_testVFE6;dot.junit.opcodes.if_gt.d.T_if_gt_10 ;if-gt;Verifier #6; Constraint A6, branch target shall not be "inside" instruction
dot.junit.opcodes.if_gt.Main_testVFE7;dot.junit.opcodes.if_gt.d.T_if_gt_11 ;if-gt;Verifier #7; Constraint n/a, branch target shall not be 0
dot.junit.opcodes.if_gtz.Main_testB1;dot.junit.opcodes.if_gtz.d.T_if_gtz_1 ;if-gtz;Boundary #1;Arguments = Integer.MAX_VALUE
dot.junit.opcodes.if_gtz.Main_testB2;dot.junit.opcodes.if_gtz.d.T_if_gtz_1 ;if-gtz;Boundary #2;Arguments = Integer.MIN_VALUE
dot.junit.opcodes.if_gtz.Main_testB3;dot.junit.opcodes.if_gtz.d.T_if_gtz_1 ;if-gtz;Boundary #3;Arguments = 0
dot.junit.opcodes.if_gtz.Main_testN1;dot.junit.opcodes.if_gtz.d.T_if_gtz_1 ;if-gtz;Normal #1;Argument = 5
dot.junit.opcodes.if_gtz.Main_testN2;dot.junit.opcodes.if_gtz.d.T_if_gtz_1 ;if-gtz;Normal #2;Argument = -5
dot.junit.opcodes.if_gtz.Main_testN3;dot.junit.opcodes.if_gtz.d.T_if_gtz_2 ;if-gtz;Normal #3;Types of arguments - float. Dalvik doens't distinguish 32-bits types internally, so this operation of float makes no sense but shall not crash the VM.
dot.junit.opcodes.if_gtz.Main_testVFE1;dot.junit.opcodes.if_gtz.d.T_if_gtz_3 ;if-gtz;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.if_gtz.Main_testVFE2;dot.junit.opcodes.if_gtz.d.T_if_gtz_4 ;if-gtz;Verifier #2; Constraint B1, types of arguments - double
dot.junit.opcodes.if_gtz.Main_testVFE3;dot.junit.opcodes.if_gtz.d.T_if_gtz_5 ;if-gtz;Verifier #3; Constraint B1, types of arguments - long
dot.junit.opcodes.if_gtz.Main_testVFE4;dot.junit.opcodes.if_gtz.d.T_if_gtz_6 ;if-gtz;Verifier #4; Constraint B1, types of arguments - reference
dot.junit.opcodes.if_gtz.Main_testVFE5;dot.junit.opcodes.if_gtz.d.T_if_gtz_8 ;if-gtz;Verifier #5; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.if_gtz.Main_testVFE6;dot.junit.opcodes.if_gtz.d.T_if_gtz_9 ;if-gtz;Verifier #6; Constraint A6, branch target shall not be "inside" instruction
dot.junit.opcodes.if_gtz.Main_testVFE7;dot.junit.opcodes.if_gtz.d.T_if_gtz_10 ;if-gtz;Verifier #7; Constraint n/a, branch must not be 0
dot.junit.opcodes.if_le.Main_testB1;dot.junit.opcodes.if_le.d.T_if_le_1 ;if-le;Boundary #1;Arguments = Integer.MAX_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.if_le.Main_testB2;dot.junit.opcodes.if_le.d.T_if_le_1 ;if-le;Boundary #2;Arguments = Integer.MIN_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.if_le.Main_testB3;dot.junit.opcodes.if_le.d.T_if_le_1 ;if-le;Boundary #3;Arguments = Integer.MAX_VALUE, Integer.MIN_VALUE
dot.junit.opcodes.if_le.Main_testB4;dot.junit.opcodes.if_le.d.T_if_le_1 ;if-le;Boundary #4;Arguments = 0, Integer.MIN_VALUE
dot.junit.opcodes.if_le.Main_testB5;dot.junit.opcodes.if_le.d.T_if_le_1 ;if-le;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.if_le.Main_testN1;dot.junit.opcodes.if_le.d.T_if_le_1 ;if-le;Normal #1;Case: 5 < 6
dot.junit.opcodes.if_le.Main_testN2;dot.junit.opcodes.if_le.d.T_if_le_1 ;if-le;Normal #2;Case: 0x0f0e0d0c = 0x0f0e0d0c
dot.junit.opcodes.if_le.Main_testN3;dot.junit.opcodes.if_le.d.T_if_le_1 ;if-le;Normal #3;Case: 5 > -5
dot.junit.opcodes.if_le.Main_testN4;dot.junit.opcodes.if_le.d.T_if_le_11 ;if-le;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this operation of int and float makes no sense but shall not crash the VM.
dot.junit.opcodes.if_le.Main_testVFE1;dot.junit.opcodes.if_le.d.T_if_le_4 ;if-le;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.if_le.Main_testVFE2;dot.junit.opcodes.if_le.d.T_if_le_5 ;if-le;Verifier #2; Constraint B1, types of arguments - int, double
dot.junit.opcodes.if_le.Main_testVFE3;dot.junit.opcodes.if_le.d.T_if_le_6 ;if-le;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.if_le.Main_testVFE4;dot.junit.opcodes.if_le.d.T_if_le_7 ;if-le;Verifier #4; Constraint B1, types of arguments - int, reference
dot.junit.opcodes.if_le.Main_testVFE5;dot.junit.opcodes.if_le.d.T_if_le_9 ;if-le;Verifier #5; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.if_le.Main_testVFE6;dot.junit.opcodes.if_le.d.T_if_le_10 ;if-le;Verifier #6; Constraint A6, branch target shall not be "inside" instruction
dot.junit.opcodes.if_le.Main_testVFE7;dot.junit.opcodes.if_le.d.T_if_le_12 ;if-le;Verifier #7; Constraint n/a, branch target shall not be 0
dot.junit.opcodes.if_lez.Main_testB1;dot.junit.opcodes.if_lez.d.T_if_lez_1 ;if-lez;Boundary #1;Arguments = Integer.MAX_VALUE
dot.junit.opcodes.if_lez.Main_testB2;dot.junit.opcodes.if_lez.d.T_if_lez_1 ;if-lez;Boundary #2;Arguments = Integer.MIN_VALUE
dot.junit.opcodes.if_lez.Main_testB3;dot.junit.opcodes.if_lez.d.T_if_lez_1 ;if-lez;Boundary #3;Arguments = 0
dot.junit.opcodes.if_lez.Main_testN1;dot.junit.opcodes.if_lez.d.T_if_lez_1 ;if-lez;Normal #1;Argument = 5
dot.junit.opcodes.if_lez.Main_testN2;dot.junit.opcodes.if_lez.d.T_if_lez_1 ;if-lez;Normal #2;Argument = -5
dot.junit.opcodes.if_lez.Main_testN3;dot.junit.opcodes.if_lez.d.T_if_lez_2 ;if-lez;Normal #3;Types of arguments - float. Dalvik doens't distinguish 32-bits types internally, so this operation of float makes no sense but shall not crash the VM.
dot.junit.opcodes.if_lez.Main_testVFE1;dot.junit.opcodes.if_lez.d.T_if_lez_3 ;if-lez;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.if_lez.Main_testVFE2;dot.junit.opcodes.if_lez.d.T_if_lez_4 ;if-lez;Verifier #2; Constraint B1, types of arguments - double
dot.junit.opcodes.if_lez.Main_testVFE3;dot.junit.opcodes.if_lez.d.T_if_lez_5 ;if-lez;Verifier #3; Constraint B1, types of arguments - long
dot.junit.opcodes.if_lez.Main_testVFE4;dot.junit.opcodes.if_lez.d.T_if_lez_6 ;if-lez;Verifier #4; Constraint B1, types of arguments - reference
dot.junit.opcodes.if_lez.Main_testVFE5;dot.junit.opcodes.if_lez.d.T_if_lez_8 ;if-lez;Verifier #5; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.if_lez.Main_testVFE6;dot.junit.opcodes.if_lez.d.T_if_lez_9 ;if-lez;Verifier #6; Constraint A6, branch target shall not be "inside" instruction
dot.junit.opcodes.if_lez.Main_testVFE7;dot.junit.opcodes.if_lez.d.T_if_lez_10 ;if-lez;Verifier #7; Constraint n/a, branch must not be 0
dot.junit.opcodes.if_lt.Main_testB1;dot.junit.opcodes.if_lt.d.T_if_lt_1 ;if-lt;Boundary #1;Arguments = Integer.MAX_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.if_lt.Main_testB2;dot.junit.opcodes.if_lt.d.T_if_lt_1 ;if-lt;Boundary #2;Arguments = Integer.MIN_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.if_lt.Main_testB3;dot.junit.opcodes.if_lt.d.T_if_lt_1 ;if-lt;Boundary #3;Arguments = Integer.MAX_VALUE, Integer.MIN_VALUE
dot.junit.opcodes.if_lt.Main_testB4;dot.junit.opcodes.if_lt.d.T_if_lt_1 ;if-lt;Boundary #4;Arguments = 0, Integer.MIN_VALUE
dot.junit.opcodes.if_lt.Main_testB5;dot.junit.opcodes.if_lt.d.T_if_lt_1 ;if-lt;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.if_lt.Main_testN1;dot.junit.opcodes.if_lt.d.T_if_lt_1 ;if-lt;Normal #1;Case: 5 < 6
dot.junit.opcodes.if_lt.Main_testN2;dot.junit.opcodes.if_lt.d.T_if_lt_1 ;if-lt;Normal #2;Case: 0x0f0e0d0c = 0x0f0e0d0c
dot.junit.opcodes.if_lt.Main_testN3;dot.junit.opcodes.if_lt.d.T_if_lt_1 ;if-lt;Normal #3;Case: 5 > -5
dot.junit.opcodes.if_lt.Main_testN4;dot.junit.opcodes.if_lt.d.T_if_lt_11 ;if-lt;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this operation of int and float makes no sense but shall not crash the VM.
dot.junit.opcodes.if_lt.Main_testVFE1;dot.junit.opcodes.if_lt.d.T_if_lt_4 ;if-lt;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.if_lt.Main_testVFE2;dot.junit.opcodes.if_lt.d.T_if_lt_5 ;if-lt;Verifier #2; Constraint B1, types of arguments - int, double
dot.junit.opcodes.if_lt.Main_testVFE3;dot.junit.opcodes.if_lt.d.T_if_lt_6 ;if-lt;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.if_lt.Main_testVFE4;dot.junit.opcodes.if_lt.d.T_if_lt_7 ;if-lt;Verifier #4; Constraint B1, types of arguments - int, reference
dot.junit.opcodes.if_lt.Main_testVFE5;dot.junit.opcodes.if_lt.d.T_if_lt_9 ;if-lt;Verifier #5; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.if_lt.Main_testVFE6;dot.junit.opcodes.if_lt.d.T_if_lt_10 ;if-lt;Verifier #6; Constraint A6, branch target shall not be "inside" instruction
dot.junit.opcodes.if_lt.Main_testVFE7;dot.junit.opcodes.if_lt.d.T_if_lt_12 ;if-lt;Verifier #7; Constraint n/a, branch target shall not be 0
dot.junit.opcodes.if_ltz.Main_testB1;dot.junit.opcodes.if_ltz.d.T_if_ltz_1 ;if-ltz;Boundary #1;Arguments = Integer.MAX_VALUE
dot.junit.opcodes.if_ltz.Main_testB2;dot.junit.opcodes.if_ltz.d.T_if_ltz_1 ;if-ltz;Boundary #2;Arguments = Integer.MIN_VALUE
dot.junit.opcodes.if_ltz.Main_testB3;dot.junit.opcodes.if_ltz.d.T_if_ltz_1 ;if-ltz;Boundary #3;Arguments = 0
dot.junit.opcodes.if_ltz.Main_testN1;dot.junit.opcodes.if_ltz.d.T_if_ltz_1 ;if-ltz;Normal #1;Argument = 5
dot.junit.opcodes.if_ltz.Main_testN2;dot.junit.opcodes.if_ltz.d.T_if_ltz_1 ;if-ltz;Normal #2;Argument = -5
dot.junit.opcodes.if_ltz.Main_testN3;dot.junit.opcodes.if_ltz.d.T_if_ltz_2 ;if-ltz;Normal #3;Types of arguments - float. Dalvik doens't distinguish 32-bits types internally, so this operation of float makes no sense but shall not crash the VM.
dot.junit.opcodes.if_ltz.Main_testVFE1;dot.junit.opcodes.if_ltz.d.T_if_ltz_3 ;if-ltz;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.if_ltz.Main_testVFE2;dot.junit.opcodes.if_ltz.d.T_if_ltz_4 ;if-ltz;Verifier #2; Constraint B1, types of arguments - double
dot.junit.opcodes.if_ltz.Main_testVFE3;dot.junit.opcodes.if_ltz.d.T_if_ltz_5 ;if-ltz;Verifier #3; Constraint B1, types of arguments - long
dot.junit.opcodes.if_ltz.Main_testVFE4;dot.junit.opcodes.if_ltz.d.T_if_ltz_6 ;if-ltz;Verifier #4; Constraint B1, types of arguments - reference
dot.junit.opcodes.if_ltz.Main_testVFE5;dot.junit.opcodes.if_ltz.d.T_if_ltz_8 ;if-ltz;Verifier #5; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.if_ltz.Main_testVFE6;dot.junit.opcodes.if_ltz.d.T_if_ltz_9 ;if-ltz;Verifier #6; Constraint A6, branch target shall not be "inside" instruction
dot.junit.opcodes.if_ltz.Main_testVFE7;dot.junit.opcodes.if_ltz.d.T_if_ltz_7 ;if-ltz;Verifier #7; Constraint n/a, branch must not be 0
dot.junit.opcodes.if_ne.Main_testB1;dot.junit.opcodes.if_ne.d.T_if_ne_1 ;if-ne;Boundary #1;Arguments = Integer.MAX_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.if_ne.Main_testB2;dot.junit.opcodes.if_ne.d.T_if_ne_1 ;if-ne;Boundary #2;Arguments = Integer.MIN_VALUE, Integer.MIN_VALUE
dot.junit.opcodes.if_ne.Main_testB3;dot.junit.opcodes.if_ne.d.T_if_ne_1 ;if-ne;Boundary #3;Arguments = 0, 1234567
dot.junit.opcodes.if_ne.Main_testB4;dot.junit.opcodes.if_ne.d.T_if_ne_1 ;if-ne;Boundary #4;Arguments = 0, 0
dot.junit.opcodes.if_ne.Main_testB5;dot.junit.opcodes.if_ne.d.T_if_ne_2 ;if-ne;Boundary #5;Compare with null
dot.junit.opcodes.if_ne.Main_testN1;dot.junit.opcodes.if_ne.d.T_if_ne_1 ;if-ne;Normal #1;Arguments = 5, 6
dot.junit.opcodes.if_ne.Main_testN2;dot.junit.opcodes.if_ne.d.T_if_ne_1 ;if-ne;Normal #2;Arguments = 0x0f0e0d0c, 0x0f0e0d0c
dot.junit.opcodes.if_ne.Main_testN3;dot.junit.opcodes.if_ne.d.T_if_ne_1 ;if-ne;Normal #3;Arguments = 5, -5
dot.junit.opcodes.if_ne.Main_testN4;dot.junit.opcodes.if_ne.d.T_if_ne_1 ;if-ne;Normal #4;Arguments = 0x01001234, 0x1234
dot.junit.opcodes.if_ne.Main_testN5;dot.junit.opcodes.if_ne.d.T_if_ne_2 ;if-ne;Normal #5;Compare references
dot.junit.opcodes.if_ne.Main_testN6;dot.junit.opcodes.if_ne.d.T_if_ne_2 ;if-ne;Normal #6;Compare references
dot.junit.opcodes.if_ne.Main_testN7;dot.junit.opcodes.if_ne.d.T_if_ne_4 ;if-ne;Normal #7;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this operation of int and float makes no sense but shall not crash the VM.
dot.junit.opcodes.if_ne.Main_testVFE1;dot.junit.opcodes.if_ne.d.T_if_ne_5 ;if-ne;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.if_ne.Main_testVFE2;dot.junit.opcodes.if_ne.d.T_if_ne_7 ;if-ne;Verifier #2; Constraint B1, types of arguments - int, double
dot.junit.opcodes.if_ne.Main_testVFE3;dot.junit.opcodes.if_ne.d.T_if_ne_8 ;if-ne;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.if_ne.Main_testVFE4;dot.junit.opcodes.if_ne.d.T_if_ne_9 ;if-ne;Verifier #4; Constraint B1, types of arguments - int, reference
dot.junit.opcodes.if_ne.Main_testVFE5;dot.junit.opcodes.if_ne.d.T_if_ne_10 ;if-ne;Verifier #5; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.if_ne.Main_testVFE6;dot.junit.opcodes.if_ne.d.T_if_ne_11 ;if-ne;Verifier #6; Constraint A6, branch target shall not be "inside" instruction
dot.junit.opcodes.if_ne.Main_testVFE7;dot.junit.opcodes.if_ne.d.T_if_ne_12 ;if-ne;Verifier #7; Constraint n/a, branch target shall not be 0
dot.junit.opcodes.if_nez.Main_testB1;dot.junit.opcodes.if_nez.d.T_if_nez_1 ;if-nez;Boundary #1;Arguments = Integer.MAX_VALUE
dot.junit.opcodes.if_nez.Main_testB2;dot.junit.opcodes.if_nez.d.T_if_nez_1 ;if-nez;Boundary #2;Arguments = Integer.MIN_VALUE
dot.junit.opcodes.if_nez.Main_testB3;dot.junit.opcodes.if_nez.d.T_if_nez_1 ;if-nez;Boundary #3;Arguments = 0
dot.junit.opcodes.if_nez.Main_testB4;dot.junit.opcodes.if_nez.d.T_if_nez_4 ;if-nez;Boundary #4;Compare reference with null
dot.junit.opcodes.if_nez.Main_testN1;dot.junit.opcodes.if_nez.d.T_if_nez_1 ;if-nez;Normal #1;Argument = 5 and -5
dot.junit.opcodes.if_nez.Main_testN2;dot.junit.opcodes.if_nez.d.T_if_nez_2 ;if-nez;Normal #2;Arguments = null
dot.junit.opcodes.if_nez.Main_testN3;dot.junit.opcodes.if_nez.d.T_if_nez_2 ;if-nez;Normal #3;Arguments = not null
dot.junit.opcodes.if_nez.Main_testN4;dot.junit.opcodes.if_nez.d.T_if_nez_3 ;if-nez;Normal #4;Types of arguments - float. Dalvik doens't distinguish 32-bits types internally, so this operation of float makes no sense but shall not crash the VM.
dot.junit.opcodes.if_nez.Main_testVFE1;dot.junit.opcodes.if_nez.d.T_if_nez_5 ;if-nez;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.if_nez.Main_testVFE2;dot.junit.opcodes.if_nez.d.T_if_nez_6 ;if-nez;Verifier #2; Constraint B1, types of arguments - double
dot.junit.opcodes.if_nez.Main_testVFE3;dot.junit.opcodes.if_nez.d.T_if_nez_7 ;if-nez;Verifier #3; Constraint B1, types of arguments - long
dot.junit.opcodes.if_nez.Main_testVFE5;dot.junit.opcodes.if_nez.d.T_if_nez_9 ;if-nez;Verifier #5; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.if_nez.Main_testVFE6;dot.junit.opcodes.if_nez.d.T_if_nez_10 ;if-nez;Verifier #6; Constraint A6, branch target shall not be "inside" instruction
dot.junit.opcodes.if_nez.Main_testVFE7;dot.junit.opcodes.if_nez.d.T_if_nez_11 ;if-nez;Verifier #7; Constraint n/a, branch must not be 0
dot.junit.opcodes.iget_boolean.Main_testE2;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_9 ;iget-boolean;Exception #2;Expected NullPointerException
dot.junit.opcodes.iget_boolean.Main_testN1;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_1 ;iget-boolean;Normal #1;Get boolean from field
dot.junit.opcodes.iget_boolean.Main_testN3;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_1 dot.junit.opcodes.iget_boolean.d.T_iget_boolean_11 ;iget-boolean;Normal #3;Access protected field from subclass
dot.junit.opcodes.iget_boolean.Main_testVFE1;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_4 ;iget-boolean;Verifier #1; Constraint A11, constant pool index
dot.junit.opcodes.iget_boolean.Main_testVFE10;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_16 ;iget-boolean;Verifier #10; Constraint B1, iget_boolean shall not work for int fields
dot.junit.opcodes.iget_boolean.Main_testVFE11;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_17 ;iget-boolean;Verifier #11; Constraint B1, iget_boolean shall not work for char fields
dot.junit.opcodes.iget_boolean.Main_testVFE12;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_18 ;iget-boolean;Verifier #12; Constraint B1, iget_boolean shall not work for byte fields
dot.junit.opcodes.iget_boolean.Main_testVFE13;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_19 ;iget-boolean;Verifier #13; Constraint B1, iget_boolean shall not work for double fields
dot.junit.opcodes.iget_boolean.Main_testVFE14;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_20 ;iget-boolean;Verifier #14; Constraint B1, iget_boolean shall not work for long fields
dot.junit.opcodes.iget_boolean.Main_testVFE15;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_21 dot.junit.opcodes.iget_boolean.TestStubs ;iget-boolean;Verifier #15; Constraint B12, Attempt to read inaccessible protected field.
dot.junit.opcodes.iget_boolean.Main_testVFE16;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_5 dot.junit.opcodes.iget_boolean.TestStubs ;iget-boolean;Verifier #16; Constraint A11, Attempt to read static field.
dot.junit.opcodes.iget_boolean.Main_testVFE2;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_3 ;iget-boolean;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.iget_boolean.Main_testVFE3;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_13 ;iget-boolean;Verifier #3; Constraint B13, read boolean from long field - only field with same name but  different type exists
dot.junit.opcodes.iget_boolean.Main_testVFE30;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_30 ;iget-boolean;Verifier #30; Constraint B6, instance fields may only be accessed on already initialized instances.
dot.junit.opcodes.iget_boolean.Main_testVFE4;dot.junit.opcodes.iget_boolean.TestStubs dot.junit.opcodes.iget_boolean.d.T_iget_boolean_6 ;iget-boolean;Verifier #4; Constraint n/a, Attempt to read inaccessible field
dot.junit.opcodes.iget_boolean.Main_testVFE5;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_7 ;iget-boolean;Verifier #5; Constraint n/a, Attempt to read field of undefined class.
dot.junit.opcodes.iget_boolean.Main_testVFE6;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_8 ;iget-boolean;Verifier #6; Constraint n/a, Attempt to read undefined field.
dot.junit.opcodes.iget_boolean.Main_testVFE7;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_12 dot.junit.opcodes.iget_boolean.d.T_iget_boolean_1 ;iget-boolean;Verifier #7; Constraint n/a, Attempt to read superclass' private field from subclass.
dot.junit.opcodes.iget_boolean.Main_testVFE8;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_14 ;iget-boolean;Verifier #8; Constraint B1, iget_boolean shall not work for reference fields
dot.junit.opcodes.iget_boolean.Main_testVFE9;dot.junit.opcodes.iget_boolean.d.T_iget_boolean_15 ;iget-boolean;Verifier #9; Constraint B1, iget_boolean shall not work for short fields
dot.junit.opcodes.iget_byte.Main_testE2;dot.junit.opcodes.iget_byte.d.T_iget_byte_9 ;iget-byte;Exception #2;Expected NullPointerException
dot.junit.opcodes.iget_byte.Main_testN1;dot.junit.opcodes.iget_byte.d.T_iget_byte_1 ;iget-byte;Normal #1;Get byte from field
dot.junit.opcodes.iget_byte.Main_testN3;dot.junit.opcodes.iget_byte.d.T_iget_byte_11 dot.junit.opcodes.iget_byte.d.T_iget_byte_1 ;iget-byte;Normal #3;Access protected field from subclass
dot.junit.opcodes.iget_byte.Main_testVFE1;dot.junit.opcodes.iget_byte.d.T_iget_byte_4 ;iget-byte;Verifier #1; Constraint A11, constant pool index
dot.junit.opcodes.iget_byte.Main_testVFE10;dot.junit.opcodes.iget_byte.d.T_iget_byte_16 ;iget-byte;Verifier #10; Constraint B1, iget_byte shall not work for int fields
dot.junit.opcodes.iget_byte.Main_testVFE11;dot.junit.opcodes.iget_byte.d.T_iget_byte_17 ;iget-byte;Verifier #11; Constraint B1, iget_byte shall not work for char fields
dot.junit.opcodes.iget_byte.Main_testVFE12;dot.junit.opcodes.iget_byte.d.T_iget_byte_18 ;iget-byte;Verifier #12; Constraint B1, iget_byte shall not work for boolean fields
dot.junit.opcodes.iget_byte.Main_testVFE13;dot.junit.opcodes.iget_byte.d.T_iget_byte_19 ;iget-byte;Verifier #13; Constraint B1, iget_byte shall not work for double fields
dot.junit.opcodes.iget_byte.Main_testVFE14;dot.junit.opcodes.iget_byte.d.T_iget_byte_20 ;iget-byte;Verifier #14; Constraint B1, iget_byte shall not work for long fields
dot.junit.opcodes.iget_byte.Main_testVFE15;dot.junit.opcodes.iget_byte.TestStubs dot.junit.opcodes.iget_byte.d.T_iget_byte_21 ;iget-byte;Verifier #15; Constraint B12, Attempt to read inaccessible protected field.
dot.junit.opcodes.iget_byte.Main_testVFE16;dot.junit.opcodes.iget_byte.d.T_iget_byte_5 dot.junit.opcodes.iget_byte.TestStubs ;iget-byte;Verifier #16; Constraint A11, Attempt to read static  field.
dot.junit.opcodes.iget_byte.Main_testVFE2;dot.junit.opcodes.iget_byte.d.T_iget_byte_3 ;iget-byte;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.iget_byte.Main_testVFE3;dot.junit.opcodes.iget_byte.d.T_iget_byte_13 ;iget-byte;Verifier #3; Constraint B13, read byte from long field - only field with same name but  different type exists
dot.junit.opcodes.iget_byte.Main_testVFE30;dot.junit.opcodes.iget_byte.d.T_iget_byte_30 ;iget-byte;Verifier #30; Constraint B6, instance fields may only be accessed on already initialized instances.
dot.junit.opcodes.iget_byte.Main_testVFE4;dot.junit.opcodes.iget_byte.d.T_iget_byte_6 dot.junit.opcodes.iget_byte.TestStubs ;iget-byte;Verifier #4; Constraint n/a, Attempt to read inaccessible field.
dot.junit.opcodes.iget_byte.Main_testVFE5;dot.junit.opcodes.iget_byte.d.T_iget_byte_7 ;iget-byte;Verifier #5; Constraint n/a, Attempt to read field of undefined class.
dot.junit.opcodes.iget_byte.Main_testVFE6;dot.junit.opcodes.iget_byte.d.T_iget_byte_8 ;iget-byte;Verifier #6; Constraint n/a, Attempt to read undefined field.
dot.junit.opcodes.iget_byte.Main_testVFE7;dot.junit.opcodes.iget_byte.d.T_iget_byte_12 dot.junit.opcodes.iget_byte.d.T_iget_byte_1 ;iget-byte;Verifier #7; Constraint n/a, Attempt to read superclass' private field from subclass.
dot.junit.opcodes.iget_byte.Main_testVFE8;dot.junit.opcodes.iget_byte.d.T_iget_byte_14 ;iget-byte;Verifier #8; Constraint B1, iget_byte shall not work for reference fields
dot.junit.opcodes.iget_byte.Main_testVFE9;dot.junit.opcodes.iget_byte.d.T_iget_byte_15 ;iget-byte;Verifier #9; Constraint B1, iget_byte shall not work for short fields
dot.junit.opcodes.iget_char.Main_testE2;dot.junit.opcodes.iget_char.d.T_iget_char_9 ;iget-char;Exception #2;Expected NullPointerException
dot.junit.opcodes.iget_char.Main_testN1;dot.junit.opcodes.iget_char.d.T_iget_char_1 ;iget-char;Normal #1;Get char from field
dot.junit.opcodes.iget_char.Main_testN3;dot.junit.opcodes.iget_char.d.T_iget_char_11 dot.junit.opcodes.iget_char.d.T_iget_char_1 ;iget-char;Normal #3;Access protected field from subclass
dot.junit.opcodes.iget_char.Main_testVFE1;dot.junit.opcodes.iget_char.d.T_iget_char_4 ;iget-char;Verifier #1; Constraint A11, constant pool index
dot.junit.opcodes.iget_char.Main_testVFE10;dot.junit.opcodes.iget_char.d.T_iget_char_16 ;iget-char;Verifier #10; Constraint B1, iget_char shall not work for int fields
dot.junit.opcodes.iget_char.Main_testVFE11;dot.junit.opcodes.iget_char.d.T_iget_char_17 ;iget-char;Verifier #11; Constraint B1, iget_char shall not work for byte fields
dot.junit.opcodes.iget_char.Main_testVFE12;dot.junit.opcodes.iget_char.d.T_iget_char_18 ;iget-char;Verifier #12; Constraint B1, iget_char shall not work for boolean fields
dot.junit.opcodes.iget_char.Main_testVFE13;dot.junit.opcodes.iget_char.d.T_iget_char_19 ;iget-char;Verifier #13; Constraint B1, iget_char shall not work for double fields
dot.junit.opcodes.iget_char.Main_testVFE14;dot.junit.opcodes.iget_char.d.T_iget_char_20 ;iget-char;Verifier #14; Constraint B1, iget_char shall not work for long fields
dot.junit.opcodes.iget_char.Main_testVFE15;dot.junit.opcodes.iget_char.d.T_iget_char_21 dot.junit.opcodes.iget_char.TestStubs ;iget-char;Verifier #15; Constraint B12, Attempt to read inaccessible protected field.
dot.junit.opcodes.iget_char.Main_testVFE16;dot.junit.opcodes.iget_char.d.T_iget_char_5 dot.junit.opcodes.iget_char.TestStubs ;iget-char;Verifier #16; Constraint A11, Attempt to read static  field.
dot.junit.opcodes.iget_char.Main_testVFE2;dot.junit.opcodes.iget_char.d.T_iget_char_3 ;iget-char;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.iget_char.Main_testVFE3;dot.junit.opcodes.iget_char.d.T_iget_char_13 ;iget-char;Verifier #3; Constraint B13, read char from long field - only field with same name but  different type exists
dot.junit.opcodes.iget_char.Main_testVFE30;dot.junit.opcodes.iget_char.d.T_iget_char_30 ;iget-char;Verifier #30; Constraint B6, instance fields may only be accessed on already initialized instances.
dot.junit.opcodes.iget_char.Main_testVFE4;dot.junit.opcodes.iget_char.d.T_iget_char_6 dot.junit.opcodes.iget_char.TestStubs ;iget-char;Verifier #4; Constraint n/a, Attempt to read inaccessible field.
dot.junit.opcodes.iget_char.Main_testVFE5;dot.junit.opcodes.iget_char.d.T_iget_char_7 ;iget-char;Verifier #5; Constraint n/a, Attempt to read field of undefined class.
dot.junit.opcodes.iget_char.Main_testVFE6;dot.junit.opcodes.iget_char.d.T_iget_char_8 ;iget-char;Verifier #6; Constraint n/a, Attempt to read undefined field.
dot.junit.opcodes.iget_char.Main_testVFE7;dot.junit.opcodes.iget_char.d.T_iget_char_12 dot.junit.opcodes.iget_char.d.T_iget_char_1 ;iget-char;Verifier #7; Constraint n/a, Attempt to read superclass' private field from subclass.
dot.junit.opcodes.iget_char.Main_testVFE8;dot.junit.opcodes.iget_char.d.T_iget_char_14 ;iget-char;Verifier #8; Constraint B1, iget_char shall not work for reference fields
dot.junit.opcodes.iget_char.Main_testVFE9;dot.junit.opcodes.iget_char.d.T_iget_char_15 ;iget-char;Verifier #9; Constraint B1, iget_char shall not work for short fields
dot.junit.opcodes.iget_object.Main_testE2;dot.junit.opcodes.iget_object.d.T_iget_object_9 ;iget-object;Exception #2;Expected NullPointerException
dot.junit.opcodes.iget_object.Main_testN1;dot.junit.opcodes.iget_object.d.T_iget_object_1 ;iget-object;Normal #1;Get reference from field
dot.junit.opcodes.iget_object.Main_testN3;dot.junit.opcodes.iget_object.d.T_iget_object_1 dot.junit.opcodes.iget_object.d.T_iget_object_11 ;iget-object;Normal #3;Access protected field from subclass
dot.junit.opcodes.iget_object.Main_testVFE1;dot.junit.opcodes.iget_object.d.T_iget_object_4 ;iget-object;Verifier #1; Constraint A11, constant pool index
dot.junit.opcodes.iget_object.Main_testVFE10;dot.junit.opcodes.iget_object.d.T_iget_object_16 ;iget-object;Verifier #10; Constraint B1, iget_object shall not work for int fields
dot.junit.opcodes.iget_object.Main_testVFE11;dot.junit.opcodes.iget_object.d.T_iget_object_17 ;iget-object;Verifier #11; Constraint B1, iget_object shall not work for byte fields
dot.junit.opcodes.iget_object.Main_testVFE12;dot.junit.opcodes.iget_object.d.T_iget_object_18 ;iget-object;Verifier #12; Constraint B1, iget_object shall not work for boolean fields
dot.junit.opcodes.iget_object.Main_testVFE13;dot.junit.opcodes.iget_object.d.T_iget_object_19 ;iget-object;Verifier #13; Constraint B1, iget_object shall not work for double fields
dot.junit.opcodes.iget_object.Main_testVFE14;dot.junit.opcodes.iget_object.d.T_iget_object_20 ;iget-object;Verifier #14; Constraint B1, iget_object shall not work for long fields
dot.junit.opcodes.iget_object.Main_testVFE15;dot.junit.opcodes.iget_object.d.T_iget_object_21 ;iget-object;Verifier #15; Constraint B13, only field of different type exists
dot.junit.opcodes.iget_object.Main_testVFE16;dot.junit.opcodes.iget_object.TestStubs dot.junit.opcodes.iget_object.d.T_iget_object_22 ;iget-object;Verifier #16; Constraint B12, Attempt to read inaccessible protected field.
dot.junit.opcodes.iget_object.Main_testVFE17;dot.junit.opcodes.iget_object.TestStubs dot.junit.opcodes.iget_object.d.T_iget_object_5 ;iget-object;Verifier #17; Constraint A11, Attempt to read static field.
dot.junit.opcodes.iget_object.Main_testVFE2;dot.junit.opcodes.iget_object.d.T_iget_object_3 ;iget-object;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.iget_object.Main_testVFE3;dot.junit.opcodes.iget_object.d.T_iget_object_13 ;iget-object;Verifier #3; Constraint B13, (read object from long field - only field with same name but  different type exists)
dot.junit.opcodes.iget_object.Main_testVFE30;dot.junit.opcodes.iget_object.d.T_iget_object_30 ;iget-object;Verifier #30; Constraint B6, instance fields may only be accessed on already initialized instances.
dot.junit.opcodes.iget_object.Main_testVFE4;dot.junit.opcodes.iget_object.TestStubs dot.junit.opcodes.iget_object.d.T_iget_object_6 ;iget-object;Verifier #4; Constraint n/a, Attempt to read inaccessible field.
dot.junit.opcodes.iget_object.Main_testVFE5;dot.junit.opcodes.iget_object.d.T_iget_object_7 ;iget-object;Verifier #5; Constraint n/a, Attempt to read field of undefined class.
dot.junit.opcodes.iget_object.Main_testVFE6;dot.junit.opcodes.iget_object.d.T_iget_object_8 ;iget-object;Verifier #6; Constraint n/a, Attempt to read undefined field.
dot.junit.opcodes.iget_object.Main_testVFE7;dot.junit.opcodes.iget_object.d.T_iget_object_1 dot.junit.opcodes.iget_object.d.T_iget_object_12 ;iget-object;Verifier #7; Constraint n/a, Attempt to read superclass' private field from subclass.
dot.junit.opcodes.iget_object.Main_testVFE8;dot.junit.opcodes.iget_object.d.T_iget_object_14 ;iget-object;Verifier #8; Constraint B1, iget_object shall not work for short fields
dot.junit.opcodes.iget_object.Main_testVFE9;dot.junit.opcodes.iget_object.d.T_iget_object_15 ;iget-object;Verifier #9; Constraint B1, iget_object shall not work for char fields
dot.junit.opcodes.iget_short.Main_testE2;dot.junit.opcodes.iget_short.d.T_iget_short_9 ;iget-short;Exception #2;Expected NullPointerException
dot.junit.opcodes.iget_short.Main_testN1;dot.junit.opcodes.iget_short.d.T_iget_short_1 ;iget-short;Normal #1;Get short from field
dot.junit.opcodes.iget_short.Main_testN3;dot.junit.opcodes.iget_short.d.T_iget_short_11 dot.junit.opcodes.iget_short.d.T_iget_short_1 ;iget-short;Normal #3;Access protected field from subclass
dot.junit.opcodes.iget_short.Main_testVFE1;dot.junit.opcodes.iget_short.d.T_iget_short_4 ;iget-short;Verifier #1; Constraint A11, constant pool index
dot.junit.opcodes.iget_short.Main_testVFE10;dot.junit.opcodes.iget_short.d.T_iget_short_16 ;iget-short;Verifier #10; Constraint B1, iget_short shall not work for int fields
dot.junit.opcodes.iget_short.Main_testVFE11;dot.junit.opcodes.iget_short.d.T_iget_short_17 ;iget-short;Verifier #11; Constraint B1, iget_short shall not work for byte fields
dot.junit.opcodes.iget_short.Main_testVFE12;dot.junit.opcodes.iget_short.d.T_iget_short_18 ;iget-short;Verifier #12; Constraint B1, iget_short shall not work for boolean fields
dot.junit.opcodes.iget_short.Main_testVFE13;dot.junit.opcodes.iget_short.d.T_iget_short_19 ;iget-short;Verifier #13; Constraint B1, iget_short shall not work for double fields
dot.junit.opcodes.iget_short.Main_testVFE14;dot.junit.opcodes.iget_short.d.T_iget_short_20 ;iget-short;Verifier #14; Constraint B1, iget_short shall not work for long fields
dot.junit.opcodes.iget_short.Main_testVFE15;dot.junit.opcodes.iget_short.d.T_iget_short_21 dot.junit.opcodes.iget_short.TestStubs ;iget-short;Verifier #15; Constraint B12, Attempt to read inaccessible protected field.
dot.junit.opcodes.iget_short.Main_testVFE16;dot.junit.opcodes.iget_short.d.T_iget_short_5 dot.junit.opcodes.iget_short.TestStubs ;iget-short;Verifier #16; Constraint A11, Attempt to read static  field.
dot.junit.opcodes.iget_short.Main_testVFE2;dot.junit.opcodes.iget_short.d.T_iget_short_3 ;iget-short;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.iget_short.Main_testVFE3;dot.junit.opcodes.iget_short.d.T_iget_short_13 ;iget-short;Verifier #3; Constraint B13, read short from long field - only field with same name but  different type exists
dot.junit.opcodes.iget_short.Main_testVFE30;dot.junit.opcodes.iget_short.d.T_iget_short_30 ;iget-short;Verifier #30; Constraint B6, instance fields may only be accessed on already initialized instances.
dot.junit.opcodes.iget_short.Main_testVFE4;dot.junit.opcodes.iget_short.d.T_iget_short_6 dot.junit.opcodes.iget_short.TestStubs ;iget-short;Verifier #4; Constraint n/a, Attempt to read inaccessible field.
dot.junit.opcodes.iget_short.Main_testVFE5;dot.junit.opcodes.iget_short.d.T_iget_short_7 ;iget-short;Verifier #5; Constraint n/a, Attempt to read field of undefined class.
dot.junit.opcodes.iget_short.Main_testVFE6;dot.junit.opcodes.iget_short.d.T_iget_short_8 ;iget-short;Verifier #6; Constraint n/a, Attempt to read undefined field.
dot.junit.opcodes.iget_short.Main_testVFE7;dot.junit.opcodes.iget_short.d.T_iget_short_12 dot.junit.opcodes.iget_short.d.T_iget_short_1 ;iget-short;Verifier #7; Constraint n/a, Attempt to read superclass' private field from subclass.
dot.junit.opcodes.iget_short.Main_testVFE8;dot.junit.opcodes.iget_short.d.T_iget_short_14 ;iget-short;Verifier #8; Constraint B1, iget_short shall not work for reference fields
dot.junit.opcodes.iget_short.Main_testVFE9;dot.junit.opcodes.iget_short.d.T_iget_short_15 ;iget-short;Verifier #9; Constraint B1, iget_short shall not work for char fields
dot.junit.opcodes.iget.Main_testE2;dot.junit.opcodes.iget.d.T_iget_9 ;iget;Exception #2;Expected NullPointerException
dot.junit.opcodes.iget.Main_testN1;dot.junit.opcodes.iget.d.T_iget_1 ;iget;Normal #1;Type - int
dot.junit.opcodes.iget.Main_testN2;dot.junit.opcodes.iget.d.T_iget_2 ;iget;Normal #2;Type - float
dot.junit.opcodes.iget.Main_testN3;dot.junit.opcodes.iget.d.T_iget_1 dot.junit.opcodes.iget.d.T_iget_11 ;iget;Normal #3;Access protected field from subclass
dot.junit.opcodes.iget.Main_testVFE1;dot.junit.opcodes.iget.d.T_iget_4 ;iget;Verifier #1; Constraint A11, constant pool index
dot.junit.opcodes.iget.Main_testVFE10;dot.junit.opcodes.iget.d.T_iget_16 ;iget;Verifier #10; Constraint B1, iget shall not work for boolean fields
dot.junit.opcodes.iget.Main_testVFE11;dot.junit.opcodes.iget.d.T_iget_17 ;iget;Verifier #11; Constraint B1, iget shall not work for char fields
dot.junit.opcodes.iget.Main_testVFE12;dot.junit.opcodes.iget.d.T_iget_18 ;iget;Verifier #12; Constraint B1, iget shall not work for byte fields
dot.junit.opcodes.iget.Main_testVFE13;dot.junit.opcodes.iget.d.T_iget_19 ;iget;Verifier #13; Constraint B1, iget shall not work for double fields
dot.junit.opcodes.iget.Main_testVFE14;dot.junit.opcodes.iget.d.T_iget_20 ;iget;Verifier #14; Constraint B1, iget shall not work for long fields
dot.junit.opcodes.iget.Main_testVFE15;dot.junit.opcodes.iget.d.T_iget_21 dot.junit.opcodes.iget.TestStubs ;iget;Verifier #15; Constraint B12, Attempt to read protected field of unrelated class.
dot.junit.opcodes.iget.Main_testVFE16;dot.junit.opcodes.iget.TestStubs dot.junit.opcodes.iget.d.T_iget_5 ;iget;Verifier #16; Constraint A11, Attempt to read static field.
dot.junit.opcodes.iget.Main_testVFE2;dot.junit.opcodes.iget.d.T_iget_3 ;iget;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.iget.Main_testVFE3;dot.junit.opcodes.iget.d.T_iget_13 ;iget;Verifier #3; Constraint B13, read integer from long field - only field with same name but  different type exist
dot.junit.opcodes.iget.Main_testVFE30;dot.junit.opcodes.iget.d.T_iget_30 ;iget;Verifier #30; Constraint B6, instance fields may only be accessed on already initialized instances.
dot.junit.opcodes.iget.Main_testVFE4;dot.junit.opcodes.iget.TestStubs dot.junit.opcodes.iget.d.T_iget_6 ;iget;Verifier #4; Constraint n/a, Attempt to read inaccessible private field.
dot.junit.opcodes.iget.Main_testVFE5;dot.junit.opcodes.iget.d.T_iget_7 ;iget;Verifier #5; Constraint n/a, Attempt to read field of undefined class.
dot.junit.opcodes.iget.Main_testVFE6;dot.junit.opcodes.iget.d.T_iget_8 ;iget;Verifier #6; Constraint n/a, Attempt to read undefined field.
dot.junit.opcodes.iget.Main_testVFE7;dot.junit.opcodes.iget.d.T_iget_1 dot.junit.opcodes.iget.d.T_iget_12 ;iget;Verifier #7; Constraint n/a, Attempt to read superclass' private field from subclass.
dot.junit.opcodes.iget.Main_testVFE8;dot.junit.opcodes.iget.d.T_iget_14 ;iget;Verifier #8; Constraint B1, iget shall not work for reference fields
dot.junit.opcodes.iget.Main_testVFE9;dot.junit.opcodes.iget.d.T_iget_15 ;iget;Verifier #9; Constraint B1, iget shall not work for short fields
dot.junit.opcodes.iget_wide.Main_testE2;dot.junit.opcodes.iget_wide.d.T_iget_wide_9 ;iget-wide;Exception #2;Expected NullPointerException
dot.junit.opcodes.iget_wide.Main_testN1;dot.junit.opcodes.iget_wide.d.T_iget_wide_1 ;iget-wide;Normal #1;Type - long
dot.junit.opcodes.iget_wide.Main_testN2;dot.junit.opcodes.iget_wide.d.T_iget_wide_2 ;iget-wide;Normal #2;Type - double
dot.junit.opcodes.iget_wide.Main_testN3;dot.junit.opcodes.iget_wide.d.T_iget_wide_1 dot.junit.opcodes.iget_wide.d.T_iget_wide_11 ;iget-wide;Normal #3;Access protected field from subclass
dot.junit.opcodes.iget_wide.Main_testVFE1;dot.junit.opcodes.iget_wide.d.T_iget_wide_4 ;iget-wide;Verifier #1; Constraint A11, constant pool index
dot.junit.opcodes.iget_wide.Main_testVFE10;dot.junit.opcodes.iget_wide.d.T_iget_wide_16 ;iget-wide;Verifier #10; Constraint B1, iget-wide shall not work for boolean fields
dot.junit.opcodes.iget_wide.Main_testVFE11;dot.junit.opcodes.iget_wide.d.T_iget_wide_17 ;iget-wide;Verifier #11; Constraint B1, iget-wide shall not work for char fields
dot.junit.opcodes.iget_wide.Main_testVFE12;dot.junit.opcodes.iget_wide.d.T_iget_wide_18 ;iget-wide;Verifier #12; Constraint B1, iget-wide shall not work for byte fields
dot.junit.opcodes.iget_wide.Main_testVFE13;dot.junit.opcodes.iget_wide.d.T_iget_wide_19 ;iget-wide;Verifier #13; Constraint B1, iget-wide shall not work for float fields
dot.junit.opcodes.iget_wide.Main_testVFE14;dot.junit.opcodes.iget_wide.d.T_iget_wide_20 ;iget-wide;Verifier #14; Constraint B1, iget-wide shall not work for int fields
dot.junit.opcodes.iget_wide.Main_testVFE15;dot.junit.opcodes.iget_wide.d.T_iget_wide_21 dot.junit.opcodes.iget_wide.TestStubs ;iget-wide;Verifier #15; Constraint B12, Attempt to read inaccessible protected field.
dot.junit.opcodes.iget_wide.Main_testVFE16;dot.junit.opcodes.iget_wide.d.T_iget_wide_5 dot.junit.opcodes.iget_wide.TestStubs ;iget-wide;Verifier #16; Constraint A11, Attempt to read static  field.
dot.junit.opcodes.iget_wide.Main_testVFE2;dot.junit.opcodes.iget_wide.d.T_iget_wide_3 ;iget-wide;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.iget_wide.Main_testVFE3;dot.junit.opcodes.iget_wide.d.T_iget_wide_13 ;iget-wide;Verifier #3; Constraint B13, read long from integer field - only field with same name but  different type exists
dot.junit.opcodes.iget_wide.Main_testVFE30;dot.junit.opcodes.iget_wide.d.T_iget_wide_30 ;iget-wide;Verifier #30; Constraint B6, instance fields may only be accessed on already initialized instances.
dot.junit.opcodes.iget_wide.Main_testVFE4;dot.junit.opcodes.iget_wide.d.T_iget_wide_6 dot.junit.opcodes.iget_wide.TestStubs ;iget-wide;Verifier #4; Constraint n/a, Attempt to read inaccessible field.
dot.junit.opcodes.iget_wide.Main_testVFE5;dot.junit.opcodes.iget_wide.d.T_iget_wide_7 ;iget-wide;Verifier #5; Constraint n/a, Attempt to read field of undefined class.
dot.junit.opcodes.iget_wide.Main_testVFE6;dot.junit.opcodes.iget_wide.d.T_iget_wide_8 ;iget-wide;Verifier #6; Constraint n/a, Attempt to read undefined field.
dot.junit.opcodes.iget_wide.Main_testVFE7;dot.junit.opcodes.iget_wide.d.T_iget_wide_1 dot.junit.opcodes.iget_wide.d.T_iget_wide_12 ;iget-wide;Verifier #7; Constraint n/a, Attempt to read superclass' private field from subclass.
dot.junit.opcodes.iget_wide.Main_testVFE8;dot.junit.opcodes.iget_wide.d.T_iget_wide_14 ;iget-wide;Verifier #8; Constraint B1, iget-wide shall not work for reference fields
dot.junit.opcodes.iget_wide.Main_testVFE9;dot.junit.opcodes.iget_wide.d.T_iget_wide_15 ;iget-wide;Verifier #9; Constraint B1, iget-wide shall not work for short fields
dot.junit.opcodes.instance_of.Main_testE1;dot.junit.opcodes.instance_of.d.T_instance_of_1 ;instance-of;Exception #1;T_instance_of_1 instanceof String
dot.junit.opcodes.instance_of.Main_testE2;dot.junit.opcodes.instance_of.d.T_instance_of_3 dot.junit.opcodes.instance_of.TestStubs ;instance-of;Exception #2;Attempt to access inaccessible class.
dot.junit.opcodes.instance_of.Main_testE3;dot.junit.opcodes.instance_of.d.T_instance_of_7 ;instance-of;Exception #3;Attempt to access undefined class.
dot.junit.opcodes.instance_of.Main_testN1;dot.junit.opcodes.instance_of.d.T_instance_of_1 ;instance-of;Normal #1;(Object)String instanceof String
dot.junit.opcodes.instance_of.Main_testN2;dot.junit.opcodes.instance_of.d.T_instance_of_1 ;instance-of;Normal #2;Null instanceof String
dot.junit.opcodes.instance_of.Main_testN4;dot.junit.opcodes.instance_of.d.T_instance_of_2 ;instance-of;Normal #4;Check assignment compatibility rules
dot.junit.opcodes.instance_of.Main_testVFE1;dot.junit.opcodes.instance_of.d.T_instance_of_4 ;instance-of;Verifier #1; Constraint A19, constant pool index
dot.junit.opcodes.instance_of.Main_testVFE2;dot.junit.opcodes.instance_of.d.T_instance_of_5 ;instance-of;Verifier #2; Constraint B1, type of argument - int
dot.junit.opcodes.instance_of.Main_testVFE3;dot.junit.opcodes.instance_of.d.T_instance_of_8 ;instance-of;Verifier #3; Constraint B1, type of argument - long
dot.junit.opcodes.instance_of.Main_testVFE4;dot.junit.opcodes.instance_of.d.T_instance_of_6 ;instance-of;Verifier #4; Constraint B1, number of registers
dot.junit.opcodes.int_to_byte.Main_testB1;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_1 ;int-to-byte;Boundary #1;Argument = 127
dot.junit.opcodes.int_to_byte.Main_testB2;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_1 ;int-to-byte;Boundary #2;Argument = 128
dot.junit.opcodes.int_to_byte.Main_testB3;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_1 ;int-to-byte;Boundary #3;Argument = 0
dot.junit.opcodes.int_to_byte.Main_testB4;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_1 ;int-to-byte;Boundary #4;Argument = -128
dot.junit.opcodes.int_to_byte.Main_testB5;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_1 ;int-to-byte;Boundary #5;Argument = -129
dot.junit.opcodes.int_to_byte.Main_testB6;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_1 ;int-to-byte;Boundary #6;Argument = Integer.MAX_VALUE
dot.junit.opcodes.int_to_byte.Main_testB7;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_1 ;int-to-byte;Boundary #7;Argument = Integer.MIN_VALUE
dot.junit.opcodes.int_to_byte.Main_testN1;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_1 ;int-to-byte;Normal #1;Argument = 1
dot.junit.opcodes.int_to_byte.Main_testN2;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_1 ;int-to-byte;Normal #2;Argument = -1
dot.junit.opcodes.int_to_byte.Main_testN3;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_1 ;int-to-byte;Normal #3;Argument = 16
dot.junit.opcodes.int_to_byte.Main_testN4;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_1 ;int-to-byte;Normal #4;Argument = -32
dot.junit.opcodes.int_to_byte.Main_testN5;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_1 ;int-to-byte;Normal #5;Argument = 134
dot.junit.opcodes.int_to_byte.Main_testN6;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_1 ;int-to-byte;Normal #6;Argument = -134
dot.junit.opcodes.int_to_byte.Main_testN7;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_5 ;int-to-byte;Normal #7;Type of argument - float. Dalvik doens't distinguish 32-bits types internally, so this conversion of float to byte makes no sense but shall not crash the VM.
dot.junit.opcodes.int_to_byte.Main_testVFE1;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_2 ;int-to-byte;Verifier #1; Constraint B1, type of argument - double
dot.junit.opcodes.int_to_byte.Main_testVFE2;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_3 ;int-to-byte;Verifier #2; Constraint B1, type of argument - long
dot.junit.opcodes.int_to_byte.Main_testVFE3;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_4 ;int-to-byte;Verifier #3; Constraint B1, type of argument - reference
dot.junit.opcodes.int_to_byte.Main_testVFE4;dot.junit.opcodes.int_to_byte.d.T_int_to_byte_6 ;int-to-byte;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.int_to_char.Main_testB1;dot.junit.opcodes.int_to_char.d.T_int_to_char_1 ;int-to-char;Boundary #1;Argument = 0
dot.junit.opcodes.int_to_char.Main_testB2;dot.junit.opcodes.int_to_char.d.T_int_to_char_1 ;int-to-char;Boundary #2;Argument = 65535
dot.junit.opcodes.int_to_char.Main_testB3;dot.junit.opcodes.int_to_char.d.T_int_to_char_1 ;int-to-char;Boundary #3;Argument = Integer.MAX_VALUE
dot.junit.opcodes.int_to_char.Main_testB4;dot.junit.opcodes.int_to_char.d.T_int_to_char_1 ;int-to-char;Boundary #4;Argument = Integer.MIN_VALUE
dot.junit.opcodes.int_to_char.Main_testN1;dot.junit.opcodes.int_to_char.d.T_int_to_char_1 ;int-to-char;Normal #1;Argument = 65
dot.junit.opcodes.int_to_char.Main_testN2;dot.junit.opcodes.int_to_char.d.T_int_to_char_1 ;int-to-char;Normal #2;Argument = 65537
dot.junit.opcodes.int_to_char.Main_testN3;dot.junit.opcodes.int_to_char.d.T_int_to_char_1 ;int-to-char;Normal #3;Argument = -2
dot.junit.opcodes.int_to_char.Main_testN4;dot.junit.opcodes.int_to_char.d.T_int_to_char_1 ;int-to-char;Normal #4;Argument = 0x110000
dot.junit.opcodes.int_to_char.Main_testN5;dot.junit.opcodes.int_to_char.d.T_int_to_char_5 ;int-to-char;Normal #5;Type of argument - float. Dalvik doens't distinguish 32-bits types internally, so this conversion of float to char makes no sense but shall not crash the VM.
dot.junit.opcodes.int_to_char.Main_testVFE2;dot.junit.opcodes.int_to_char.d.T_int_to_char_2 ;int-to-char;Verifier #2; Constraint B1, type of argument - double
dot.junit.opcodes.int_to_char.Main_testVFE3;dot.junit.opcodes.int_to_char.d.T_int_to_char_3 ;int-to-char;Verifier #3; Constraint B1, type of argument - long
dot.junit.opcodes.int_to_char.Main_testVFE4;dot.junit.opcodes.int_to_char.d.T_int_to_char_4 ;int-to-char;Verifier #4; Constraint B1, type of argument - reference
dot.junit.opcodes.int_to_char.Main_testVFE5;dot.junit.opcodes.int_to_char.d.T_int_to_char_6 ;int-to-char;Verifier #5; Constraint A23, number of registers
dot.junit.opcodes.int_to_double.Main_testB1;dot.junit.opcodes.int_to_double.d.T_int_to_double_1 ;int-to-double;Boundary #1;Argument = Integer.MAX_VALUE
dot.junit.opcodes.int_to_double.Main_testB2;dot.junit.opcodes.int_to_double.d.T_int_to_double_1 ;int-to-double;Boundary #2;Argument = Integer.MIN_VALUE
dot.junit.opcodes.int_to_double.Main_testB3;dot.junit.opcodes.int_to_double.d.T_int_to_double_1 ;int-to-double;Boundary #3;Argument = 0
dot.junit.opcodes.int_to_double.Main_testN1;dot.junit.opcodes.int_to_double.d.T_int_to_double_1 ;int-to-double;Normal #1;Argument = 300000000
dot.junit.opcodes.int_to_double.Main_testN2;dot.junit.opcodes.int_to_double.d.T_int_to_double_1 ;int-to-double;Normal #2;Argument = 1
dot.junit.opcodes.int_to_double.Main_testN3;dot.junit.opcodes.int_to_double.d.T_int_to_double_1 ;int-to-double;Normal #3;Argument = -1
dot.junit.opcodes.int_to_double.Main_testN8;dot.junit.opcodes.int_to_double.d.T_int_to_double_6 ;int-to-double;Normal #8;Type of argument - float. Dalvik doens't distinguish 32-bits types internally, so this conversion of float to double makes no sense but shall not crash the VM.
dot.junit.opcodes.int_to_double.Main_testVFE1;dot.junit.opcodes.int_to_double.d.T_int_to_double_3 ;int-to-double;Verifier #1; Constraint B1, type of argument - long
dot.junit.opcodes.int_to_double.Main_testVFE2;dot.junit.opcodes.int_to_double.d.T_int_to_double_4 ;int-to-double;Verifier #2; Constraint A24, number of registers
dot.junit.opcodes.int_to_double.Main_testVFE3;dot.junit.opcodes.int_to_double.d.T_int_to_double_5 ;int-to-double;Verifier #3; Constraint B1, type of argument - reference
dot.junit.opcodes.int_to_double.Main_testVFE4;dot.junit.opcodes.int_to_double.d.T_int_to_double_7 ;int-to-double;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.int_to_float.Main_testB1;dot.junit.opcodes.int_to_float.d.T_int_to_float_1 ;int-to-float;Boundary #1;Argument = 0
dot.junit.opcodes.int_to_float.Main_testB2;dot.junit.opcodes.int_to_float.d.T_int_to_float_1 ;int-to-float;Boundary #2;Argument = Argument = Integer.MAX_VALUE
dot.junit.opcodes.int_to_float.Main_testB3;dot.junit.opcodes.int_to_float.d.T_int_to_float_1 ;int-to-float;Boundary #3;Argument = Integer.MIN_VALUE
dot.junit.opcodes.int_to_float.Main_testN1;dot.junit.opcodes.int_to_float.d.T_int_to_float_1 ;int-to-float;Normal #1;Argument = 123456
dot.junit.opcodes.int_to_float.Main_testN2;dot.junit.opcodes.int_to_float.d.T_int_to_float_1 ;int-to-float;Normal #2;Argument = 1
dot.junit.opcodes.int_to_float.Main_testN3;dot.junit.opcodes.int_to_float.d.T_int_to_float_1 ;int-to-float;Normal #3;Argument = -1
dot.junit.opcodes.int_to_float.Main_testN4;dot.junit.opcodes.int_to_float.d.T_int_to_float_1 ;int-to-float;Normal #4;Argument = 33564439
dot.junit.opcodes.int_to_float.Main_testN5;dot.junit.opcodes.int_to_float.d.T_int_to_float_5 ;int-to-float;Normal #5;Type of argument - float. Dalvik doens't distinguish 32-bits types internally, so this conversion of float to float makes no sense but shall not crash the VM.
dot.junit.opcodes.int_to_float.Main_testVFE1;dot.junit.opcodes.int_to_float.d.T_int_to_float_2 ;int-to-float;Verifier #1; Constraint B1, (type of argument - double)
dot.junit.opcodes.int_to_float.Main_testVFE2;dot.junit.opcodes.int_to_float.d.T_int_to_float_3 ;int-to-float;Verifier #2; Constraint B1, type of argument - long
dot.junit.opcodes.int_to_float.Main_testVFE3;dot.junit.opcodes.int_to_float.d.T_int_to_float_4 ;int-to-float;Verifier #3; Constraint B1, type of argument - reference
dot.junit.opcodes.int_to_float.Main_testVFE4;dot.junit.opcodes.int_to_float.d.T_int_to_float_6 ;int-to-float;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.int_to_long.Main_testB1;dot.junit.opcodes.int_to_long.d.T_int_to_long_1 ;int-to-long;Boundary #1;Argument = 0
dot.junit.opcodes.int_to_long.Main_testB2;dot.junit.opcodes.int_to_long.d.T_int_to_long_1 ;int-to-long;Boundary #2;Argument = Integer.MAX_VALUE
dot.junit.opcodes.int_to_long.Main_testB3;dot.junit.opcodes.int_to_long.d.T_int_to_long_1 ;int-to-long;Boundary #3;Argument = Integer.MIN_VALUE
dot.junit.opcodes.int_to_long.Main_testN1;dot.junit.opcodes.int_to_long.d.T_int_to_long_1 ;int-to-long;Normal #1;Argument = 123456
dot.junit.opcodes.int_to_long.Main_testN2;dot.junit.opcodes.int_to_long.d.T_int_to_long_1 ;int-to-long;Normal #2;Argument = 1
dot.junit.opcodes.int_to_long.Main_testN3;dot.junit.opcodes.int_to_long.d.T_int_to_long_1 ;int-to-long;Normal #3;Argument = -1
dot.junit.opcodes.int_to_long.Main_testN8;dot.junit.opcodes.int_to_long.d.T_int_to_long_6 ;int-to-long;Normal #8;Type of argument - float. Dalvik doens't distinguish 32-bits types internally, so this conversion of float to long makes no sense but shall not crash the VM.
dot.junit.opcodes.int_to_long.Main_testVFE1;dot.junit.opcodes.int_to_long.d.T_int_to_long_2 ;int-to-long;Verifier #1; Constraint B1, type of argument - double
dot.junit.opcodes.int_to_long.Main_testVFE2;dot.junit.opcodes.int_to_long.d.T_int_to_long_3 ;int-to-long;Verifier #2; Constraint B1, type of argument - long
dot.junit.opcodes.int_to_long.Main_testVFE3;dot.junit.opcodes.int_to_long.d.T_int_to_long_4 ;int-to-long;Verifier #3; Constraint A24, number of registers
dot.junit.opcodes.int_to_long.Main_testVFE4;dot.junit.opcodes.int_to_long.d.T_int_to_long_5 ;int-to-long;Verifier #4; Constraint B1, type of argument - reference
dot.junit.opcodes.int_to_long.Main_testVFE5;dot.junit.opcodes.int_to_long.d.T_int_to_long_7 ;int-to-long;Verifier #5; Constraint A23, number of registers
dot.junit.opcodes.int_to_short.Main_testB1;dot.junit.opcodes.int_to_short.d.T_int_to_short_1 ;int-to-short;Boundary #1;Argument = 0
dot.junit.opcodes.int_to_short.Main_testB2;dot.junit.opcodes.int_to_short.d.T_int_to_short_1 ;int-to-short;Boundary #2;Argument = Integer.MAX_VALUE
dot.junit.opcodes.int_to_short.Main_testB3;dot.junit.opcodes.int_to_short.d.T_int_to_short_1 ;int-to-short;Boundary #3;Argument = Integer.MIN_VALUE
dot.junit.opcodes.int_to_short.Main_testN1;dot.junit.opcodes.int_to_short.d.T_int_to_short_1 ;int-to-short;Normal #1;Argument = 1
dot.junit.opcodes.int_to_short.Main_testN2;dot.junit.opcodes.int_to_short.d.T_int_to_short_1 ;int-to-short;Normal #2;Argument = -1
dot.junit.opcodes.int_to_short.Main_testN3;dot.junit.opcodes.int_to_short.d.T_int_to_short_1 ;int-to-short;Normal #3;Argument = 32767
dot.junit.opcodes.int_to_short.Main_testN4;dot.junit.opcodes.int_to_short.d.T_int_to_short_1 ;int-to-short;Normal #4;Argument = -32768
dot.junit.opcodes.int_to_short.Main_testN5;dot.junit.opcodes.int_to_short.d.T_int_to_short_1 ;int-to-short;Normal #5;Argument = -32769
dot.junit.opcodes.int_to_short.Main_testN6;dot.junit.opcodes.int_to_short.d.T_int_to_short_1 ;int-to-short;Normal #6;Argument = 32768
dot.junit.opcodes.int_to_short.Main_testN7;dot.junit.opcodes.int_to_short.d.T_int_to_short_1 ;int-to-short;Normal #7;Argument = 0x10fedc;
dot.junit.opcodes.int_to_short.Main_testN8;dot.junit.opcodes.int_to_short.d.T_int_to_short_5 ;int-to-short;Normal #8;Type of argument - float. Dalvik doens't distinguish 32-bits types internally, so this conversion of float to short makes no sense but shall not crash the VM.
dot.junit.opcodes.int_to_short.Main_testVFE1;dot.junit.opcodes.int_to_short.d.T_int_to_short_2 ;int-to-short;Verifier #1; Constraint B1, type of argument - double
dot.junit.opcodes.int_to_short.Main_testVFE2;dot.junit.opcodes.int_to_short.d.T_int_to_short_3 ;int-to-short;Verifier #2; Constraint B1, type of argument - long
dot.junit.opcodes.int_to_short.Main_testVFE3;dot.junit.opcodes.int_to_short.d.T_int_to_short_4 ;int-to-short;Verifier #3; Constraint B1, type of argument - reference
dot.junit.opcodes.int_to_short.Main_testVFE4;dot.junit.opcodes.int_to_short.d.T_int_to_short_6 ;int-to-short;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.invoke_direct_range.Main_testE3;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_8 ;invoke-direct/range;Exception #3;Objref is null
dot.junit.opcodes.invoke_direct_range.Main_testE5;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_9 ;invoke-direct/range;Exception #5;Native method can't be linked
dot.junit.opcodes.invoke_direct_range.Main_testN2;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_2 ;invoke-direct/range;Normal #2;Private method call
dot.junit.opcodes.invoke_direct_range.Main_testN7;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_21 ;invoke-direct/range;Normal #7;Check that new frame is created by invoke_direct_range
dot.junit.opcodes.invoke_direct_range.Main_testVFE1;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_3 ;invoke-direct/range;Verifier #1; Constraint A14, invalid constant pool index
dot.junit.opcodes.invoke_direct_range.Main_testVFE10;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_25 dot.junit.opcodes.invoke_direct_range.TSuper dot.junit.opcodes.invoke_direct_range.TPlain ;invoke-direct/range;Verifier #10; Constraint B10, assignment incompatible references when accessing protected method
dot.junit.opcodes.invoke_direct_range.Main_testVFE11;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_25 dot.junit.opcodes.invoke_direct_range.TSuper ;invoke-direct/range;Verifier #11; Constraint B5, Superclass' method call
dot.junit.opcodes.invoke_direct_range.Main_testVFE12;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_15 ;invoke-direct/range;Verifier #12; Constraint A23, number of registers
dot.junit.opcodes.invoke_direct_range.Main_testVFE13;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_7 ;invoke-direct/range;Verifier #13; Constraint n/a, Attempt to call undefined method.
dot.junit.opcodes.invoke_direct_range.Main_testVFE14;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_16 ;invoke-direct/range;Verifier #14; Constraint n/a, Method has different signature.
dot.junit.opcodes.invoke_direct_range.Main_testVFE15;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_11 ;invoke-direct/range;Verifier #15; Constraint n/a, Attempt to invoke static method. Java throws IncompatibleClassChangeError on first access but Dalvik throws VerifyError on class loading.
dot.junit.opcodes.invoke_direct_range.Main_testVFE16;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_12 dot.junit.opcodes.invoke_direct_range.TSuper ;invoke-direct/range;Verifier #16; Constraint n/a, Attempt to invoke private method of superclass. Java throws IllegalAccessError on first access but Dalvik throws VerifyError on class loading.
dot.junit.opcodes.invoke_direct_range.Main_testVFE17;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_13 dot.junit.opcodes.invoke_direct_range.TAbstract ;invoke-direct/range;Verifier #17; Constraint n/a, Attempt to invoke abstract method
dot.junit.opcodes.invoke_direct_range.Main_testVFE18;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_17 ;invoke-direct/range;Verifier #18; Constraint B5, An instance initializer must only be invoked on an uninitialized instance.
dot.junit.opcodes.invoke_direct_range.Main_testVFE19;dot.junit.opcodes.invoke_direct_range.TSuper dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_18 ;invoke-direct/range;Verifier #19; Constraint B8, attempt to access inherited instance field before <init> is called
dot.junit.opcodes.invoke_direct_range.Main_testVFE20;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_26 ;invoke-direct/range;Verifier #20; Constraint A14, attempt to invoke interface method
dot.junit.opcodes.invoke_direct_range.Main_testVFE21;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_27 ;invoke-direct/range;Verifier #21; Constraint B6, instance methods may only be invoked on already initialized instances.
dot.junit.opcodes.invoke_direct_range.Main_testVFE3;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_4 ;invoke-direct/range;Verifier #3; Constraint A15, invoke-direct may not be used to invoke &lt;clinit&gt;
dot.junit.opcodes.invoke_direct_range.Main_testVFE4;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_6 dot.junit.opcodes.invoke_direct_range.TSuper ;invoke-direct/range;Verifier #4; Constraint B4, invoke-direct target must be in self or superclass
dot.junit.opcodes.invoke_direct_range.Main_testVFE5;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_5 ;invoke-direct/range;Verifier #5; Constraint B1, number of arguments
dot.junit.opcodes.invoke_direct_range.Main_testVFE6;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_10 ;invoke-direct/range;Verifier #6; Constraint B1, int is passed instead of obj ref
dot.junit.opcodes.invoke_direct_range.Main_testVFE8;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_14 ;invoke-direct/range;Verifier #8; Constraint B9, number of arguments passed to method
dot.junit.opcodes.invoke_direct_range.Main_testVFE9;dot.junit.opcodes.invoke_direct_range.d.T_invoke_direct_range_24 ;invoke-direct/range;Verifier #9; Constraint B9, types of arguments passed to method
dot.junit.opcodes.invoke_direct.Main_testE3;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_8 ;invoke-direct;Exception #3;Objref is null
dot.junit.opcodes.invoke_direct.Main_testE5;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_9 ;invoke-direct;Exception #5;Native method can't be linked
dot.junit.opcodes.invoke_direct.Main_testN2;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_2 ;invoke-direct;Normal #2;Private method call
dot.junit.opcodes.invoke_direct.Main_testN7;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_21 ;invoke-direct;Normal #7;Check that new frame is created by invoke_direct
dot.junit.opcodes.invoke_direct.Main_testVFE1;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_3 ;invoke-direct;Verifier #1; Constraint A13, invalid constant pool index
dot.junit.opcodes.invoke_direct.Main_testVFE10;dot.junit.opcodes.invoke_direct.TPlain dot.junit.opcodes.invoke_direct.d.T_invoke_direct_25 dot.junit.opcodes.invoke_direct.TSuper ;invoke-direct;Verifier #10; Constraint B10, assignment incompatible references when accessing protected method
dot.junit.opcodes.invoke_direct.Main_testVFE11;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_25 dot.junit.opcodes.invoke_direct.TSuper ;invoke-direct;Verifier #11; Constraint B5, Superclass' method call
dot.junit.opcodes.invoke_direct.Main_testVFE12;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_15 ;invoke-direct;Verifier #12; Constraint A23, number of registers
dot.junit.opcodes.invoke_direct.Main_testVFE13;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_7 ;invoke-direct;Verifier #13; Constraint n/a, Attempt to call undefined method.
dot.junit.opcodes.invoke_direct.Main_testVFE14;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_16 ;invoke-direct;Verifier #14; Constraint n/a, Method has different signature.
dot.junit.opcodes.invoke_direct.Main_testVFE15;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_11 ;invoke-direct;Verifier #15; Constraint n/a, Attempt to invoke static method. Java throws IncompatibleClassChangeError on first access but Dalvik throws VerifyError on class loading.
dot.junit.opcodes.invoke_direct.Main_testVFE16;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_12 dot.junit.opcodes.invoke_direct.TSuper ;invoke-direct;Verifier #16; Constraint n/a, Attempt to invoke private method of superclass.
dot.junit.opcodes.invoke_direct.Main_testVFE17;dot.junit.opcodes.invoke_direct.TAbstract dot.junit.opcodes.invoke_direct.d.T_invoke_direct_13 ;invoke-direct;Verifier #17; Constraint n/a, Attempt to invoke abstract method
dot.junit.opcodes.invoke_direct.Main_testVFE18;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_17 ;invoke-direct;Verifier #18; Constraint B5, An instance initializer must only be invoked on an uninitialized instance.
dot.junit.opcodes.invoke_direct.Main_testVFE19;dot.junit.opcodes.invoke_direct.TSuper dot.junit.opcodes.invoke_direct.d.T_invoke_direct_18 ;invoke-direct;Verifier #19; Constraint B8, attempt to access inherited instance field before <init> is called
dot.junit.opcodes.invoke_direct.Main_testVFE20;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_26 ;invoke-direct;Verifier #20; Constraint A13, attempt to invoke interface method
dot.junit.opcodes.invoke_direct.Main_testVFE21;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_27 ;invoke-direct;Verifier #21; Constraint B6, instance methods may only be invoked on already initialized instances.
dot.junit.opcodes.invoke_direct.Main_testVFE3;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_4 ;invoke-direct;Verifier #3; Constraint A15, invoke-direct may not be used to invoke &lt;clinit&gt;
dot.junit.opcodes.invoke_direct.Main_testVFE4;dot.junit.opcodes.invoke_direct.TSuper dot.junit.opcodes.invoke_direct.d.T_invoke_direct_6 ;invoke-direct;Verifier #4; Constraint B4, invoke-direct target must be in self or superclass
dot.junit.opcodes.invoke_direct.Main_testVFE5;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_5 ;invoke-direct;Verifier #5; Constraint B1, number of arguments
dot.junit.opcodes.invoke_direct.Main_testVFE6;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_10 ;invoke-direct;Verifier #6; Constraint B1, int is passed instead of obj ref
dot.junit.opcodes.invoke_direct.Main_testVFE8;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_14 ;invoke-direct;Verifier #8; Constraint B9, number of arguments passed to method
dot.junit.opcodes.invoke_direct.Main_testVFE9;dot.junit.opcodes.invoke_direct.d.T_invoke_direct_24 ;invoke-direct;Verifier #9; Constraint B9, types of arguments passed to method
dot.junit.opcodes.invoke_interface_range.Main_testE3;dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_3 dot.junit.opcodes.invoke_interface_range.ITest ;invoke-interface/range;Exception #3;Objref is null
dot.junit.opcodes.invoke_interface_range.Main_testE4;dot.junit.opcodes.invoke_interface_range.ITestImpl dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_11 dot.junit.opcodes.invoke_interface_range.ITest ;invoke-interface/range;Exception #4;Object doesn't implement interface
dot.junit.opcodes.invoke_interface_range.Main_testE5;dot.junit.opcodes.invoke_interface_range.ITestImpl dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_12 dot.junit.opcodes.invoke_interface_range.ITest ;invoke-interface/range;Exception #5;Native method can't be linked
dot.junit.opcodes.invoke_interface_range.Main_testE6;dot.junit.opcodes.invoke_interface_range.ITestImplAbstract dot.junit.opcodes.invoke_interface_range.ITestImpl dot.junit.opcodes.invoke_interface_range.ITest dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_13 ;invoke-interface/range;Exception #6;Attempt to invoke abstract method
dot.junit.opcodes.invoke_interface_range.Main_testN1;dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_1 ;invoke-interface/range;Normal #1;Invoke interface method
dot.junit.opcodes.invoke_interface_range.Main_testN2;dot.junit.opcodes.invoke_interface_range.ITestImpl dot.junit.opcodes.invoke_interface_range.ITest dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_14 ;invoke-interface/range;Normal #2;Check that new frame is created by invoke_interface_range and arguments are passed to method
dot.junit.opcodes.invoke_interface_range.Main_testVFE1;dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_2 ;invoke-interface/range;Verifier #1; Constraint A17, invalid constant pool index
dot.junit.opcodes.invoke_interface_range.Main_testVFE10;dot.junit.opcodes.invoke_interface_range.ITestImplAbstract dot.junit.opcodes.invoke_interface_range.ITestImpl dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_18 dot.junit.opcodes.invoke_interface_range.ITest ;invoke-interface/range;Verifier #10; Constraint A15, invoke-interface may not be used to call <init>.
dot.junit.opcodes.invoke_interface_range.Main_testVFE11;dot.junit.opcodes.invoke_interface_range.ITestImpl dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_20 dot.junit.opcodes.invoke_interface_range.ITest ;invoke-interface/range;Verifier #11; Constraint A15, invoke-interface may not be used to call <clinit>.
dot.junit.opcodes.invoke_interface_range.Main_testVFE12;dot.junit.opcodes.invoke_interface_range.ITestImpl dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_21 dot.junit.opcodes.invoke_interface_range.ITest ;invoke-interface/range;Verifier #12; Constraint B9, types of arguments passed to method
dot.junit.opcodes.invoke_interface_range.Main_testVFE13;dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_8 ;invoke-interface/range;Verifier #13; Constraint A23, number of registers
dot.junit.opcodes.invoke_interface_range.Main_testVFE14;dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_7 dot.junit.opcodes.invoke_interface_range.ITestImpl dot.junit.opcodes.invoke_interface_range.ITest ;invoke-interface/range;Verifier #14; Constraint n/a, Attempt to call undefined method.
dot.junit.opcodes.invoke_interface_range.Main_testVFE15;dot.junit.opcodes.invoke_interface_range.ITestImpl dot.junit.opcodes.invoke_interface_range.ITest dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_16 ;invoke-interface/range;Verifier #15; Constraint n/a, Method has different signature.
dot.junit.opcodes.invoke_interface_range.Main_testVFE2;dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_4 ;invoke-interface/range;Verifier #2; Constraint A17, The referenced method_id must belong to an interface (not a class).
dot.junit.opcodes.invoke_interface_range.Main_testVFE21;dot.junit.opcodes.invoke_interface_range.ITestImpl dot.junit.opcodes.invoke_interface_range.ITest dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_22 ;invoke-interface/range;Verifier #21; Constraint B6, instance methods may only be invoked on already initialized instances.
dot.junit.opcodes.invoke_interface_range.Main_testVFE5;dot.junit.opcodes.invoke_interface_range.ITestImpl dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_5 dot.junit.opcodes.invoke_interface_range.ITest ;invoke-interface/range;Verifier #5; Constraint B1, number of arguments
dot.junit.opcodes.invoke_interface_range.Main_testVFE6;dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_10 ;invoke-interface/range;Verifier #6; Constraint B1, int is passed instead of objref
dot.junit.opcodes.invoke_interface_range.Main_testVFE9;dot.junit.opcodes.invoke_interface_range.d.T_invoke_interface_range_9 ;invoke-interface/range;Verifier #9; Constraint B9, number of arguments passed to method
dot.junit.opcodes.invoke_interface.Main_testE3;dot.junit.opcodes.invoke_interface.ITest dot.junit.opcodes.invoke_interface.d.T_invoke_interface_3 ;invoke-interface;Exception #3;Objref is null
dot.junit.opcodes.invoke_interface.Main_testE4;dot.junit.opcodes.invoke_interface.ITestImpl dot.junit.opcodes.invoke_interface.ITest dot.junit.opcodes.invoke_interface.d.T_invoke_interface_11 ;invoke-interface;Exception #4;Object doesn't implement interface
dot.junit.opcodes.invoke_interface.Main_testE5;dot.junit.opcodes.invoke_interface.ITestImpl dot.junit.opcodes.invoke_interface.ITest dot.junit.opcodes.invoke_interface.d.T_invoke_interface_12 ;invoke-interface;Exception #5;Native method can't be linked
dot.junit.opcodes.invoke_interface.Main_testE6;dot.junit.opcodes.invoke_interface.d.T_invoke_interface_13 dot.junit.opcodes.invoke_interface.ITestImpl dot.junit.opcodes.invoke_interface.ITest dot.junit.opcodes.invoke_interface.ITestImplAbstract ;invoke-interface;Exception #6;Attempt to invoke abstract method
dot.junit.opcodes.invoke_interface.Main_testN1;dot.junit.opcodes.invoke_interface.d.T_invoke_interface_1 ;invoke-interface;Normal #1;Invoke interface method
dot.junit.opcodes.invoke_interface.Main_testN2;dot.junit.opcodes.invoke_interface.ITestImpl dot.junit.opcodes.invoke_interface.d.T_invoke_interface_14 dot.junit.opcodes.invoke_interface.ITest ;invoke-interface;Normal #2;Check that new frame is created by invoke_interface and arguments are passed to method
dot.junit.opcodes.invoke_interface.Main_testVFE1;dot.junit.opcodes.invoke_interface.d.T_invoke_interface_2 ;invoke-interface;Verifier #1; Constraint A16, invalid constant pool index
dot.junit.opcodes.invoke_interface.Main_testVFE10;dot.junit.opcodes.invoke_interface.ITestImpl dot.junit.opcodes.invoke_interface.ITest dot.junit.opcodes.invoke_interface.d.T_invoke_interface_18 dot.junit.opcodes.invoke_interface.ITestImplAbstract ;invoke-interface;Verifier #10; Constraint A15, invoke-interface may not be used to call <init>.
dot.junit.opcodes.invoke_interface.Main_testVFE11;dot.junit.opcodes.invoke_interface.ITestImpl dot.junit.opcodes.invoke_interface.ITest dot.junit.opcodes.invoke_interface.d.T_invoke_interface_20 ;invoke-interface;Verifier #11; Constraint A15, invoke-interface may not be used to call <clinit>.
dot.junit.opcodes.invoke_interface.Main_testVFE12;dot.junit.opcodes.invoke_interface.ITestImpl dot.junit.opcodes.invoke_interface.ITest dot.junit.opcodes.invoke_interface.d.T_invoke_interface_21 ;invoke-interface;Verifier #12; Constraint B9, types of arguments passed to method
dot.junit.opcodes.invoke_interface.Main_testVFE13;dot.junit.opcodes.invoke_interface.d.T_invoke_interface_8 ;invoke-interface;Verifier #13; Constraint A23, number of registers
dot.junit.opcodes.invoke_interface.Main_testVFE14;dot.junit.opcodes.invoke_interface.ITestImpl dot.junit.opcodes.invoke_interface.ITest dot.junit.opcodes.invoke_interface.d.T_invoke_interface_7 ;invoke-interface;Verifier #14; Constraint n/a, Attempt to call undefined method.
dot.junit.opcodes.invoke_interface.Main_testVFE15;dot.junit.opcodes.invoke_interface.ITestImpl dot.junit.opcodes.invoke_interface.d.T_invoke_interface_16 dot.junit.opcodes.invoke_interface.ITest ;invoke-interface;Verifier #15; Constraint n/a, Method has different signature.
dot.junit.opcodes.invoke_interface.Main_testVFE2;dot.junit.opcodes.invoke_interface.d.T_invoke_interface_4 ;invoke-interface;Verifier #2; Constraint A16, The referenced method_id must belong to an interface (not a class).
dot.junit.opcodes.invoke_interface.Main_testVFE21;dot.junit.opcodes.invoke_interface.ITestImpl dot.junit.opcodes.invoke_interface.d.T_invoke_interface_22 dot.junit.opcodes.invoke_interface.ITest ;invoke-interface;Verifier #21; Constraint B6, instance methods may only be invoked on already initialized instances.
dot.junit.opcodes.invoke_interface.Main_testVFE5;dot.junit.opcodes.invoke_interface.ITestImpl dot.junit.opcodes.invoke_interface.ITest dot.junit.opcodes.invoke_interface.d.T_invoke_interface_5 ;invoke-interface;Verifier #5; Constraint B1, number of arguments
dot.junit.opcodes.invoke_interface.Main_testVFE6;dot.junit.opcodes.invoke_interface.d.T_invoke_interface_10 ;invoke-interface;Verifier #6; Constraint B1, int is passed instead of objref
dot.junit.opcodes.invoke_interface.Main_testVFE9;dot.junit.opcodes.invoke_interface.d.T_invoke_interface_9 ;invoke-interface;Verifier #9; Constraint B9, number of arguments passed to method
dot.junit.opcodes.invoke_static_range.Main_testE2;dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_6 ;invoke-static/range;Exception #2;Native method can't be linked
dot.junit.opcodes.invoke_static_range.Main_testE7;dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_14 ;invoke-static/range;Exception #7;Initialization of referenced class throws exception
dot.junit.opcodes.invoke_static_range.Main_testN1;dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_1 ;invoke-static/range;Normal #1;Static method from library class Math
dot.junit.opcodes.invoke_static_range.Main_testN2;dot.junit.opcodes.invoke_static_range.TestClass dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_2 ;invoke-static/range;Normal #2;Static method from user class
dot.junit.opcodes.invoke_static_range.Main_testN3;dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_4 ;invoke-static/range;Normal #3;Big number of registers
dot.junit.opcodes.invoke_static_range.Main_testN5;dot.junit.opcodes.invoke_static_range.TestClass dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_15 ;invoke-static/range;Normal #5;Check that new frame is created by invoke_static_range and arguments are passed to method
dot.junit.opcodes.invoke_static_range.Main_testN6;dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_18 ;invoke-static/range;Normal #6;Static protected method from other class in the same package
dot.junit.opcodes.invoke_static_range.Main_testVFE1;dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_3 ;invoke-static/range;Verifier #1; Constraint A14, invalid constant pool index
dot.junit.opcodes.invoke_static_range.Main_testVFE10;dot.junit.opcodes.invoke_static_range.TestClass dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_13 ;invoke-static/range;Verifier #10; Constraint n/a, Method has different signature.
dot.junit.opcodes.invoke_static_range.Main_testVFE12;dot.junit.opcodes.invoke_static_range.TestClass dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_17 ;invoke-static/range;Verifier #12; Constraint B12, Attempt to call protected method of unrelated class.
dot.junit.opcodes.invoke_static_range.Main_testVFE13;dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_16 ;invoke-static/range;Verifier #13; Constraint A23, number of registers
dot.junit.opcodes.invoke_static_range.Main_testVFE18;dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_24 ;invoke-static/range;Verifier #18; Constraint A14, attempt to invoke interface method
dot.junit.opcodes.invoke_static_range.Main_testVFE3;dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_10 ;invoke-static/range;Verifier #3; Constraint A15, &lt;clinit&gt; may not be called using invoke_static_range
dot.junit.opcodes.invoke_static_range.Main_testVFE4;dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_11 ;invoke-static/range;Verifier #4; Constraint B1, number of arguments passed to method
dot.junit.opcodes.invoke_static_range.Main_testVFE5;dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_19 ;invoke-static/range;Verifier #5; Constraint A15, &lt;init&gt; may not be called using invoke_static_range
dot.junit.opcodes.invoke_static_range.Main_testVFE6;dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_20 ;invoke-static/range;Verifier #6; Constraint B9, types of arguments passed to method
dot.junit.opcodes.invoke_static_range.Main_testVFE7;dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_5 ;invoke-static/range;Verifier #7; Constraint n/a, Attempt to call non-static method.
dot.junit.opcodes.invoke_static_range.Main_testVFE8;dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_7 ;invoke-static/range;Verifier #8; Constraint n/a, Attempt to call undefined method.
dot.junit.opcodes.invoke_static_range.Main_testVFE9;dot.junit.opcodes.invoke_static_range.TestClass dot.junit.opcodes.invoke_static_range.d.T_invoke_static_range_8 ;invoke-static/range;Verifier #9; Constraint n/a, Attempt to call private method of other class.
dot.junit.opcodes.invoke_static.Main_testE2;dot.junit.opcodes.invoke_static.d.T_invoke_static_6 ;invoke-static;Exception #2;Native method can't be linked
dot.junit.opcodes.invoke_static.Main_testE7;dot.junit.opcodes.invoke_static.d.T_invoke_static_14 ;invoke-static;Exception #7;Initialization of referenced class throws exception
dot.junit.opcodes.invoke_static.Main_testN1;dot.junit.opcodes.invoke_static.d.T_invoke_static_1 ;invoke-static;Normal #1;Static method from library class Math
dot.junit.opcodes.invoke_static.Main_testN2;dot.junit.opcodes.invoke_static.TestClass dot.junit.opcodes.invoke_static.d.T_invoke_static_2 ;invoke-static;Normal #2;Static method from user class
dot.junit.opcodes.invoke_static.Main_testN3;dot.junit.opcodes.invoke_static.d.T_invoke_static_4 ;invoke-static;Normal #3;Check that <clinit> is called
dot.junit.opcodes.invoke_static.Main_testN5;dot.junit.opcodes.invoke_static.TestClass dot.junit.opcodes.invoke_static.d.T_invoke_static_15 ;invoke-static;Normal #5;Check that new frame is created by invoke_static and arguments are passed to method
dot.junit.opcodes.invoke_static.Main_testN6;dot.junit.opcodes.invoke_static.d.T_invoke_static_18 ;invoke-static;Normal #6;Static protected method from other class in the same package
dot.junit.opcodes.invoke_static.Main_testVFE1;dot.junit.opcodes.invoke_static.d.T_invoke_static_3 ;invoke-static;Verifier #1; Constraint A13, invalid constant pool index
dot.junit.opcodes.invoke_static.Main_testVFE10;dot.junit.opcodes.invoke_static.TestClass dot.junit.opcodes.invoke_static.d.T_invoke_static_13 ;invoke-static;Verifier #10; Constraint n/a, Method has different signature.
dot.junit.opcodes.invoke_static.Main_testVFE12;dot.junit.opcodes.invoke_static.TestClass dot.junit.opcodes.invoke_static.d.T_invoke_static_17 ;invoke-static;Verifier #12; Constraint B12, Attempt to call protected method of unrelated class.
dot.junit.opcodes.invoke_static.Main_testVFE13;dot.junit.opcodes.invoke_static.d.T_invoke_static_16 ;invoke-static;Verifier #13; Constraint A23, number of registers
dot.junit.opcodes.invoke_static.Main_testVFE18;dot.junit.opcodes.invoke_static.d.T_invoke_static_24 ;invoke-static;Verifier #18; Constraint A13, attempt to invoke interface method
dot.junit.opcodes.invoke_static.Main_testVFE3;dot.junit.opcodes.invoke_static.d.T_invoke_static_10 ;invoke-static;Verifier #3; Constraint A15, &lt;clinit&gt; may not be called using invoke-static
dot.junit.opcodes.invoke_static.Main_testVFE4;dot.junit.opcodes.invoke_static.d.T_invoke_static_11 ;invoke-static;Verifier #4; Constraint B1, number of arguments passed to method.
dot.junit.opcodes.invoke_static.Main_testVFE5;dot.junit.opcodes.invoke_static.d.T_invoke_static_19 ;invoke-static;Verifier #5; Constraint A15, &lt;init&gt; may not be called using invoke_static
dot.junit.opcodes.invoke_static.Main_testVFE6;dot.junit.opcodes.invoke_static.d.T_invoke_static_20 ;invoke-static;Verifier #6; Constraint B9, types of arguments passed to method
dot.junit.opcodes.invoke_static.Main_testVFE7;dot.junit.opcodes.invoke_static.d.T_invoke_static_5 ;invoke-static;Verifier #7; Constraint n/a, Attempt to call non-static method.
dot.junit.opcodes.invoke_static.Main_testVFE8;dot.junit.opcodes.invoke_static.d.T_invoke_static_7 ;invoke-static;Verifier #8; Constraint n/a, Attempt to call undefined method.
dot.junit.opcodes.invoke_static.Main_testVFE9;dot.junit.opcodes.invoke_static.TestClass dot.junit.opcodes.invoke_static.d.T_invoke_static_8 ;invoke-static;Verifier #9; Constraint n/a, Attempt to call private method of other class.
dot.junit.opcodes.invoke_super_range.Main_testE1;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_1 dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_2 dot.junit.opcodes.invoke_super_range.d.TSuper ;invoke-super/range;Exception #1;Obj ref is null
dot.junit.opcodes.invoke_super_range.Main_testE2;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_4 dot.junit.opcodes.invoke_super_range.d.TSuper ;invoke-super/range;Exception #2;Native method can't be linked
dot.junit.opcodes.invoke_super_range.Main_testE4;dot.junit.opcodes.invoke_super_range.ATest dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_6 ;invoke-super/range;Exception #4;Attempt to invoke abstract method
dot.junit.opcodes.invoke_super_range.Main_testN1;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_1 dot.junit.opcodes.invoke_super_range.d.TSuper ;invoke-super/range;Normal #1;Invoke method of superclass
dot.junit.opcodes.invoke_super_range.Main_testN3;dot.junit.opcodes.invoke_super_range.d.TSuper dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_7 ;invoke-super/range;Normal #3;Invoke protected method of superclass
dot.junit.opcodes.invoke_super_range.Main_testN5;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_14 dot.junit.opcodes.invoke_super_range.d.TSuper ;invoke-super/range;Normal #5;Check that new frame is created by invoke_super_range and arguments are passed to method
dot.junit.opcodes.invoke_super_range.Main_testN6;dot.junit.opcodes.invoke_super_range.d.TSuper dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_17 dot.junit.opcodes.invoke_super_range.d.TSuper2 ;invoke-super/range;Normal #6;Recursion of method lookup procedure
dot.junit.opcodes.invoke_super_range.Main_testVFE1;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_8 ;invoke-super/range;Verifier #1; Constraint A14, invalid constant pool index
dot.junit.opcodes.invoke_super_range.Main_testVFE10;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_5 dot.junit.opcodes.invoke_super_range.d.TSuper ;invoke-super/range;Verifier #10; Constraint n/a, Attempt to call static method.
dot.junit.opcodes.invoke_super_range.Main_testVFE12;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_15 ;invoke-super/range;Verifier #12; Constraint n/a, Attempt to invoke non-existing method.
dot.junit.opcodes.invoke_super_range.Main_testVFE13;dot.junit.opcodes.invoke_super_range.TestStubs dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_18 ;invoke-super/range;Verifier #13; Constraint n/a, Attempt to invoke private method of other class.
dot.junit.opcodes.invoke_super_range.Main_testVFE14;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_20 dot.junit.opcodes.invoke_super_range.TestStubs ;invoke-super/range;Verifier #14; Constraint B12, Attempt to invoke protected method of unrelated class.
dot.junit.opcodes.invoke_super_range.Main_testVFE15;dot.junit.opcodes.invoke_super_range.d.TSuper dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_19 ;invoke-super/range;Verifier #15; Constraint n/a, Method has different signature.
dot.junit.opcodes.invoke_super_range.Main_testVFE16;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_13 dot.junit.opcodes.invoke_super_range.d.TSuper ;invoke-super/range;Verifier #16; Constraint n/a, invoke-super/range shall be used to invoke private methods
dot.junit.opcodes.invoke_super_range.Main_testVFE17;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_9 ;invoke-super/range;Verifier #17; Constraint A23, number of registers
dot.junit.opcodes.invoke_super_range.Main_testVFE18;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_24 ;invoke-super/range;Verifier #18; Constraint A14, attempt to invoke interface method
dot.junit.opcodes.invoke_super_range.Main_testVFE19;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_25 dot.junit.opcodes.invoke_super_range.d.TSuper ;invoke-super/range;Verifier #19; Constraint B6, instance methods may only be invoked on already initialized instances.
dot.junit.opcodes.invoke_super_range.Main_testVFE3;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_10 ;invoke-super/range;Verifier #3; Constraint A15, &lt;clinit&gt; may not be called using invoke-super
dot.junit.opcodes.invoke_super_range.Main_testVFE4;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_11 ;invoke-super/range;Verifier #4; Constraint B1, number of arguments passed to method
dot.junit.opcodes.invoke_super_range.Main_testVFE5;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_12 dot.junit.opcodes.invoke_super_range.d.TSuper ;invoke-super/range;Verifier #5; Constraint B9, types of arguments passed to method.
dot.junit.opcodes.invoke_super_range.Main_testVFE6;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_16 ;invoke-super/range;Verifier #6; Constraint A15, &lt;init&gt; may not be called using invoke_super_range
dot.junit.opcodes.invoke_super_range.Main_testVFE8;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_22 dot.junit.opcodes.invoke_super_range.d.TPlain dot.junit.opcodes.invoke_super_range.d.TSuper ;invoke-super/range;Verifier #8; Constraint B10, assignment incompatible references when accessing                  protected method
dot.junit.opcodes.invoke_super_range.Main_testVFE9;dot.junit.opcodes.invoke_super_range.d.T_invoke_super_range_23 dot.junit.opcodes.invoke_super_range.d.TSuper dot.junit.opcodes.invoke_super_range.d.TSuper2 ;invoke-super/range;Verifier #9; Constraint B10, assignment incompatible references when accessing                  public method
dot.junit.opcodes.invoke_super.Main_testE1;dot.junit.opcodes.invoke_super.d.TSuper dot.junit.opcodes.invoke_super.d.T_invoke_super_1 dot.junit.opcodes.invoke_super.d.T_invoke_super_2 ;invoke-super;Exception #1;Obj ref is null
dot.junit.opcodes.invoke_super.Main_testE2;dot.junit.opcodes.invoke_super.d.TSuper dot.junit.opcodes.invoke_super.d.T_invoke_super_4 ;invoke-super;Exception #2;Native method can't be linked
dot.junit.opcodes.invoke_super.Main_testE4;dot.junit.opcodes.invoke_super.ATest dot.junit.opcodes.invoke_super.d.T_invoke_super_6 ;invoke-super;Exception #4;Attempt to invoke abstract method
dot.junit.opcodes.invoke_super.Main_testN1;dot.junit.opcodes.invoke_super.d.TSuper dot.junit.opcodes.invoke_super.d.T_invoke_super_1 ;invoke-super;Normal #1;Invoke method of superclass
dot.junit.opcodes.invoke_super.Main_testN3;dot.junit.opcodes.invoke_super.d.TSuper dot.junit.opcodes.invoke_super.d.T_invoke_super_7 ;invoke-super;Normal #3;Invoke protected method of superclass
dot.junit.opcodes.invoke_super.Main_testN5;dot.junit.opcodes.invoke_super.d.TSuper dot.junit.opcodes.invoke_super.d.T_invoke_super_14 ;invoke-super;Normal #5;Check that new frame is created by invoke_super and arguments are passed to method
dot.junit.opcodes.invoke_super.Main_testN6;dot.junit.opcodes.invoke_super.d.TSuper dot.junit.opcodes.invoke_super.d.T_invoke_super_17 dot.junit.opcodes.invoke_super.d.TSuper2 ;invoke-super;Normal #6;Recursion of method lookup procedure
dot.junit.opcodes.invoke_super.Main_testVFE1;dot.junit.opcodes.invoke_super.d.T_invoke_super_8 ;invoke-super;Verifier #1; Constraint A13, invalid constant pool index
dot.junit.opcodes.invoke_super.Main_testVFE10;dot.junit.opcodes.invoke_super.d.TSuper dot.junit.opcodes.invoke_super.d.T_invoke_super_5 ;invoke-super;Verifier #10; Constraint n/a, Attempt to call static method.
dot.junit.opcodes.invoke_super.Main_testVFE12;dot.junit.opcodes.invoke_super.d.T_invoke_super_15 ;invoke-super;Verifier #12; Constraint n/a, Attempt to invoke non-existing method.
dot.junit.opcodes.invoke_super.Main_testVFE13;dot.junit.opcodes.invoke_super.TestStubs dot.junit.opcodes.invoke_super.d.T_invoke_super_18 ;invoke-super;Verifier #13; Constraint n/a, Attempt to invoke private method of other class.
dot.junit.opcodes.invoke_super.Main_testVFE14;dot.junit.opcodes.invoke_super.TestStubs dot.junit.opcodes.invoke_super.d.T_invoke_super_20 ;invoke-super;Verifier #14; Constraint B12, Attempt to invoke protected method of unrelated class.
dot.junit.opcodes.invoke_super.Main_testVFE15;dot.junit.opcodes.invoke_super.d.TSuper dot.junit.opcodes.invoke_super.d.T_invoke_super_19 ;invoke-super;Verifier #15; Constraint n/a, Method has different signature.
dot.junit.opcodes.invoke_super.Main_testVFE16;dot.junit.opcodes.invoke_super.d.TSuper dot.junit.opcodes.invoke_super.d.T_invoke_super_13 ;invoke-super;Verifier #16; Constraint n/a, invoke-super shall be used to invoke private methods
dot.junit.opcodes.invoke_super.Main_testVFE17;dot.junit.opcodes.invoke_super.d.T_invoke_super_9 ;invoke-super;Verifier #17; Constraint A23, number of registers
dot.junit.opcodes.invoke_super.Main_testVFE18;dot.junit.opcodes.invoke_super.d.T_invoke_super_24 ;invoke-super;Verifier #18; Constraint A13, attempt to invoke interface method
dot.junit.opcodes.invoke_super.Main_testVFE19;dot.junit.opcodes.invoke_super.d.TSuper dot.junit.opcodes.invoke_super.d.T_invoke_super_25 ;invoke-super;Verifier #19; Constraint B6, instance methods may only be invoked on already initialized instances.
dot.junit.opcodes.invoke_super.Main_testVFE3;dot.junit.opcodes.invoke_super.d.T_invoke_super_10 ;invoke-super;Verifier #3; Constraint A15, &lt;clinit&gt; may not be called using invoke-super
dot.junit.opcodes.invoke_super.Main_testVFE4;dot.junit.opcodes.invoke_super.d.T_invoke_super_11 ;invoke-super;Verifier #4; Constraint B1, number of arguments passed to method
dot.junit.opcodes.invoke_super.Main_testVFE5;dot.junit.opcodes.invoke_super.d.TSuper dot.junit.opcodes.invoke_super.d.T_invoke_super_12 ;invoke-super;Verifier #5; Constraint B9, types of arguments passed to method.
dot.junit.opcodes.invoke_super.Main_testVFE6;dot.junit.opcodes.invoke_super.d.T_invoke_super_16 ;invoke-super;Verifier #6; Constraint A15, &lt;init&gt; may not be called using invoke_super
dot.junit.opcodes.invoke_super.Main_testVFE8;dot.junit.opcodes.invoke_super.d.TSuper dot.junit.opcodes.invoke_super.d.TPlain dot.junit.opcodes.invoke_super.d.T_invoke_super_22 ;invoke-super;Verifier #8; Constraint B10, assignment incompatible references when accessing                  protected method
dot.junit.opcodes.invoke_super.Main_testVFE9;dot.junit.opcodes.invoke_super.d.TSuper dot.junit.opcodes.invoke_super.d.TSuper2 dot.junit.opcodes.invoke_super.d.T_invoke_super_23 ;invoke-super;Verifier #9; Constraint B10, assignment incompatible references when accessing                  public method
dot.junit.opcodes.invoke_virtual_range.Main_testE1;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_1 ;invoke-virtual/range;Exception #1;Expected NullPointerException
dot.junit.opcodes.invoke_virtual_range.Main_testE2;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_4 ;invoke-virtual/range;Exception #2;Native method can't be linked
dot.junit.opcodes.invoke_virtual_range.Main_testE4;dot.junit.opcodes.invoke_virtual_range.ATest dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_6 ;invoke-virtual/range;Exception #4;Attempt to invoke abstract method
dot.junit.opcodes.invoke_virtual_range.Main_testN1;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_1 ;invoke-virtual/range;Normal #1;Invoke virtual method
dot.junit.opcodes.invoke_virtual_range.Main_testN3;dot.junit.opcodes.invoke_virtual_range.d.TSuper dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_7 ;invoke-virtual/range;Normal #3;Invoke protected method of superclass
dot.junit.opcodes.invoke_virtual_range.Main_testN5;dot.junit.opcodes.invoke_virtual_range.d.TSuper dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_14 ;invoke-virtual/range;Normal #5;Check that new frame is created by invoke_virtual_range and arguments are passed to method
dot.junit.opcodes.invoke_virtual_range.Main_testN6;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_17 dot.junit.opcodes.invoke_virtual_range.d.TSuper ;invoke-virtual/range;Normal #6;Recursion of method lookup procedure
dot.junit.opcodes.invoke_virtual_range.Main_testN7;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_2 ;invoke-virtual/range;Normal #7;Big number of arguments
dot.junit.opcodes.invoke_virtual_range.Main_testVFE1;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_8 ;invoke-virtual/range;Verifier #1; Constraint A14, invalid constant pool index
dot.junit.opcodes.invoke_virtual_range.Main_testVFE10;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_5 ;invoke-virtual/range;Verifier #10; Constraint n/a, Attempt to call static method.
dot.junit.opcodes.invoke_virtual_range.Main_testVFE12;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_15 ;invoke-virtual/range;Verifier #12; Constraint n/a, Attempt to invoke non-existing method.
dot.junit.opcodes.invoke_virtual_range.Main_testVFE13;dot.junit.opcodes.invoke_virtual_range.TestStubs dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_18 ;invoke-virtual/range;Verifier #13; Constraint n/a, Attempt to invoke private method of other class.
dot.junit.opcodes.invoke_virtual_range.Main_testVFE14;dot.junit.opcodes.invoke_virtual_range.TestStubs dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_20 ;invoke-virtual/range;Verifier #14; Constraint B12, Attempt to invoke protected method of unrelated class.
dot.junit.opcodes.invoke_virtual_range.Main_testVFE15;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_19 dot.junit.opcodes.invoke_virtual_range.d.TSuper ;invoke-virtual/range;Verifier #15; Constraint n/a, Method has different signature.
dot.junit.opcodes.invoke_virtual_range.Main_testVFE16;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_13 ;invoke-virtual/range;Verifier #16; Constraint n/a, invoke-virtual/range shall be used to invoke private methods
dot.junit.opcodes.invoke_virtual_range.Main_testVFE17;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_9 ;invoke-virtual/range;Verifier #17; Constraint A23, number of registers
dot.junit.opcodes.invoke_virtual_range.Main_testVFE18;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_24 ;invoke-virtual/range;Verifier #18; Constraint A14, attempt to invoke interface method
dot.junit.opcodes.invoke_virtual_range.Main_testVFE19;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_25 ;invoke-virtual/range;Verifier #19; Constraint B6, instance methods may only be invoked on already initialized instances.
dot.junit.opcodes.invoke_virtual_range.Main_testVFE3;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_10 ;invoke-virtual/range;Verifier #3; Constraint A15, &lt;clinit&gt; may not be called using invoke-virtual
dot.junit.opcodes.invoke_virtual_range.Main_testVFE4;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_11 ;invoke-virtual/range;Verifier #4; Constraint B1, number of arguments passed to method
dot.junit.opcodes.invoke_virtual_range.Main_testVFE5;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_12 ;invoke-virtual/range;Verifier #5; Constraint B9, types of arguments passed to method
dot.junit.opcodes.invoke_virtual_range.Main_testVFE6;dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_16 ;invoke-virtual/range;Verifier #6; Constraint A15, &lt;init&gt; may not be called using invoke_virtual_range
dot.junit.opcodes.invoke_virtual_range.Main_testVFE8;dot.junit.opcodes.invoke_virtual_range.d.TSuper dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_22 dot.junit.opcodes.invoke_virtual_range.d.TPlain ;invoke-virtual/range;Verifier #8; Constraint B10, assignment incompatible references when accessing                  protected method
dot.junit.opcodes.invoke_virtual_range.Main_testVFE9;dot.junit.opcodes.invoke_virtual_range.d.TSuper2 dot.junit.opcodes.invoke_virtual_range.d.TSuper dot.junit.opcodes.invoke_virtual_range.d.T_invoke_virtual_range_23 ;invoke-virtual/range;Verifier #9; Constraint B10, assignment incompatible references when accessing                  public method
dot.junit.opcodes.invoke_virtual.Main_testE1;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_1 ;invoke-virtual;Exception #1;Expected NullPointerException
dot.junit.opcodes.invoke_virtual.Main_testE2;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_4 ;invoke-virtual;Exception #2;Native method can't be linked
dot.junit.opcodes.invoke_virtual.Main_testE4;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_6 dot.junit.opcodes.invoke_virtual.ATest ;invoke-virtual;Exception #4;Attempt to invoke abstract method
dot.junit.opcodes.invoke_virtual.Main_testN1;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_1 ;invoke-virtual;Normal #1;Invoke virtual method
dot.junit.opcodes.invoke_virtual.Main_testN3;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_7 dot.junit.opcodes.invoke_virtual.d.TSuper ;invoke-virtual;Normal #3;Invoke protected method of superclass
dot.junit.opcodes.invoke_virtual.Main_testN5;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_14 dot.junit.opcodes.invoke_virtual.d.TSuper ;invoke-virtual;Normal #5;Check that new frame is created by invoke_virtual and arguments are passed to method
dot.junit.opcodes.invoke_virtual.Main_testN6;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_17 dot.junit.opcodes.invoke_virtual.d.TSuper ;invoke-virtual;Normal #6;Recursion of method lookup procedure
dot.junit.opcodes.invoke_virtual.Main_testVFE1;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_8 ;invoke-virtual;Verifier #1; Constraint A13, invalid constant pool index
dot.junit.opcodes.invoke_virtual.Main_testVFE10;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_5 ;invoke-virtual;Verifier #10; Constraint n/a, Attempt to call static method.
dot.junit.opcodes.invoke_virtual.Main_testVFE12;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_15 ;invoke-virtual;Verifier #12; Constraint n/a, Attempt to invoke non-existing method.
dot.junit.opcodes.invoke_virtual.Main_testVFE13;dot.junit.opcodes.invoke_virtual.TestStubs dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_18 ;invoke-virtual;Verifier #13; Constraint n/a, Attempt to invoke private method of other class.
dot.junit.opcodes.invoke_virtual.Main_testVFE14;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_20 dot.junit.opcodes.invoke_virtual.TestStubs ;invoke-virtual;Verifier #14; Constraint B12, Attempt to invoke protected method of unrelated class.
dot.junit.opcodes.invoke_virtual.Main_testVFE15;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_19 dot.junit.opcodes.invoke_virtual.d.TSuper ;invoke-virtual;Verifier #15; Constraint n/a, Method has different signature.
dot.junit.opcodes.invoke_virtual.Main_testVFE16;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_13 ;invoke-virtual;Verifier #16; Constraint n/a, invoke-virtual shall be used to invoke private methods
dot.junit.opcodes.invoke_virtual.Main_testVFE17;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_9 ;invoke-virtual;Verifier #17; Constraint A23, number of registers
dot.junit.opcodes.invoke_virtual.Main_testVFE18;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_24 ;invoke-virtual;Verifier #18; Constraint A13, attempt to invoke interface method
dot.junit.opcodes.invoke_virtual.Main_testVFE19;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_25 ;invoke-virtual;Verifier #19; Constraint B6, instance methods may only be invoked on already initialized instances.
dot.junit.opcodes.invoke_virtual.Main_testVFE3;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_10 ;invoke-virtual;Verifier #3; Constraint A15, &lt;clinit&gt; may not be called using invoke-virtual
dot.junit.opcodes.invoke_virtual.Main_testVFE4;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_11 ;invoke-virtual;Verifier #4; Constraint B1, number of arguments passed to method
dot.junit.opcodes.invoke_virtual.Main_testVFE5;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_12 ;invoke-virtual;Verifier #5; Constraint B9, types of arguments passed to method
dot.junit.opcodes.invoke_virtual.Main_testVFE6;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_16 ;invoke-virtual;Verifier #6; Constraint A15, &lt;init&gt; may not be called using invoke_virtual
dot.junit.opcodes.invoke_virtual.Main_testVFE8;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_22 dot.junit.opcodes.invoke_virtual.d.TPlain dot.junit.opcodes.invoke_virtual.d.TSuper ;invoke-virtual;Verifier #8; Constraint B10, assignment incompatible references when accessing                  protected method
dot.junit.opcodes.invoke_virtual.Main_testVFE9;dot.junit.opcodes.invoke_virtual.d.T_invoke_virtual_23 dot.junit.opcodes.invoke_virtual.d.TSuper2 dot.junit.opcodes.invoke_virtual.d.TSuper ;invoke-virtual;Verifier #9; Constraint B10, assignment incompatible references when accessing                  public method
dot.junit.opcodes.iput_boolean.Main_testE2;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_13 ;iput-boolean;Exception #2;Expected NullPointerException
dot.junit.opcodes.iput_boolean.Main_testN1;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_1 ;iput-boolean;Normal #1;Put boolean into field
dot.junit.opcodes.iput_boolean.Main_testN2;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_12 ;iput-boolean;Normal #2;Modification of final field
dot.junit.opcodes.iput_boolean.Main_testN4;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_14 dot.junit.opcodes.iput_boolean.d.T_iput_boolean_1 ;iput-boolean;Normal #4;Modification of protected field from subclass
dot.junit.opcodes.iput_boolean.Main_testVFE1;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_3 ;iput-boolean;Verifier #1; Constraint A11, constant pool index
dot.junit.opcodes.iput_boolean.Main_testVFE10;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_9 ;iput-boolean;Verifier #10; Constraint n/a, Attempt to modify field of undefined class.
dot.junit.opcodes.iput_boolean.Main_testVFE11;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_10 ;iput-boolean;Verifier #11; Constraint n/a, Attempt to modify undefined field.
dot.junit.opcodes.iput_boolean.Main_testVFE12;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_15 dot.junit.opcodes.iput_boolean.d.T_iput_boolean_1 ;iput-boolean;Verifier #12; Constraint n/a, Attempt to modify superclass' private field from subclass.
dot.junit.opcodes.iput_boolean.Main_testVFE13;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_2 ;iput-boolean;Verifier #13; Constraint B1, iput_boolean shall not work for wide numbers
dot.junit.opcodes.iput_boolean.Main_testVFE14;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_20 ;iput-boolean;Verifier #14; Constraint B1, iput_boolean shall not work for reference fields
dot.junit.opcodes.iput_boolean.Main_testVFE15;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_21 ;iput-boolean;Verifier #15; Constraint B1, iput_boolean shall not work for short fields
dot.junit.opcodes.iput_boolean.Main_testVFE16;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_22 ;iput-boolean;Verifier #16; Constraint B1, iput_boolean shall not work for int fields
dot.junit.opcodes.iput_boolean.Main_testVFE17;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_23 ;iput-boolean;Verifier #17; Constraint B1, iput_boolean shall not work for char fields
dot.junit.opcodes.iput_boolean.Main_testVFE18;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_24 ;iput-boolean;Verifier #18; Constraint B1, iput_boolean shall not work for byte fields
dot.junit.opcodes.iput_boolean.Main_testVFE19;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_11 dot.junit.opcodes.iput_boolean.TestStubs ;iput-boolean;Verifier #19; Constraint n/a, Modification of final field in other class
dot.junit.opcodes.iput_boolean.Main_testVFE2;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_4 ;iput-boolean;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.iput_boolean.Main_testVFE30;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_30 ;iput-boolean;Verifier #30; Constraint B6, instance fields may only be accessed on already initialized instances.
dot.junit.opcodes.iput_boolean.Main_testVFE5;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_17 ;iput-boolean;Verifier #5; Constraint B14, put boolean into long field - only field with same name but different type exists
dot.junit.opcodes.iput_boolean.Main_testVFE6;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_6 ;iput-boolean;Verifier #6; Constraint B14, put value '2' into boolean field
dot.junit.opcodes.iput_boolean.Main_testVFE7;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_18 ;iput-boolean;Verifier #7; Constraint B14, type of field doesn't match opcode - attempt to modify double field with single-width register
dot.junit.opcodes.iput_boolean.Main_testVFE8;dot.junit.opcodes.iput_boolean.d.T_iput_boolean_7 ;iput-boolean;Verifier #8; Constraint A11, Attempt to set static field.
dot.junit.opcodes.iput_boolean.Main_testVFE9;dot.junit.opcodes.iput_boolean.TestStubs dot.junit.opcodes.iput_boolean.d.T_iput_boolean_8 ;iput-boolean;Verifier #9; Constraint B12, Attempt to modify inaccessible protected field.
dot.junit.opcodes.iput_byte.Main_testE2;dot.junit.opcodes.iput_byte.d.T_iput_byte_13 ;iput-byte;Exception #2;Expected NullPointerException
dot.junit.opcodes.iput_byte.Main_testN1;dot.junit.opcodes.iput_byte.d.T_iput_byte_1 ;iput-byte;Normal #1;Put byte into field
dot.junit.opcodes.iput_byte.Main_testN2;dot.junit.opcodes.iput_byte.d.T_iput_byte_12 ;iput-byte;Normal #2;Modification of final field
dot.junit.opcodes.iput_byte.Main_testN4;dot.junit.opcodes.iput_byte.d.T_iput_byte_1 dot.junit.opcodes.iput_byte.d.T_iput_byte_14 ;iput-byte;Normal #4;Modification of protected field from subclass
dot.junit.opcodes.iput_byte.Main_testVFE1;dot.junit.opcodes.iput_byte.d.T_iput_byte_3 ;iput-byte;Verifier #1; Constraint A11, constant pool index
dot.junit.opcodes.iput_byte.Main_testVFE10;dot.junit.opcodes.iput_byte.d.T_iput_byte_9 ;iput-byte;Verifier #10; Constraint n/a, Attempt to modify field of undefined class.
dot.junit.opcodes.iput_byte.Main_testVFE11;dot.junit.opcodes.iput_byte.d.T_iput_byte_10 ;iput-byte;Verifier #11; Constraint n/a, Attempt to modify undefined field.
dot.junit.opcodes.iput_byte.Main_testVFE12;dot.junit.opcodes.iput_byte.d.T_iput_byte_1 dot.junit.opcodes.iput_byte.d.T_iput_byte_15 ;iput-byte;Verifier #12; Constraint n/a, Attempt to modify superclass' private field from subclass.
dot.junit.opcodes.iput_byte.Main_testVFE13;dot.junit.opcodes.iput_byte.d.T_iput_byte_2 ;iput-byte;Verifier #13; Constraint B1, iput-byte shall not work for wide numbers
dot.junit.opcodes.iput_byte.Main_testVFE14;dot.junit.opcodes.iput_byte.d.T_iput_byte_20 ;iput-byte;Verifier #14; Constraint B1, iput-byte shall not work for reference fields
dot.junit.opcodes.iput_byte.Main_testVFE15;dot.junit.opcodes.iput_byte.d.T_iput_byte_21 ;iput-byte;Verifier #15; Constraint B1, iput-byte shall not work for short fields
dot.junit.opcodes.iput_byte.Main_testVFE16;dot.junit.opcodes.iput_byte.d.T_iput_byte_22 ;iput-byte;Verifier #16; Constraint B1, iput-byte shall not work for int fields
dot.junit.opcodes.iput_byte.Main_testVFE17;dot.junit.opcodes.iput_byte.d.T_iput_byte_23 ;iput-byte;Verifier #17; Constraint B1, iput-byte shall not work for char fields
dot.junit.opcodes.iput_byte.Main_testVFE18;dot.junit.opcodes.iput_byte.d.T_iput_byte_24 ;iput-byte;Verifier #18; Constraint B1, iput-byte shall not work for boolean fields
dot.junit.opcodes.iput_byte.Main_testVFE19;dot.junit.opcodes.iput_byte.d.T_iput_byte_11 dot.junit.opcodes.iput_byte.TestStubs ;iput-byte;Verifier #19; Constraint n/a, Modification of final field in other class
dot.junit.opcodes.iput_byte.Main_testVFE2;dot.junit.opcodes.iput_byte.d.T_iput_byte_4 ;iput-byte;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.iput_byte.Main_testVFE30;dot.junit.opcodes.iput_byte.d.T_iput_byte_30 ;iput-byte;Verifier #30; Constraint B6, instance fields may only be accessed on already initialized instances.
dot.junit.opcodes.iput_byte.Main_testVFE5;dot.junit.opcodes.iput_byte.d.T_iput_byte_17 ;iput-byte;Verifier #5; Constraint B14, put byte into long field - only field with same name but different type exists
dot.junit.opcodes.iput_byte.Main_testVFE6;dot.junit.opcodes.iput_byte.d.T_iput_byte_6 ;iput-byte;Verifier #6; Constraint B14, put value '256' into byte field
dot.junit.opcodes.iput_byte.Main_testVFE7;dot.junit.opcodes.iput_byte.d.T_iput_byte_18 ;iput-byte;Verifier #7; Constraint B14, type of field doesn't match opcode - attempt to modify double field with single-width register
dot.junit.opcodes.iput_byte.Main_testVFE8;dot.junit.opcodes.iput_byte.d.T_iput_byte_7 ;iput-byte;Verifier #8; Constraint A11, Attempt to set static field.
dot.junit.opcodes.iput_byte.Main_testVFE9;dot.junit.opcodes.iput_byte.d.T_iput_byte_8 dot.junit.opcodes.iput_byte.TestStubs ;iput-byte;Verifier #9; Constraint B12, Attempt to modify inaccessible protected field.
dot.junit.opcodes.iput_char.Main_testE2;dot.junit.opcodes.iput_char.d.T_iput_char_13 ;iput-char;Exception #2;Expected NullPointerException
dot.junit.opcodes.iput_char.Main_testN1;dot.junit.opcodes.iput_char.d.T_iput_char_1 ;iput-char;Normal #1;Put char into field
dot.junit.opcodes.iput_char.Main_testN2;dot.junit.opcodes.iput_char.d.T_iput_char_12 ;iput-char;Normal #2;Modification of final field
dot.junit.opcodes.iput_char.Main_testN4;dot.junit.opcodes.iput_char.d.T_iput_char_14 dot.junit.opcodes.iput_char.d.T_iput_char_1 ;iput-char;Normal #4;Modification of protected field from subclass
dot.junit.opcodes.iput_char.Main_testVFE1;dot.junit.opcodes.iput_char.d.T_iput_char_3 ;iput-char;Verifier #1; Constraint A11, constant pool index
dot.junit.opcodes.iput_char.Main_testVFE10;dot.junit.opcodes.iput_char.d.T_iput_char_9 ;iput-char;Verifier #10; Constraint n/a, Attempt to modify field of undefined class.
dot.junit.opcodes.iput_char.Main_testVFE11;dot.junit.opcodes.iput_char.d.T_iput_char_10 ;iput-char;Verifier #11; Constraint n/a, Attempt to modify undefined field.
dot.junit.opcodes.iput_char.Main_testVFE12;dot.junit.opcodes.iput_char.d.T_iput_char_15 dot.junit.opcodes.iput_char.d.T_iput_char_1 ;iput-char;Verifier #12; Constraint n/a, Attempt to modify superclass' private field from subclass.
dot.junit.opcodes.iput_char.Main_testVFE13;dot.junit.opcodes.iput_char.d.T_iput_char_2 ;iput-char;Verifier #13; Constraint B1, iput-char shall not work for wide numbers
dot.junit.opcodes.iput_char.Main_testVFE14;dot.junit.opcodes.iput_char.d.T_iput_char_20 ;iput-char;Verifier #14; Constraint B1, iput-char shall not work for reference fields
dot.junit.opcodes.iput_char.Main_testVFE15;dot.junit.opcodes.iput_char.d.T_iput_char_21 ;iput-char;Verifier #15; Constraint B1, iput-char shall not work for short fields
dot.junit.opcodes.iput_char.Main_testVFE16;dot.junit.opcodes.iput_char.d.T_iput_char_22 ;iput-char;Verifier #16; Constraint B1, iput-char shall not work for int fields
dot.junit.opcodes.iput_char.Main_testVFE17;dot.junit.opcodes.iput_char.d.T_iput_char_23 ;iput-char;Verifier #17; Constraint B1, iput-char shall not work for byte fields
dot.junit.opcodes.iput_char.Main_testVFE18;dot.junit.opcodes.iput_char.d.T_iput_char_24 ;iput-char;Verifier #18; Constraint B1, iput-char shall not work for boolean fields
dot.junit.opcodes.iput_char.Main_testVFE19;dot.junit.opcodes.iput_char.d.T_iput_char_11 dot.junit.opcodes.iput_char.TestStubs ;iput-char;Verifier #19; Constraint n/a, Modification of final field in other class
dot.junit.opcodes.iput_char.Main_testVFE2;dot.junit.opcodes.iput_char.d.T_iput_char_4 ;iput-char;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.iput_char.Main_testVFE30;dot.junit.opcodes.iput_char.d.T_iput_char_30 ;iput-char;Verifier #30; Constraint B6, instance fields may only be accessed on already initialized instances.
dot.junit.opcodes.iput_char.Main_testVFE5;dot.junit.opcodes.iput_char.d.T_iput_char_17 ;iput-char;Verifier #5; Constraint B14, put char into long field - only field with same name but different type exists
dot.junit.opcodes.iput_char.Main_testVFE6;dot.junit.opcodes.iput_char.d.T_iput_char_6 ;iput-char;Verifier #6; Constraint B14, put value '66000' into byte field
dot.junit.opcodes.iput_char.Main_testVFE7;dot.junit.opcodes.iput_char.d.T_iput_char_18 ;iput-char;Verifier #7; Constraint B14, type of field doesn't match opcode - attempt to modify double field with single-width register
dot.junit.opcodes.iput_char.Main_testVFE8;dot.junit.opcodes.iput_char.d.T_iput_char_7 ;iput-char;Verifier #8; Constraint A11, Attempt to set static field.
dot.junit.opcodes.iput_char.Main_testVFE9;dot.junit.opcodes.iput_char.TestStubs dot.junit.opcodes.iput_char.d.T_iput_char_8 ;iput-char;Verifier #9; Constraint B12, Attempt to modify inaccessible protected field.
dot.junit.opcodes.iput_object.Main_testE2;dot.junit.opcodes.iput_object.d.T_iput_object_13 ;iput-object;Exception #2;Expected NullPointerException
dot.junit.opcodes.iput_object.Main_testN1;dot.junit.opcodes.iput_object.d.T_iput_object_1 ;iput-object;Normal #1;Put reference into field
dot.junit.opcodes.iput_object.Main_testN2;dot.junit.opcodes.iput_object.d.T_iput_object_12 ;iput-object;Normal #2;Modification of final field
dot.junit.opcodes.iput_object.Main_testN4;dot.junit.opcodes.iput_object.d.T_iput_object_14 dot.junit.opcodes.iput_object.d.T_iput_object_1 ;iput-object;Normal #4;Modification of protected field from subclass
dot.junit.opcodes.iput_object.Main_testVFE1;dot.junit.opcodes.iput_object.d.T_iput_object_3 ;iput-object;Verifier #1; Constraint A11, constant pool index
dot.junit.opcodes.iput_object.Main_testVFE10;dot.junit.opcodes.iput_object.d.T_iput_object_9 ;iput-object;Verifier #10; Constraint n/a, Attempt to modify field of undefined class.
dot.junit.opcodes.iput_object.Main_testVFE11;dot.junit.opcodes.iput_object.d.T_iput_object_10 ;iput-object;Verifier #11; Constraint n/a, Attempt to modify undefined field.
dot.junit.opcodes.iput_object.Main_testVFE12;dot.junit.opcodes.iput_object.d.T_iput_object_1 dot.junit.opcodes.iput_object.d.T_iput_object_15 ;iput-object;Verifier #12; Constraint n/a, Attempt to modify superclass' private field from subclass.
dot.junit.opcodes.iput_object.Main_testVFE13;dot.junit.opcodes.iput_object.d.T_iput_object_2 ;iput-object;Verifier #13; Constraint B1, iput-object shall not work for wide numbers
dot.junit.opcodes.iput_object.Main_testVFE14;dot.junit.opcodes.iput_object.d.T_iput_object_20 ;iput-object;Verifier #14; Constraint B13, assignment incompatible references
dot.junit.opcodes.iput_object.Main_testVFE15;dot.junit.opcodes.iput_object.d.T_iput_object_21 ;iput-object;Verifier #15; Constraint B1, iput-object shall not work for char fields
dot.junit.opcodes.iput_object.Main_testVFE16;dot.junit.opcodes.iput_object.d.T_iput_object_22 ;iput-object;Verifier #16; Constraint B1, iput-object shall not work for int fields
dot.junit.opcodes.iput_object.Main_testVFE17;dot.junit.opcodes.iput_object.d.T_iput_object_23 ;iput-object;Verifier #17; Constraint B1, iput-object shall not work for byte fields
dot.junit.opcodes.iput_object.Main_testVFE18;dot.junit.opcodes.iput_object.d.T_iput_object_24 ;iput-object;Verifier #18; Constraint B1, iput-object shall not work for boolean fields
dot.junit.opcodes.iput_object.Main_testVFE19;dot.junit.opcodes.iput_object.d.T_iput_object_11 dot.junit.opcodes.iput_object.TestStubs ;iput-object;Verifier #19; Constraint n/a, Modification of final field in other class
dot.junit.opcodes.iput_object.Main_testVFE2;dot.junit.opcodes.iput_object.d.T_iput_object_4 ;iput-object;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.iput_object.Main_testVFE30;dot.junit.opcodes.iput_object.d.T_iput_object_30 ;iput-object;Verifier #30; Constraint B6, instance fields may only be accessed on already initialized instances.
dot.junit.opcodes.iput_object.Main_testVFE5;dot.junit.opcodes.iput_object.d.T_iput_object_17 ;iput-object;Verifier #5; Constraint B14, put object into long field - only field with same name but different type exists
dot.junit.opcodes.iput_object.Main_testVFE6;dot.junit.opcodes.iput_object.d.T_iput_object_6 ;iput-object;Verifier #6; Constraint B1, iput-object shall not work for short fields
dot.junit.opcodes.iput_object.Main_testVFE7;dot.junit.opcodes.iput_object.d.T_iput_object_18 ;iput-object;Verifier #7; Constraint B14, type of field doesn't match opcode - attempt to modify double field with single-width register
dot.junit.opcodes.iput_object.Main_testVFE8;dot.junit.opcodes.iput_object.d.T_iput_object_7 ;iput-object;Verifier #8; Constraint A11, Attempt to set non-static field.
dot.junit.opcodes.iput_object.Main_testVFE9;dot.junit.opcodes.iput_object.TestStubs dot.junit.opcodes.iput_object.d.T_iput_object_8 ;iput-object;Verifier #9; Constraint B12, Attempt to modify inaccessible protected field.
dot.junit.opcodes.iput_short.Main_testE2;dot.junit.opcodes.iput_short.d.T_iput_short_13 ;iput-short;Exception #2;Expected NullPointerException
dot.junit.opcodes.iput_short.Main_testN1;dot.junit.opcodes.iput_short.d.T_iput_short_1 ;iput-short;Normal #1;Put short into field
dot.junit.opcodes.iput_short.Main_testN2;dot.junit.opcodes.iput_short.d.T_iput_short_12 ;iput-short;Normal #2;Modification of final field
dot.junit.opcodes.iput_short.Main_testN4;dot.junit.opcodes.iput_short.d.T_iput_short_1 dot.junit.opcodes.iput_short.d.T_iput_short_14 ;iput-short;Normal #4;Modification of protected field from subclass
dot.junit.opcodes.iput_short.Main_testVFE1;dot.junit.opcodes.iput_short.d.T_iput_short_3 ;iput-short;Verifier #1; Constraint A11, constant pool index
dot.junit.opcodes.iput_short.Main_testVFE10;dot.junit.opcodes.iput_short.d.T_iput_short_9 ;iput-short;Verifier #10; Constraint n/a, Attempt to modify field of undefined class.
dot.junit.opcodes.iput_short.Main_testVFE11;dot.junit.opcodes.iput_short.d.T_iput_short_10 ;iput-short;Verifier #11; Constraint n/a, Attempt to modify undefined field.
dot.junit.opcodes.iput_short.Main_testVFE12;dot.junit.opcodes.iput_short.d.T_iput_short_1 dot.junit.opcodes.iput_short.d.T_iput_short_15 ;iput-short;Verifier #12; Constraint n/a, Attempt to modify superclass' private field from subclass.
dot.junit.opcodes.iput_short.Main_testVFE13;dot.junit.opcodes.iput_short.d.T_iput_short_2 ;iput-short;Verifier #13; Constraint B1, iput-short shall not work for wide numbers
dot.junit.opcodes.iput_short.Main_testVFE14;dot.junit.opcodes.iput_short.d.T_iput_short_20 ;iput-short;Verifier #14; Constraint B1, iput-short shall not work for reference fields
dot.junit.opcodes.iput_short.Main_testVFE15;dot.junit.opcodes.iput_short.d.T_iput_short_21 ;iput-short;Verifier #15; Constraint B1, iput-short shall not work for char fields
dot.junit.opcodes.iput_short.Main_testVFE16;dot.junit.opcodes.iput_short.d.T_iput_short_22 ;iput-short;Verifier #16; Constraint B1, iput-short shall not work for int fields
dot.junit.opcodes.iput_short.Main_testVFE17;dot.junit.opcodes.iput_short.d.T_iput_short_23 ;iput-short;Verifier #17; Constraint B1, iput-short shall not work for byte fields
dot.junit.opcodes.iput_short.Main_testVFE18;dot.junit.opcodes.iput_short.d.T_iput_short_24 ;iput-short;Verifier #18; Constraint B1, iput-short shall not work for boolean fields
dot.junit.opcodes.iput_short.Main_testVFE19;dot.junit.opcodes.iput_short.TestStubs dot.junit.opcodes.iput_short.d.T_iput_short_11 ;iput-short;Verifier #19; Constraint n/a, Modification of final field in other class
dot.junit.opcodes.iput_short.Main_testVFE2;dot.junit.opcodes.iput_short.d.T_iput_short_4 ;iput-short;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.iput_short.Main_testVFE30;dot.junit.opcodes.iput_short.d.T_iput_short_30 ;iput-short;Verifier #30; Constraint B6, instance fields may only be accessed on already initialized instances.
dot.junit.opcodes.iput_short.Main_testVFE5;dot.junit.opcodes.iput_short.d.T_iput_short_17 ;iput-short;Verifier #5; Constraint B14, put short into long field - only field with same name but different type exists
dot.junit.opcodes.iput_short.Main_testVFE6;dot.junit.opcodes.iput_short.d.T_iput_short_6 ;iput-short;Verifier #6; Constraint B14, put value '66000' into byte field
dot.junit.opcodes.iput_short.Main_testVFE7;dot.junit.opcodes.iput_short.d.T_iput_short_18 ;iput-short;Verifier #7; Constraint B14, type of field doesn't match opcode - attempt to modify double field with single-width register
dot.junit.opcodes.iput_short.Main_testVFE8;dot.junit.opcodes.iput_short.d.T_iput_short_7 ;iput-short;Verifier #8; Constraint A11, Attempt to set static field.
dot.junit.opcodes.iput_short.Main_testVFE9;dot.junit.opcodes.iput_short.TestStubs dot.junit.opcodes.iput_short.d.T_iput_short_8 ;iput-short;Verifier #9; Constraint B12, Attempt to modify inaccessible protected field.
dot.junit.opcodes.iput.Main_testE2;dot.junit.opcodes.iput.d.T_iput_13 ;iput;Exception #2;Expected NullPointerException
dot.junit.opcodes.iput.Main_testE5;dot.junit.opcodes.iput.TestStubs dot.junit.opcodes.iput.d.T_iput_11 ;iput;Exception #5; Constraint n/a, Modification of final field in other class
dot.junit.opcodes.iput.Main_testN1;dot.junit.opcodes.iput.d.T_iput_1 ;iput;Normal #1;Type - int
dot.junit.opcodes.iput.Main_testN2;dot.junit.opcodes.iput.d.T_iput_19 ;iput;Normal #2;Type - float
dot.junit.opcodes.iput.Main_testN3;dot.junit.opcodes.iput.d.T_iput_12 ;iput;Normal #3;Modification of final field
dot.junit.opcodes.iput.Main_testN4;dot.junit.opcodes.iput.d.T_iput_1 dot.junit.opcodes.iput.d.T_iput_14 ;iput;Normal #4;Modification of protected field from subclass
dot.junit.opcodes.iput.Main_testN6;dot.junit.opcodes.iput.d.T_iput_5 ;iput;Normal #6;Trying to put float into integer field. Dalvik doens't distinguish 32-bits types internally, so this operation makes no sense but shall not crash the VM.
dot.junit.opcodes.iput.Main_testVFE1;dot.junit.opcodes.iput.d.T_iput_3 ;iput;Verifier #1; Constraint A11, constant pool index
dot.junit.opcodes.iput.Main_testVFE10;dot.junit.opcodes.iput.d.T_iput_9 ;iput;Verifier #10; Constraint n/a, Attempt to modify field of undefined class.
dot.junit.opcodes.iput.Main_testVFE11;dot.junit.opcodes.iput.d.T_iput_10 ;iput;Verifier #11; Constraint n/a, Attempt to modify undefined field.
dot.junit.opcodes.iput.Main_testVFE12;dot.junit.opcodes.iput.d.T_iput_1 dot.junit.opcodes.iput.d.T_iput_15 ;iput;Verifier #12; Constraint n/a, Attempt to modify superclass' private field from subclass.
dot.junit.opcodes.iput.Main_testVFE13;dot.junit.opcodes.iput.d.T_iput_2 ;iput;Verifier #13; Constraint B1, iput shall not work for wide numbers
dot.junit.opcodes.iput.Main_testVFE14;dot.junit.opcodes.iput.d.T_iput_20 ;iput;Verifier #14; Constraint B1, iput shall not work for reference fields
dot.junit.opcodes.iput.Main_testVFE15;dot.junit.opcodes.iput.d.T_iput_21 ;iput;Verifier #15; Constraint B1, iput shall not work for short fields
dot.junit.opcodes.iput.Main_testVFE16;dot.junit.opcodes.iput.d.T_iput_22 ;iput;Verifier #16; Constraint B1, iput shall not work for boolean fields
dot.junit.opcodes.iput.Main_testVFE17;dot.junit.opcodes.iput.d.T_iput_23 ;iput;Verifier #17; Constraint B1, iput shall not work for char fields
dot.junit.opcodes.iput.Main_testVFE18;dot.junit.opcodes.iput.d.T_iput_24 ;iput;Verifier #18; Constraint B1, iput shall not work for byte fields
dot.junit.opcodes.iput.Main_testVFE2;dot.junit.opcodes.iput.d.T_iput_4 ;iput;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.iput.Main_testVFE30;dot.junit.opcodes.iput.d.T_iput_30 ;iput;Verifier #30; Constraint B6, instance fields may only be accessed on already initialized instances.
dot.junit.opcodes.iput.Main_testVFE5;dot.junit.opcodes.iput.d.T_iput_17 ;iput;Verifier #5; Constraint B14, put integer into long field - only field with same name but different type exists
dot.junit.opcodes.iput.Main_testVFE7;dot.junit.opcodes.iput.d.T_iput_18 ;iput;Verifier #7; Constraint B14, type of field doesn't match opcode - attempt to modify double field with single-width register
dot.junit.opcodes.iput.Main_testVFE8;dot.junit.opcodes.iput.d.T_iput_7 ;iput;Verifier #8; Constraint A11, Attempt to set static field.
dot.junit.opcodes.iput.Main_testVFE9;dot.junit.opcodes.iput.d.T_iput_8 dot.junit.opcodes.iput.TestStubs ;iput;Verifier #9; Constraint B12, Attempt to modify inaccessible protected field.
dot.junit.opcodes.iput_wide.Main_testE2;dot.junit.opcodes.iput_wide.d.T_iput_wide_13 ;iput-wide;Exception #2;Expected NullPointerException
dot.junit.opcodes.iput_wide.Main_testE5;dot.junit.opcodes.iput_wide.d.T_iput_wide_11 dot.junit.opcodes.iput_wide.TestStubs ;iput-wide;Exception #5; Constraint n/a, Modification of final field in other class
dot.junit.opcodes.iput_wide.Main_testN1;dot.junit.opcodes.iput_wide.d.T_iput_wide_1 ;iput-wide;Normal #1;Put long into field
dot.junit.opcodes.iput_wide.Main_testN2;dot.junit.opcodes.iput_wide.d.T_iput_wide_5 ;iput-wide;Normal #2;Put double into field
dot.junit.opcodes.iput_wide.Main_testN3;dot.junit.opcodes.iput_wide.d.T_iput_wide_12 ;iput-wide;Normal #3;Modification of final field
dot.junit.opcodes.iput_wide.Main_testN4;dot.junit.opcodes.iput_wide.d.T_iput_wide_1 dot.junit.opcodes.iput_wide.d.T_iput_wide_14 ;iput-wide;Normal #4;Modification of protected field from subclass
dot.junit.opcodes.iput_wide.Main_testVFE1;dot.junit.opcodes.iput_wide.d.T_iput_wide_3 ;iput-wide;Verifier #1; Constraint A11, constant pool index
dot.junit.opcodes.iput_wide.Main_testVFE10;dot.junit.opcodes.iput_wide.d.T_iput_wide_9 ;iput-wide;Verifier #10; Constraint n/a, Attempt to modify field of undefined class.
dot.junit.opcodes.iput_wide.Main_testVFE11;dot.junit.opcodes.iput_wide.d.T_iput_wide_10 ;iput-wide;Verifier #11; Constraint n/a, Attempt to modify undefined field.
dot.junit.opcodes.iput_wide.Main_testVFE12;dot.junit.opcodes.iput_wide.d.T_iput_wide_15 dot.junit.opcodes.iput_wide.d.T_iput_wide_1 ;iput-wide;Verifier #12; Constraint n/a, Attempt to modify superclass' private field from subclass.
dot.junit.opcodes.iput_wide.Main_testVFE13;dot.junit.opcodes.iput_wide.d.T_iput_wide_2 ;iput-wide;Verifier #13; Constraint B1, iput-wide shall not work for single-width numbers
dot.junit.opcodes.iput_wide.Main_testVFE14;dot.junit.opcodes.iput_wide.d.T_iput_wide_20 ;iput-wide;Verifier #14; Constraint B1, iput-wide shall not work for reference fields
dot.junit.opcodes.iput_wide.Main_testVFE15;dot.junit.opcodes.iput_wide.d.T_iput_wide_21 ;iput-wide;Verifier #15; Constraint B1, iput-wide shall not work for char fields
dot.junit.opcodes.iput_wide.Main_testVFE16;dot.junit.opcodes.iput_wide.d.T_iput_wide_22 ;iput-wide;Verifier #16; Constraint B1, iput-wide shall not work for int fields
dot.junit.opcodes.iput_wide.Main_testVFE17;dot.junit.opcodes.iput_wide.d.T_iput_wide_23 ;iput-wide;Verifier #17; Constraint B1, iput-wide shall not work for byte fields
dot.junit.opcodes.iput_wide.Main_testVFE18;dot.junit.opcodes.iput_wide.d.T_iput_wide_24 ;iput-wide;Verifier #18; Constraint B1, iput-wide shall not work for boolean fields
dot.junit.opcodes.iput_wide.Main_testVFE2;dot.junit.opcodes.iput_wide.d.T_iput_wide_4 ;iput-wide;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.iput_wide.Main_testVFE30;dot.junit.opcodes.iput_wide.d.T_iput_wide_30 ;iput-wide;Verifier #30; Constraint B6, instance fields may only be accessed on already initialized instances.
dot.junit.opcodes.iput_wide.Main_testVFE5;dot.junit.opcodes.iput_wide.d.T_iput_wide_17 ;iput-wide;Verifier #5; Constraint B14, put int into long field - only field with same name but different type exists
dot.junit.opcodes.iput_wide.Main_testVFE6;dot.junit.opcodes.iput_wide.d.T_iput_wide_6 ;iput-wide;Verifier #6; Constraint B1, iput-wide shall not work for short fields
dot.junit.opcodes.iput_wide.Main_testVFE7;dot.junit.opcodes.iput_wide.d.T_iput_wide_18 ;iput-wide;Verifier #7; Constraint B14, type of field doesn't match opcode - attempt to modify float field with double-width register
dot.junit.opcodes.iput_wide.Main_testVFE8;dot.junit.opcodes.iput_wide.d.T_iput_wide_7 ;iput-wide;Verifier #8; Constraint A11, Attempt to set non-static field.
dot.junit.opcodes.iput_wide.Main_testVFE9;dot.junit.opcodes.iput_wide.d.T_iput_wide_8 dot.junit.opcodes.iput_wide.TestStubs ;iput-wide;Verifier #9; Constraint B12, Attempt to modify inaccessible protected field.
dot.junit.opcodes.long_to_double.Main_testB1;dot.junit.opcodes.long_to_double.d.T_long_to_double_1 ;long-to-double;Boundary #1;Argument = Long.MAX_VALUE
dot.junit.opcodes.long_to_double.Main_testB2;dot.junit.opcodes.long_to_double.d.T_long_to_double_1 ;long-to-double;Boundary #2;Argument = Long.MIN_VALUE
dot.junit.opcodes.long_to_double.Main_testB3;dot.junit.opcodes.long_to_double.d.T_long_to_double_1 ;long-to-double;Boundary #3;Argument = 0
dot.junit.opcodes.long_to_double.Main_testN1;dot.junit.opcodes.long_to_double.d.T_long_to_double_1 ;long-to-double;Normal #1;Argument = 50000000000
dot.junit.opcodes.long_to_double.Main_testN2;dot.junit.opcodes.long_to_double.d.T_long_to_double_1 ;long-to-double;Normal #2;Argument = 1
dot.junit.opcodes.long_to_double.Main_testN3;dot.junit.opcodes.long_to_double.d.T_long_to_double_1 ;long-to-double;Normal #3;Argument = -1
dot.junit.opcodes.long_to_double.Main_testN4;dot.junit.opcodes.long_to_double.d.T_long_to_double_6 ;long-to-double;Normal #4;Type of argument - double. Dalvik doens't distinguish 64-bits types internally, so this conversion of double to double makes no sense but shall not crash the VM.
dot.junit.opcodes.long_to_double.Main_testVFE1;dot.junit.opcodes.long_to_double.d.T_long_to_double_2 ;long-to-double;Verifier #1; Constraint B1, type of argument - float
dot.junit.opcodes.long_to_double.Main_testVFE2;dot.junit.opcodes.long_to_double.d.T_long_to_double_3 ;long-to-double;Verifier #2; Constraint B1, type of argument - integer
dot.junit.opcodes.long_to_double.Main_testVFE3;dot.junit.opcodes.long_to_double.d.T_long_to_double_4 ;long-to-double;Verifier #3; Constraint B1, type of argument - reference
dot.junit.opcodes.long_to_double.Main_testVFE4;dot.junit.opcodes.long_to_double.d.T_long_to_double_5 ;long-to-double;Verifier #4; Constraint A24, number of registers
dot.junit.opcodes.long_to_float.Main_testB1;dot.junit.opcodes.long_to_float.d.T_long_to_float_1 ;long-to-float;Boundary #1;Argument = Long.MAX_VALUE
dot.junit.opcodes.long_to_float.Main_testB2;dot.junit.opcodes.long_to_float.d.T_long_to_float_1 ;long-to-float;Boundary #2;Argument = Long.MIN_VALUE
dot.junit.opcodes.long_to_float.Main_testB3;dot.junit.opcodes.long_to_float.d.T_long_to_float_1 ;long-to-float;Boundary #3;Argument = 0
dot.junit.opcodes.long_to_float.Main_testN1;dot.junit.opcodes.long_to_float.d.T_long_to_float_1 ;long-to-float;Normal #1;Argument = 123456789012345
dot.junit.opcodes.long_to_float.Main_testN2;dot.junit.opcodes.long_to_float.d.T_long_to_float_1 ;long-to-float;Normal #2;Argument = 1
dot.junit.opcodes.long_to_float.Main_testN3;dot.junit.opcodes.long_to_float.d.T_long_to_float_1 ;long-to-float;Normal #3;Argument = -1
dot.junit.opcodes.long_to_float.Main_testN4;dot.junit.opcodes.long_to_float.d.T_long_to_float_2 ;long-to-float;Normal #4;Type of argument - double. Dalvik doens't distinguish 64-bits types internally, so this conversion of double to double makes no sense but shall not crash the VM.
dot.junit.opcodes.long_to_float.Main_testVFE2;dot.junit.opcodes.long_to_float.d.T_long_to_float_3 ;long-to-float;Verifier #2; Constraint B1, type of argument - integer
dot.junit.opcodes.long_to_float.Main_testVFE3;dot.junit.opcodes.long_to_float.d.T_long_to_float_4 ;long-to-float;Verifier #3; Constraint B1, type of argument - reference
dot.junit.opcodes.long_to_float.Main_testVFE4;dot.junit.opcodes.long_to_float.d.T_long_to_float_5 ;long-to-float;Verifier #4; Constraint A24, number of registers
dot.junit.opcodes.long_to_int.Main_testB1;dot.junit.opcodes.long_to_int.d.T_long_to_int_1 ;long-to-int;Boundary #1;Argument = Long.MAX_VALUE
dot.junit.opcodes.long_to_int.Main_testB2;dot.junit.opcodes.long_to_int.d.T_long_to_int_1 ;long-to-int;Boundary #2;Argument = Long.MIN_VALUE
dot.junit.opcodes.long_to_int.Main_testB3;dot.junit.opcodes.long_to_int.d.T_long_to_int_1 ;long-to-int;Boundary #3;Argument = 0
dot.junit.opcodes.long_to_int.Main_testN1;dot.junit.opcodes.long_to_int.d.T_long_to_int_1 ;long-to-int;Normal #1;Argument = 0xAAAAFFEEDDCCl
dot.junit.opcodes.long_to_int.Main_testN2;dot.junit.opcodes.long_to_int.d.T_long_to_int_1 ;long-to-int;Normal #2;Argument = -123456789
dot.junit.opcodes.long_to_int.Main_testN3;dot.junit.opcodes.long_to_int.d.T_long_to_int_1 ;long-to-int;Normal #3;Argument = 1
dot.junit.opcodes.long_to_int.Main_testN4;dot.junit.opcodes.long_to_int.d.T_long_to_int_1 ;long-to-int;Normal #4;Argument = -1
dot.junit.opcodes.long_to_int.Main_testN5;dot.junit.opcodes.long_to_int.d.T_long_to_int_2 ;long-to-int;Normal #5;Type of argument - double. Dalvik doens't distinguish 64-bits types internally, so this conversion of double to int makes no sense but shall not crash the VM.
dot.junit.opcodes.long_to_int.Main_testVFE1;dot.junit.opcodes.long_to_int.d.T_long_to_int_3 ;long-to-int;Verifier #1; Constraint B1, type of argument - float
dot.junit.opcodes.long_to_int.Main_testVFE2;dot.junit.opcodes.long_to_int.d.T_long_to_int_4 ;long-to-int;Verifier #2; Constraint B1, type of argument - reference
dot.junit.opcodes.long_to_int.Main_testVFE3;dot.junit.opcodes.long_to_int.d.T_long_to_int_5 ;long-to-int;Verifier #3; Constraint A24, number of registers
dot.junit.opcodes.long_to_int.Main_testVFE4;dot.junit.opcodes.long_to_int.d.T_long_to_int_6 ;long-to-int;Verifier #4; Constraint B1, type of argument - int
dot.junit.opcodes.monitor_enter.Main_testE1;dot.junit.opcodes.monitor_enter.d.T_monitor_enter_3 ;monitor-enter;Exception #1;Expected NullPointerException
dot.junit.opcodes.monitor_enter.Main_testN1;dot.junit.opcodes.monitor_enter.TestRunnable dot.junit.opcodes.monitor_enter.d.T_monitor_enter_1 ;monitor-enter;Normal #1;Tests monitor-enter functionality  @throws InterruptedException
dot.junit.opcodes.monitor_enter.Main_testN2;dot.junit.opcodes.monitor_enter.TestRunnable2 dot.junit.opcodes.monitor_enter.d.T_monitor_enter_2 ;monitor-enter;Normal #2;Tests behavior when monitor owned by current thread.  @throws InterruptedException
dot.junit.opcodes.monitor_enter.Main_testVFE1;dot.junit.opcodes.monitor_enter.d.T_monitor_enter_4 ;monitor-enter;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.monitor_enter.Main_testVFE2;dot.junit.opcodes.monitor_enter.d.T_monitor_enter_5 ;monitor-enter;Verifier #2; Constraint B1, types of arguments - int
dot.junit.opcodes.monitor_enter.Main_testVFE3;dot.junit.opcodes.monitor_enter.d.T_monitor_enter_6 ;monitor-enter;Verifier #3; Constraint B1, types of arguments - float
dot.junit.opcodes.monitor_enter.Main_testVFE4;dot.junit.opcodes.monitor_enter.d.T_monitor_enter_7 ;monitor-enter;Verifier #4; Constraint B1, types of arguments - long
dot.junit.opcodes.monitor_enter.Main_testVFE5;dot.junit.opcodes.monitor_enter.d.T_monitor_enter_8 ;monitor-enter;Verifier #5; Constraint B1, types of arguments - double
dot.junit.opcodes.monitor_exit.Main_testE1;dot.junit.opcodes.monitor_exit.TestRunnable dot.junit.opcodes.monitor_exit.d.T_monitor_exit_1 ;monitor-exit;Exception #1;Thread is not monitor owner
dot.junit.opcodes.monitor_exit.Main_testE3;dot.junit.opcodes.monitor_exit.d.T_monitor_exit_3 ;monitor-exit;Exception #3;Expected NullPointerException
dot.junit.opcodes.monitor_exit.Main_testVFE1;dot.junit.opcodes.monitor_exit.d.T_monitor_exit_4 ;monitor-exit;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.monitor_exit.Main_testVFE2;dot.junit.opcodes.monitor_exit.d.T_monitor_exit_5 ;monitor-exit;Verifier #2; Constraint B1, type of arguments - int
dot.junit.opcodes.monitor_exit.Main_testVFE3;dot.junit.opcodes.monitor_exit.d.T_monitor_exit_6 ;monitor-exit;Verifier #3; Constraint B1, type of arguments - float
dot.junit.opcodes.monitor_exit.Main_testVFE4;dot.junit.opcodes.monitor_exit.d.T_monitor_exit_7 ;monitor-exit;Verifier #4; Constraint B1, type of arguments - long
dot.junit.opcodes.monitor_exit.Main_testVFE5;dot.junit.opcodes.monitor_exit.d.T_monitor_exit_8 ;monitor-exit;Verifier #5; Constraint B1, type of arguments - double
dot.junit.opcodes.move_16.Main_testN1;dot.junit.opcodes.move_16.d.T_move_16_1 ;move/16;Normal #1;V4001 -> v4000
dot.junit.opcodes.move_16.Main_testN2;dot.junit.opcodes.move_16.d.T_move_16_2 ;move/16;Normal #2;V1 -> v4001
dot.junit.opcodes.move_16.Main_testVFE1;dot.junit.opcodes.move_16.d.T_move_16_3 ;move/16;Verifier #1; Constraint A23, number of registers - src is not valid
dot.junit.opcodes.move_16.Main_testVFE2;dot.junit.opcodes.move_16.d.T_move_16_4 ;move/16;Verifier #2; Constraint A23, number of registers - dst is not valid
dot.junit.opcodes.move_16.Main_testVFE3;dot.junit.opcodes.move_16.d.T_move_16_5 ;move/16;Verifier #3; Constraint B1, src register contains reference
dot.junit.opcodes.move_16.Main_testVFE4;dot.junit.opcodes.move_16.d.T_move_16_6 ;move/16;Verifier #4; Constraint B1, src register contains wide
dot.junit.opcodes.move_16.Main_testVFE5;dot.junit.opcodes.move_16.d.T_move_16_7 ;move/16;Verifier #5; Constraint B1, src register is a part of reg pair
dot.junit.opcodes.move_16.Main_testVFE6;dot.junit.opcodes.move_16.d.T_move_16_8 ;move/16;Verifier #6; Constraint B18, When writing to a register that is one half of a  register pair, but not touching the other half, the old register pair gets broken  up, and the other register involved in it becomes undefined.
dot.junit.opcodes.move_exception.Main_testN1;dot.junit.opcodes.move_exception.d.T_move_exception_1 ;move-exception;Normal #1;Tests move-exception functionality
dot.junit.opcodes.move_exception.Main_testN2;dot.junit.opcodes.move_exception.d.T_move_exception_2 ;move-exception;Normal #2;Tests move-exception functionality
dot.junit.opcodes.move_exception.Main_testVFE1;dot.junit.opcodes.move_exception.d.T_move_exception_3 ;move-exception;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.move_exception.Main_testVFE3;dot.junit.opcodes.move_exception.d.T_move_exception_5 ;move-exception;Verifier #3; Constraint B21, move-exception is not first instruction in an exception handler
dot.junit.opcodes.move_from16.Main_testN1;dot.junit.opcodes.move_from16.d.T_move_from16_1 ;move/from16;Normal #1;V4001 -> v255 -> v1
dot.junit.opcodes.move_from16.Main_testVFE1;dot.junit.opcodes.move_from16.d.T_move_from16_3 ;move/from16;Verifier #1; Constraint A23, number of registers - src is not valid
dot.junit.opcodes.move_from16.Main_testVFE2;dot.junit.opcodes.move_from16.d.T_move_from16_4 ;move/from16;Verifier #2; Constraint A23, number of registers - dst is not valid
dot.junit.opcodes.move_from16.Main_testVFE3;dot.junit.opcodes.move_from16.d.T_move_from16_5 ;move/from16;Verifier #3; Constraint B1, src register contains reference
dot.junit.opcodes.move_from16.Main_testVFE4;dot.junit.opcodes.move_from16.d.T_move_from16_6 ;move/from16;Verifier #4; Constraint B1, src register contains wide
dot.junit.opcodes.move_from16.Main_testVFE5;dot.junit.opcodes.move_from16.d.T_move_from16_7 ;move/from16;Verifier #5; Constraint B1, src register is a part of reg pair
dot.junit.opcodes.move_from16.Main_testVFE6;dot.junit.opcodes.move_from16.d.T_move_from16_8 ;move/from16;Verifier #6; Constraint B18, When writing to a register that is one half of a  register pair, but not touching the other half, the old register pair gets broken  up, and the other register involved in it becomes undefined.
dot.junit.opcodes.move_object_16.Main_testN1;dot.junit.opcodes.move_object_16.d.T_move_object_16_1 ;move-object/16;Normal #1;V4999 -> v4000 -> v1
dot.junit.opcodes.move_object_16.Main_testVFE1;dot.junit.opcodes.move_object_16.d.T_move_object_16_3 ;move-object/16;Verifier #1; Constraint A23, number of registers - src is not valid
dot.junit.opcodes.move_object_16.Main_testVFE2;dot.junit.opcodes.move_object_16.d.T_move_object_16_4 ;move-object/16;Verifier #2; Constraint A23, number of registers - dst is not valid
dot.junit.opcodes.move_object_16.Main_testVFE3;dot.junit.opcodes.move_object_16.d.T_move_object_16_5 ;move-object/16;Verifier #3; Constraint B1, src register contains integer
dot.junit.opcodes.move_object_16.Main_testVFE4;dot.junit.opcodes.move_object_16.d.T_move_object_16_6 ;move-object/16;Verifier #4; Constraint B1, src register contains wide
dot.junit.opcodes.move_object_16.Main_testVFE5;dot.junit.opcodes.move_object_16.d.T_move_object_16_7 ;move-object/16;Verifier #5; Constraint B1, src register is a part of reg pair
dot.junit.opcodes.move_object_16.Main_testVFE6;dot.junit.opcodes.move_object_16.d.T_move_object_16_8 ;move-object/16;Verifier #6; Constraint B18, When writing to a register that is one half of a  register pair, but not touching the other half, the old register pair gets broken  up, and the other register involved in it becomes undefined.
dot.junit.opcodes.move_object_from16.Main_testN1;dot.junit.opcodes.move_object_from16.d.T_move_object_from16_1 ;move-object/from16;Normal #1;V4999 -> v255 -> v1
dot.junit.opcodes.move_object_from16.Main_testVFE1;dot.junit.opcodes.move_object_from16.d.T_move_object_from16_3 ;move-object/from16;Verifier #1; Constraint A23, number of registers - src is not valid
dot.junit.opcodes.move_object_from16.Main_testVFE2;dot.junit.opcodes.move_object_from16.d.T_move_object_from16_4 ;move-object/from16;Verifier #2; Constraint A23, number of registers - dst is not valid
dot.junit.opcodes.move_object_from16.Main_testVFE3;dot.junit.opcodes.move_object_from16.d.T_move_object_from16_5 ;move-object/from16;Verifier #3; Constraint B1, src register contains integer
dot.junit.opcodes.move_object_from16.Main_testVFE4;dot.junit.opcodes.move_object_from16.d.T_move_object_from16_6 ;move-object/from16;Verifier #4; Constraint B1, src register contains wide
dot.junit.opcodes.move_object_from16.Main_testVFE5;dot.junit.opcodes.move_object_from16.d.T_move_object_from16_7 ;move-object/from16;Verifier #5; Constraint B1, src register is a part of reg pair
dot.junit.opcodes.move_object_from16.Main_testVFE6;dot.junit.opcodes.move_object_from16.d.T_move_object_from16_8 ;move-object/from16;Verifier #6; Constraint B18, When writing to a register that is one half of a  register pair, but not touching the other half, the old register pair gets broken  up, and the other register involved in it becomes undefined.
dot.junit.opcodes.move_object.Main_testN1;dot.junit.opcodes.move_object.d.T_move_object_1 ;move-object;Normal #1;Tests move-object functionality
dot.junit.opcodes.move_object.Main_testVFE1;dot.junit.opcodes.move_object.d.T_move_object_2 ;move-object;Verifier #1; Constraint A23, number of registers - src is not valid
dot.junit.opcodes.move_object.Main_testVFE2;dot.junit.opcodes.move_object.d.T_move_object_3 ;move-object;Verifier #2; Constraint A23, number of registers - dst is not valid
dot.junit.opcodes.move_object.Main_testVFE3;dot.junit.opcodes.move_object.d.T_move_object_4 ;move-object;Verifier #3; Constraint B1, src register contains integer
dot.junit.opcodes.move_object.Main_testVFE4;dot.junit.opcodes.move_object.d.T_move_object_5 ;move-object;Verifier #4; Constraint B1, src register contains wide
dot.junit.opcodes.move_object.Main_testVFE5;dot.junit.opcodes.move_object.d.T_move_object_6 ;move-object;Verifier #5; Constraint B1, src register is a part of reg pair
dot.junit.opcodes.move_object.Main_testVFE6;dot.junit.opcodes.move_object.d.T_move_object_7 ;move-object;Verifier #6; Constraint B18, When writing to a register that is one half of a  register pair, but not touching the other half, the old register pair gets broken  up, and the other register involved in it becomes undefined.
dot.junit.opcodes.move_result_object.Main_testN1;dot.junit.opcodes.move_result_object.d.T_move_result_object_1 ;move-result-object;Normal #1;Tests move-result-object functionality
dot.junit.opcodes.move_result_object.Main_testN2;dot.junit.opcodes.move_result_object.d.T_move_result_object_8 ;move-result-object;Normal #2;Filled-new-array result
dot.junit.opcodes.move_result_object.Main_testVFE1;dot.junit.opcodes.move_result_object.d.T_move_result_object_2 ;move-result-object;Verifier #1; Constraint A23, number of registers - dest is not valid
dot.junit.opcodes.move_result_object.Main_testVFE2;dot.junit.opcodes.move_result_object.d.T_move_result_object_3 ;move-result-object;Verifier #2; Constraint B1, integer
dot.junit.opcodes.move_result_object.Main_testVFE3;dot.junit.opcodes.move_result_object.d.T_move_result_object_4 ;move-result-object;Verifier #3; Constraint B1, wide
dot.junit.opcodes.move_result_object.Main_testVFE4;dot.junit.opcodes.move_result_object.d.T_move_result_object_5 ;move-result-object;Verifier #4; Constraint B18, When writing to a register that is one half of a  register pair, but not touching the other half, the old register pair gets broken  up, and the other register involved in it becomes undefined.
dot.junit.opcodes.move_result_object.Main_testVFE5;dot.junit.opcodes.move_result_object.d.T_move_result_object_6 ;move-result-object;Verifier #5; Constraint B19, move-result-object instruction must be immediately preceded  (in the insns array) by an <invoke-kind> instruction
dot.junit.opcodes.move_result_object.Main_testVFE6;dot.junit.opcodes.move_result_object.d.T_move_result_object_7 ;move-result-object;Verifier #6; Constraint B20, move-result-object instruction must be immediately preceded  (in actual control flow) by an <invoke-kind> instruction
dot.junit.opcodes.move_result_object.Main_testVFE7;dot.junit.opcodes.move_result_object.d.T_move_result_object_9 ;move-result-object;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.move_result.Main_testN1;dot.junit.opcodes.move_result.d.T_move_result_1 ;move-result;Normal #1;Tests move-result functionality
dot.junit.opcodes.move_result.Main_testVFE1;dot.junit.opcodes.move_result.d.T_move_result_2 ;move-result;Verifier #1; Constraint A23, number of registers - dest is not valid
dot.junit.opcodes.move_result.Main_testVFE2;dot.junit.opcodes.move_result.d.T_move_result_3 ;move-result;Verifier #2; Constraint B1, reference
dot.junit.opcodes.move_result.Main_testVFE3;dot.junit.opcodes.move_result.d.T_move_result_4 ;move-result;Verifier #3; Constraint B1, wide
dot.junit.opcodes.move_result.Main_testVFE4;dot.junit.opcodes.move_result.d.T_move_result_5 ;move-result;Verifier #4; Constraint B18, When writing to a register that is one half of a  register pair, but not touching the other half, the old register pair gets broken  up, and the other register involved in it becomes undefined.
dot.junit.opcodes.move_result.Main_testVFE5;dot.junit.opcodes.move_result.d.T_move_result_6 ;move-result;Verifier #5; Constraint B19, move-result instruction must be immediately preceded  (in the insns array) by an <invoke-kind> instruction
dot.junit.opcodes.move_result.Main_testVFE6;dot.junit.opcodes.move_result.d.T_move_result_7 ;move-result;Verifier #6; Constraint B20, move-result instruction must be immediately preceded  (in actual control flow) by an <invoke-kind> instruction
dot.junit.opcodes.move_result.Main_testVFE7;dot.junit.opcodes.move_result.d.T_move_result_8 ;move-result;Verifier #7; Constraint A23, number of registers
dot.junit.opcodes.move_result_wide.Main_testN1;dot.junit.opcodes.move_result_wide.d.T_move_result_wide_1 ;move-result-wide;Normal #1;Tests move-result-wide functionality
dot.junit.opcodes.move_result_wide.Main_testVFE1;dot.junit.opcodes.move_result_wide.d.T_move_result_wide_2 ;move-result-wide;Verifier #1; Constraint A23, number of registers - dest is not valid
dot.junit.opcodes.move_result_wide.Main_testVFE2;dot.junit.opcodes.move_result_wide.d.T_move_result_wide_3 ;move-result-wide;Verifier #2; Constraint B1, reference
dot.junit.opcodes.move_result_wide.Main_testVFE3;dot.junit.opcodes.move_result_wide.d.T_move_result_wide_4 ;move-result-wide;Verifier #3; Constraint B1, 32-bit value
dot.junit.opcodes.move_result_wide.Main_testVFE4;dot.junit.opcodes.move_result_wide.d.T_move_result_wide_5 ;move-result-wide;Verifier #4; Constraint B18, When writing to a register that is one half of a  register pair, but not touching the other half, the old register pair gets broken  up, and the other register involved in it becomes undefined.
dot.junit.opcodes.move_result_wide.Main_testVFE5;dot.junit.opcodes.move_result_wide.d.T_move_result_wide_6 ;move-result-wide;Verifier #5; Constraint B19, move-result-wide instruction must be immediately preceded  (in the insns array) by an <invoke-kind> instruction
dot.junit.opcodes.move_result_wide.Main_testVFE6;dot.junit.opcodes.move_result_wide.d.T_move_result_wide_7 ;move-result-wide;Verifier #6; Constraint B20, move-result-wide instruction must be immediately preceded  (in actual control flow) by an <invoke-kind> instruction
dot.junit.opcodes.move_result_wide.Main_testVFE7;dot.junit.opcodes.move_result_wide.d.T_move_result_wide_8 ;move-result-wide;Verifier #7; Constraint A24, number of registers
dot.junit.opcodes.move.Main_testN1;dot.junit.opcodes.move.d.T_move_1 ;move;Normal #1;Test move functionality
dot.junit.opcodes.move.Main_testVFE1;dot.junit.opcodes.move.d.T_move_2 ;move;Verifier #1; Constraint A23, number of registers - src is not valid
dot.junit.opcodes.move.Main_testVFE2;dot.junit.opcodes.move.d.T_move_3 ;move;Verifier #2; Constraint A23, number of registers - dst is not valid
dot.junit.opcodes.move.Main_testVFE3;dot.junit.opcodes.move.d.T_move_4 ;move;Verifier #3; Constraint B1, src register contains reference
dot.junit.opcodes.move.Main_testVFE4;dot.junit.opcodes.move.d.T_move_5 ;move;Verifier #4; Constraint B1, src register contains wide
dot.junit.opcodes.move.Main_testVFE5;dot.junit.opcodes.move.d.T_move_6 ;move;Verifier #5; Constraint B1, src register is a part of reg pair
dot.junit.opcodes.move.Main_testVFE6;dot.junit.opcodes.move.d.T_move_7 ;move;Verifier #6; Constraint B18, When writing to a register that is one half of a  register pair, but not touching the other half, the old register pair gets broken  up, and the other register involved in it becomes undefined.
dot.junit.opcodes.move_wide_16.Main_testN1;dot.junit.opcodes.move_wide_16.d.T_move_wide_16_1 ;move-wide/16;Normal #1;V4001 -> v4000
dot.junit.opcodes.move_wide_16.Main_testN2;dot.junit.opcodes.move_wide_16.d.T_move_wide_16_1 ;move-wide/16;Normal #2;V1 -> v4001
dot.junit.opcodes.move_wide_16.Main_testN3;dot.junit.opcodes.move_wide_16.d.T_move_wide_16_9 ;move-wide/16;Normal #3;V1 -> v2
dot.junit.opcodes.move_wide_16.Main_testVFE1;dot.junit.opcodes.move_wide_16.d.T_move_wide_16_3 ;move-wide/16;Verifier #1; Constraint A24, number of registers - src is not valid
dot.junit.opcodes.move_wide_16.Main_testVFE2;dot.junit.opcodes.move_wide_16.d.T_move_wide_16_4 ;move-wide/16;Verifier #2; Constraint A24, number of registers - dst is not valid
dot.junit.opcodes.move_wide_16.Main_testVFE3;dot.junit.opcodes.move_wide_16.d.T_move_wide_16_5 ;move-wide/16;Verifier #3; Constraint B1, src register contains reference
dot.junit.opcodes.move_wide_16.Main_testVFE4;dot.junit.opcodes.move_wide_16.d.T_move_wide_16_6 ;move-wide/16;Verifier #4; Constraint B1, src register contains 32-bit value
dot.junit.opcodes.move_wide_16.Main_testVFE5;dot.junit.opcodes.move_wide_16.d.T_move_wide_16_7 ;move-wide/16;Verifier #5; Constraint B1, src register is a part of reg pair
dot.junit.opcodes.move_wide_16.Main_testVFE6;dot.junit.opcodes.move_wide_16.d.T_move_wide_16_8 ;move-wide/16;Verifier #6; Constraint B18, When writing to a register that is one half of a  register pair, but not touching the other half, the old register pair gets broken  up, and the other register involved in it becomes undefined.
dot.junit.opcodes.move_wide_from16.Main_testN1;dot.junit.opcodes.move_wide_from16.d.T_move_wide_from16_1 ;move-wide/from16;Normal #1;V4001 -> v255 -> v1
dot.junit.opcodes.move_wide_from16.Main_testN2;dot.junit.opcodes.move_wide_from16.d.T_move_wide_from16_2 ;move-wide/from16;Normal #2;V100 -> 101
dot.junit.opcodes.move_wide_from16.Main_testVFE1;dot.junit.opcodes.move_wide_from16.d.T_move_wide_from16_3 ;move-wide/from16;Verifier #1; Constraint A24, number of registers - src is not valid
dot.junit.opcodes.move_wide_from16.Main_testVFE2;dot.junit.opcodes.move_wide_from16.d.T_move_wide_from16_4 ;move-wide/from16;Verifier #2; Constraint A24, number of registers - dst is not valid
dot.junit.opcodes.move_wide_from16.Main_testVFE3;dot.junit.opcodes.move_wide_from16.d.T_move_wide_from16_5 ;move-wide/from16;Verifier #3; Constraint B1, src register contains reference
dot.junit.opcodes.move_wide_from16.Main_testVFE4;dot.junit.opcodes.move_wide_from16.d.T_move_wide_from16_6 ;move-wide/from16;Verifier #4; Constraint B1, src register contains 32-bit value
dot.junit.opcodes.move_wide_from16.Main_testVFE5;dot.junit.opcodes.move_wide_from16.d.T_move_wide_from16_7 ;move-wide/from16;Verifier #5; Constraint B1, src register is a part of reg pair
dot.junit.opcodes.move_wide_from16.Main_testVFE6;dot.junit.opcodes.move_wide_from16.d.T_move_wide_from16_8 ;move-wide/from16;Verifier #6; Constraint B18, When writing to a register that is one half of a  register pair, but not touching the other half, the old register pair gets broken  up, and the other register involved in it becomes undefined.
dot.junit.opcodes.move_wide.Main_testN1;dot.junit.opcodes.move_wide.d.T_move_wide_1 ;move-wide;Normal #1;Tests move-wide functionality
dot.junit.opcodes.move_wide.Main_testN2;dot.junit.opcodes.move_wide.d.T_move_wide_6 ;move-wide;Normal #2;V0 -> v1
dot.junit.opcodes.move_wide.Main_testVFE1;dot.junit.opcodes.move_wide.d.T_move_wide_2 ;move-wide;Verifier #1; Constraint A24, number of registers - src is not valid
dot.junit.opcodes.move_wide.Main_testVFE2;dot.junit.opcodes.move_wide.d.T_move_wide_3 ;move-wide;Verifier #2; Constraint A24, number of registers - dst is not valid
dot.junit.opcodes.move_wide.Main_testVFE3;dot.junit.opcodes.move_wide.d.T_move_wide_4 ;move-wide;Verifier #3; Constraint B1, src register contains reference
dot.junit.opcodes.move_wide.Main_testVFE4;dot.junit.opcodes.move_wide.d.T_move_wide_5 ;move-wide;Verifier #4; Constraint B1, src register contains 32-bit value
dot.junit.opcodes.move_wide.Main_testVFE6;dot.junit.opcodes.move_wide.d.T_move_wide_7 ;move-wide;Verifier #6; Constraint B18, When writing to a register that is one half of a  register pair, but not touching the other half, the old register pair gets broken  up, and the other register involved in it becomes undefined.
dot.junit.opcodes.mul_double_2addr.Main_testB1;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_1 ;mul-double/2addr;Boundary #1;Arguments = Double.MAX_VALUE, Double.NaN
dot.junit.opcodes.mul_double_2addr.Main_testB2;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_1 ;mul-double/2addr;Boundary #2;Arguments = Double.POSITIVE_INFINITY, 0
dot.junit.opcodes.mul_double_2addr.Main_testB3;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_1 ;mul-double/2addr;Boundary #3;Arguments = Double.POSITIVE_INFINITY, -2.7d
dot.junit.opcodes.mul_double_2addr.Main_testB4;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_1 ;mul-double/2addr;Boundary #4;Arguments = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
dot.junit.opcodes.mul_double_2addr.Main_testB5;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_1 ;mul-double/2addr;Boundary #5;Arguments = +0, -0d
dot.junit.opcodes.mul_double_2addr.Main_testB6;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_1 ;mul-double/2addr;Boundary #6;Arguments = -0d, -0d
dot.junit.opcodes.mul_double_2addr.Main_testB7;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_1 ;mul-double/2addr;Boundary #7;Arguments = Double.MAX_VALUE, Double.MAX_VALUE
dot.junit.opcodes.mul_double_2addr.Main_testB8;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_1 ;mul-double/2addr;Boundary #8;Arguments = Double.MIN_VALUE, -1.4E-45f
dot.junit.opcodes.mul_double_2addr.Main_testN1;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_1 ;mul-double/2addr;Normal #1;Arguments = 2.7d, 3.14d
dot.junit.opcodes.mul_double_2addr.Main_testN2;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_1 ;mul-double/2addr;Normal #2;Arguments = 0, -3.14d
dot.junit.opcodes.mul_double_2addr.Main_testN3;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_1 ;mul-double/2addr;Normal #3;Arguments = -2.7d, -3.14d
dot.junit.opcodes.mul_double_2addr.Main_testN4;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_4 ;mul-double/2addr;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this multiplication of long and long makes no sense but shall not crash the VM.
dot.junit.opcodes.mul_double_2addr.Main_testVFE1;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_2 ;mul-double/2addr;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.mul_double_2addr.Main_testVFE2;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_3 ;mul-double/2addr;Verifier #2; Constraint B1, types of arguments - float, double
dot.junit.opcodes.mul_double_2addr.Main_testVFE3;dot.junit.opcodes.mul_double_2addr.d.T_mul_double_2addr_5 ;mul-double/2addr;Verifier #3; Constraint B1, types of arguments - double, reference
dot.junit.opcodes.mul_double.Main_testB1;dot.junit.opcodes.mul_double.d.T_mul_double_1 ;mul-double;Boundary #1;Arguments = Double.MAX_VALUE, Double.NaN
dot.junit.opcodes.mul_double.Main_testB2;dot.junit.opcodes.mul_double.d.T_mul_double_1 ;mul-double;Boundary #2;Arguments = Double.POSITIVE_INFINITY, 0
dot.junit.opcodes.mul_double.Main_testB3;dot.junit.opcodes.mul_double.d.T_mul_double_1 ;mul-double;Boundary #3;Arguments = Double.POSITIVE_INFINITY, -2.7d
dot.junit.opcodes.mul_double.Main_testB4;dot.junit.opcodes.mul_double.d.T_mul_double_1 ;mul-double;Boundary #4;Arguments = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
dot.junit.opcodes.mul_double.Main_testB5;dot.junit.opcodes.mul_double.d.T_mul_double_1 ;mul-double;Boundary #5;Arguments = +0, -0d
dot.junit.opcodes.mul_double.Main_testB6;dot.junit.opcodes.mul_double.d.T_mul_double_1 ;mul-double;Boundary #6;Arguments = -0d, -0d
dot.junit.opcodes.mul_double.Main_testB7;dot.junit.opcodes.mul_double.d.T_mul_double_1 ;mul-double;Boundary #7;Arguments = Double.MAX_VALUE, Double.MAX_VALUE
dot.junit.opcodes.mul_double.Main_testB8;dot.junit.opcodes.mul_double.d.T_mul_double_1 ;mul-double;Boundary #8;Arguments = Double.MIN_VALUE, -1.4E-45f
dot.junit.opcodes.mul_double.Main_testN1;dot.junit.opcodes.mul_double.d.T_mul_double_1 ;mul-double;Normal #1;Arguments = 2.7d, 3.14d
dot.junit.opcodes.mul_double.Main_testN2;dot.junit.opcodes.mul_double.d.T_mul_double_1 ;mul-double;Normal #2;Arguments = 0, -3.14d
dot.junit.opcodes.mul_double.Main_testN3;dot.junit.opcodes.mul_double.d.T_mul_double_1 ;mul-double;Normal #3;Arguments = -2.7d, -3.14d
dot.junit.opcodes.mul_double.Main_testN4;dot.junit.opcodes.mul_double.d.T_mul_double_4 ;mul-double;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this multiplication of long and long makes no sense but shall not crash the VM.
dot.junit.opcodes.mul_double.Main_testVFE1;dot.junit.opcodes.mul_double.d.T_mul_double_2 ;mul-double;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.mul_double.Main_testVFE2;dot.junit.opcodes.mul_double.d.T_mul_double_3 ;mul-double;Verifier #2; Constraint B1, types of arguments - float, double
dot.junit.opcodes.mul_double.Main_testVFE3;dot.junit.opcodes.mul_double.d.T_mul_double_5 ;mul-double;Verifier #3; Constraint B1, types of arguments - double, reference
dot.junit.opcodes.mul_float_2addr.Main_testB1;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_1 ;mul-float/2addr;Boundary #1;Arguments = Float.MAX_VALUE, Float.NaN
dot.junit.opcodes.mul_float_2addr.Main_testB2;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_1 ;mul-float/2addr;Boundary #2;Arguments = Float.POSITIVE_INFINITY, 0
dot.junit.opcodes.mul_float_2addr.Main_testB3;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_1 ;mul-float/2addr;Boundary #3;Arguments = Float.POSITIVE_INFINITY, -2.7f
dot.junit.opcodes.mul_float_2addr.Main_testB4;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_1 ;mul-float/2addr;Boundary #4;Arguments = Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY
dot.junit.opcodes.mul_float_2addr.Main_testB5;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_1 ;mul-float/2addr;Boundary #5;Arguments = +0, -0f
dot.junit.opcodes.mul_float_2addr.Main_testB6;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_1 ;mul-float/2addr;Boundary #6;Arguments = -0f, -0f
dot.junit.opcodes.mul_float_2addr.Main_testB7;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_1 ;mul-float/2addr;Boundary #7;Arguments = Float.MAX_VALUE, Float.MAX_VALUE
dot.junit.opcodes.mul_float_2addr.Main_testB8;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_1 ;mul-float/2addr;Boundary #8;Arguments = Float.MIN_VALUE, -1.4E-45f
dot.junit.opcodes.mul_float_2addr.Main_testN1;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_1 ;mul-float/2addr;Normal #1;Arguments = 2.7f, 3.14f
dot.junit.opcodes.mul_float_2addr.Main_testN2;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_1 ;mul-float/2addr;Normal #2;Arguments = 0, -3.14f
dot.junit.opcodes.mul_float_2addr.Main_testN3;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_1 ;mul-float/2addr;Normal #3;Arguments = -2.7f, -3.14f
dot.junit.opcodes.mul_float_2addr.Main_testN4;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_6 ;mul-float/2addr;Normal #4;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this multiplication of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.mul_float_2addr.Main_testVFE1;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_2 ;mul-float/2addr;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.mul_float_2addr.Main_testVFE2;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_3 ;mul-float/2addr;Verifier #2; Constraint B1, types of arguments - float, double
dot.junit.opcodes.mul_float_2addr.Main_testVFE3;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_4 ;mul-float/2addr;Verifier #3; Constraint B1, types of arguments - long, float
dot.junit.opcodes.mul_float_2addr.Main_testVFE4;dot.junit.opcodes.mul_float_2addr.d.T_mul_float_2addr_5 ;mul-float/2addr;Verifier #4; Constraint B1, types of arguments - reference, float
dot.junit.opcodes.mul_float.Main_testB1;dot.junit.opcodes.mul_float.d.T_mul_float_1 ;mul-float;Boundary #1;Arguments = Float.MAX_VALUE, Float.NaN
dot.junit.opcodes.mul_float.Main_testB2;dot.junit.opcodes.mul_float.d.T_mul_float_1 ;mul-float;Boundary #2;Arguments = Float.POSITIVE_INFINITY, 0
dot.junit.opcodes.mul_float.Main_testB3;dot.junit.opcodes.mul_float.d.T_mul_float_1 ;mul-float;Boundary #3;Arguments = Float.POSITIVE_INFINITY, -2.7f
dot.junit.opcodes.mul_float.Main_testB4;dot.junit.opcodes.mul_float.d.T_mul_float_1 ;mul-float;Boundary #4;Arguments = Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY
dot.junit.opcodes.mul_float.Main_testB5;dot.junit.opcodes.mul_float.d.T_mul_float_1 ;mul-float;Boundary #5;Arguments = +0, -0f
dot.junit.opcodes.mul_float.Main_testB6;dot.junit.opcodes.mul_float.d.T_mul_float_1 ;mul-float;Boundary #6;Arguments = -0f, -0f
dot.junit.opcodes.mul_float.Main_testB7;dot.junit.opcodes.mul_float.d.T_mul_float_1 ;mul-float;Boundary #7;Arguments = Float.MAX_VALUE, Float.MAX_VALUE
dot.junit.opcodes.mul_float.Main_testB8;dot.junit.opcodes.mul_float.d.T_mul_float_1 ;mul-float;Boundary #8;Arguments = Float.MIN_VALUE, -1.4E-45f
dot.junit.opcodes.mul_float.Main_testN1;dot.junit.opcodes.mul_float.d.T_mul_float_1 ;mul-float;Normal #1;Arguments = 2.7f, 3.14f
dot.junit.opcodes.mul_float.Main_testN2;dot.junit.opcodes.mul_float.d.T_mul_float_1 ;mul-float;Normal #2;Arguments = 0, -3.14f
dot.junit.opcodes.mul_float.Main_testN3;dot.junit.opcodes.mul_float.d.T_mul_float_1 ;mul-float;Normal #3;Arguments = -2.7f, -3.14f
dot.junit.opcodes.mul_float.Main_testN4;dot.junit.opcodes.mul_float.d.T_mul_float_6 ;mul-float;Normal #4;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this multiplication of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.mul_float.Main_testVFE1;dot.junit.opcodes.mul_float.d.T_mul_float_2 ;mul-float;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.mul_float.Main_testVFE2;dot.junit.opcodes.mul_float.d.T_mul_float_3 ;mul-float;Verifier #2; Constraint B1, types of arguments - float, double
dot.junit.opcodes.mul_float.Main_testVFE3;dot.junit.opcodes.mul_float.d.T_mul_float_4 ;mul-float;Verifier #3; Constraint B1, types of arguments - long, float
dot.junit.opcodes.mul_float.Main_testVFE4;dot.junit.opcodes.mul_float.d.T_mul_float_5 ;mul-float;Verifier #4; Constraint B1, types of arguments - reference, float
dot.junit.opcodes.mul_int_2addr.Main_testB1;dot.junit.opcodes.mul_int_2addr.d.T_mul_int_2addr_1 ;mul-int/2addr;Boundary #1;Arguments = 0, Integer.MAX_VALUE
dot.junit.opcodes.mul_int_2addr.Main_testB2;dot.junit.opcodes.mul_int_2addr.d.T_mul_int_2addr_1 ;mul-int/2addr;Boundary #2;Arguments = Integer.MAX_VALUE, 1
dot.junit.opcodes.mul_int_2addr.Main_testB3;dot.junit.opcodes.mul_int_2addr.d.T_mul_int_2addr_1 ;mul-int/2addr;Boundary #3;Arguments = Integer.MIN_VALUE, 1
dot.junit.opcodes.mul_int_2addr.Main_testB4;dot.junit.opcodes.mul_int_2addr.d.T_mul_int_2addr_1 ;mul-int/2addr;Boundary #4;Arguments = Integer.MAX_VALUE, Integer.MIN_VALUE
dot.junit.opcodes.mul_int_2addr.Main_testB5;dot.junit.opcodes.mul_int_2addr.d.T_mul_int_2addr_1 ;mul-int/2addr;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.mul_int_2addr.Main_testN1;dot.junit.opcodes.mul_int_2addr.d.T_mul_int_2addr_1 ;mul-int/2addr;Normal #1;Arguments = 8, 4
dot.junit.opcodes.mul_int_2addr.Main_testN2;dot.junit.opcodes.mul_int_2addr.d.T_mul_int_2addr_1 ;mul-int/2addr;Normal #2;Arguments = -2, 255
dot.junit.opcodes.mul_int_2addr.Main_testN3;dot.junit.opcodes.mul_int_2addr.d.T_mul_int_2addr_1 ;mul-int/2addr;Normal #3;Arguments = 0x7ffffffe, 2
dot.junit.opcodes.mul_int_2addr.Main_testN4;dot.junit.opcodes.mul_int_2addr.d.T_mul_int_2addr_1 ;mul-int/2addr;Normal #4;Arguments = 4, 0x80000001
dot.junit.opcodes.mul_int_2addr.Main_testN5;dot.junit.opcodes.mul_int_2addr.d.T_mul_int_2addr_6 ;mul-int/2addr;Normal #5;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this multiplication of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.mul_int_2addr.Main_testVFE1;dot.junit.opcodes.mul_int_2addr.d.T_mul_int_2addr_2 ;mul-int/2addr;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.mul_int_2addr.Main_testVFE2;dot.junit.opcodes.mul_int_2addr.d.T_mul_int_2addr_3 ;mul-int/2addr;Verifier #2; Constraint B1, types of arguments - int, double
dot.junit.opcodes.mul_int_2addr.Main_testVFE3;dot.junit.opcodes.mul_int_2addr.d.T_mul_int_2addr_4 ;mul-int/2addr;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.mul_int_2addr.Main_testVFE4;dot.junit.opcodes.mul_int_2addr.d.T_mul_int_2addr_5 ;mul-int/2addr;Verifier #4; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.mul_int_lit16.Main_testB1;dot.junit.opcodes.mul_int_lit16.d.T_mul_int_lit16_4 ;mul-int/lit16;Boundary #1;Arguments = 0, 0
dot.junit.opcodes.mul_int_lit16.Main_testB2;dot.junit.opcodes.mul_int_lit16.d.T_mul_int_lit16_4 ;mul-int/lit16;Boundary #2;Arguments = 0, Short.MAX_VALUE
dot.junit.opcodes.mul_int_lit16.Main_testB3;dot.junit.opcodes.mul_int_lit16.d.T_mul_int_lit16_5 ;mul-int/lit16;Boundary #3;Arguments = 1, Short.MAX_VALUE
dot.junit.opcodes.mul_int_lit16.Main_testB4;dot.junit.opcodes.mul_int_lit16.d.T_mul_int_lit16_5 ;mul-int/lit16;Boundary #4;Arguments = 1, Short.MIN_VALUE
dot.junit.opcodes.mul_int_lit16.Main_testB5;dot.junit.opcodes.mul_int_lit16.d.T_mul_int_lit16_6 ;mul-int/lit16;Boundary #5;Arguments = 32767, Short.MIN_VALUE
dot.junit.opcodes.mul_int_lit16.Main_testN1;dot.junit.opcodes.mul_int_lit16.d.T_mul_int_lit16_1 ;mul-int/lit16;Normal #1;Arguments = 205, 130
dot.junit.opcodes.mul_int_lit16.Main_testN2;dot.junit.opcodes.mul_int_lit16.d.T_mul_int_lit16_1 ;mul-int/lit16;Normal #2;Arguments = -180, 130
dot.junit.opcodes.mul_int_lit16.Main_testN3;dot.junit.opcodes.mul_int_lit16.d.T_mul_int_lit16_1 ;mul-int/lit16;Normal #3;Arguments = 0xfa, 130
dot.junit.opcodes.mul_int_lit16.Main_testN4;dot.junit.opcodes.mul_int_lit16.d.T_mul_int_lit16_2 ;mul-int/lit16;Normal #4;Arguments = -101, -321
dot.junit.opcodes.mul_int_lit16.Main_testN5;dot.junit.opcodes.mul_int_lit16.d.T_mul_int_lit16_3 ;mul-int/lit16;Normal #5;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this multiplication of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.mul_int_lit16.Main_testVFE1;dot.junit.opcodes.mul_int_lit16.d.T_mul_int_lit16_7 ;mul-int/lit16;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.mul_int_lit16.Main_testVFE2;dot.junit.opcodes.mul_int_lit16.d.T_mul_int_lit16_8 ;mul-int/lit16;Verifier #2; Constraint B1, types of arguments - int * double
dot.junit.opcodes.mul_int_lit16.Main_testVFE3;dot.junit.opcodes.mul_int_lit16.d.T_mul_int_lit16_9 ;mul-int/lit16;Verifier #3; Constraint B1, types of arguments - long * int
dot.junit.opcodes.mul_int_lit16.Main_testVFE4;dot.junit.opcodes.mul_int_lit16.d.T_mul_int_lit16_10 ;mul-int/lit16;Verifier #4; Constraint B1, types of arguments - reference * int
dot.junit.opcodes.mul_int_lit8.Main_testB1;dot.junit.opcodes.mul_int_lit8.d.T_mul_int_lit8_4 ;mul-int/lit8;Boundary #1;Arguments = 0, 0
dot.junit.opcodes.mul_int_lit8.Main_testB2;dot.junit.opcodes.mul_int_lit8.d.T_mul_int_lit8_4 ;mul-int/lit8;Boundary #2;Arguments = 0, Byte.MAX_VALUE
dot.junit.opcodes.mul_int_lit8.Main_testB3;dot.junit.opcodes.mul_int_lit8.d.T_mul_int_lit8_5 ;mul-int/lit8;Boundary #3;Arguments = 1, Byte.MAX_VALUE
dot.junit.opcodes.mul_int_lit8.Main_testB4;dot.junit.opcodes.mul_int_lit8.d.T_mul_int_lit8_5 ;mul-int/lit8;Boundary #4;Arguments = 1, Short.MIN_VALUE
dot.junit.opcodes.mul_int_lit8.Main_testB5;dot.junit.opcodes.mul_int_lit8.d.T_mul_int_lit8_6 ;mul-int/lit8;Boundary #5;Arguments = 127, Short.MIN_VALUE
dot.junit.opcodes.mul_int_lit8.Main_testN1;dot.junit.opcodes.mul_int_lit8.d.T_mul_int_lit8_1 ;mul-int/lit8;Normal #1;Arguments =  10, 55
dot.junit.opcodes.mul_int_lit8.Main_testN2;dot.junit.opcodes.mul_int_lit8.d.T_mul_int_lit8_1 ;mul-int/lit8;Normal #2;Arguments = 10, -25
dot.junit.opcodes.mul_int_lit8.Main_testN3;dot.junit.opcodes.mul_int_lit8.d.T_mul_int_lit8_2 ;mul-int/lit8;Normal #3;Arguments = -15, -23
dot.junit.opcodes.mul_int_lit8.Main_testN4;dot.junit.opcodes.mul_int_lit8.d.T_mul_int_lit8_1 ;mul-int/lit8;Normal #4;Arguments = 0x7ffffffe, 10
dot.junit.opcodes.mul_int_lit8.Main_testN5;dot.junit.opcodes.mul_int_lit8.d.T_mul_int_lit8_3 ;mul-int/lit8;Normal #5;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this multiplication of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.mul_int_lit8.Main_testVFE1;dot.junit.opcodes.mul_int_lit8.d.T_mul_int_lit8_7 ;mul-int/lit8;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.mul_int_lit8.Main_testVFE2;dot.junit.opcodes.mul_int_lit8.d.T_mul_int_lit8_8 ;mul-int/lit8;Verifier #2; Constraint B1, types of arguments - int * double
dot.junit.opcodes.mul_int_lit8.Main_testVFE3;dot.junit.opcodes.mul_int_lit8.d.T_mul_int_lit8_9 ;mul-int/lit8;Verifier #3; Constraint B1, types of arguments - long * int
dot.junit.opcodes.mul_int_lit8.Main_testVFE4;dot.junit.opcodes.mul_int_lit8.d.T_mul_int_lit8_10 ;mul-int/lit8;Verifier #4; Constraint B1, types of arguments - reference * int
dot.junit.opcodes.mul_int.Main_testB1;dot.junit.opcodes.mul_int.d.T_mul_int_1 ;mul-int;Boundary #1;Arguments = 0, Integer.MAX_VALUE
dot.junit.opcodes.mul_int.Main_testB2;dot.junit.opcodes.mul_int.d.T_mul_int_1 ;mul-int;Boundary #2;Arguments = Integer.MAX_VALUE, 1
dot.junit.opcodes.mul_int.Main_testB3;dot.junit.opcodes.mul_int.d.T_mul_int_1 ;mul-int;Boundary #3;Arguments = Integer.MIN_VALUE, 1
dot.junit.opcodes.mul_int.Main_testB4;dot.junit.opcodes.mul_int.d.T_mul_int_1 ;mul-int;Boundary #4;Arguments = Integer.MAX_VALUE, Integer.MIN_VALUE
dot.junit.opcodes.mul_int.Main_testB5;dot.junit.opcodes.mul_int.d.T_mul_int_1 ;mul-int;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.mul_int.Main_testN1;dot.junit.opcodes.mul_int.d.T_mul_int_1 ;mul-int;Normal #1;Arguments = 8, 4
dot.junit.opcodes.mul_int.Main_testN2;dot.junit.opcodes.mul_int.d.T_mul_int_1 ;mul-int;Normal #2;Arguments = -2, 255
dot.junit.opcodes.mul_int.Main_testN3;dot.junit.opcodes.mul_int.d.T_mul_int_1 ;mul-int;Normal #3;Arguments = 0x7ffffffe, 2
dot.junit.opcodes.mul_int.Main_testN4;dot.junit.opcodes.mul_int.d.T_mul_int_1 ;mul-int;Normal #4;Arguments = 4, 0x80000001
dot.junit.opcodes.mul_int.Main_testN5;dot.junit.opcodes.mul_int.d.T_mul_int_6 ;mul-int;Normal #5;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this multiplication of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.mul_int.Main_testVFE1;dot.junit.opcodes.mul_int.d.T_mul_int_2 ;mul-int;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.mul_int.Main_testVFE2;dot.junit.opcodes.mul_int.d.T_mul_int_3 ;mul-int;Verifier #2; Constraint B1, types of arguments - int, double
dot.junit.opcodes.mul_int.Main_testVFE3;dot.junit.opcodes.mul_int.d.T_mul_int_4 ;mul-int;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.mul_int.Main_testVFE4;dot.junit.opcodes.mul_int.d.T_mul_int_5 ;mul-int;Verifier #4; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.mul_long_2addr.Main_testB1;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_1 ;mul-long/2addr;Boundary #1;Arguments = 0, Long.MAX_VALUE
dot.junit.opcodes.mul_long_2addr.Main_testB2;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_1 ;mul-long/2addr;Boundary #2;Arguments = Long.MAX_VALUE, 1
dot.junit.opcodes.mul_long_2addr.Main_testB3;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_1 ;mul-long/2addr;Boundary #3;Arguments = Long.MIN_VALUE, 1
dot.junit.opcodes.mul_long_2addr.Main_testB4;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_1 ;mul-long/2addr;Boundary #4;Arguments = Long.MAX_VALUE, Long.MIN_VALUE
dot.junit.opcodes.mul_long_2addr.Main_testB5;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_1 ;mul-long/2addr;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.mul_long_2addr.Main_testB6;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_1 ;mul-long/2addr;Boundary #6;Arguments = Long.MAX_VALUE, -1
dot.junit.opcodes.mul_long_2addr.Main_testB7;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_1 ;mul-long/2addr;Boundary #7;Arguments = Long.MIN_VALUE, -1
dot.junit.opcodes.mul_long_2addr.Main_testN1;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_1 ;mul-long/2addr;Normal #1;Arguments = 222000000000l, 5000000000l
dot.junit.opcodes.mul_long_2addr.Main_testN2;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_1 ;mul-long/2addr;Normal #2;Arguments = -123456789l, 123456789l
dot.junit.opcodes.mul_long_2addr.Main_testN3;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_1 ;mul-long/2addr;Normal #3;Arguments = -123456789l, -123456789l
dot.junit.opcodes.mul_long_2addr.Main_testN4;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_3 ;mul-long/2addr;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this multiplication of long and long makes no sense but shall not crash the VM.
dot.junit.opcodes.mul_long_2addr.Main_testVFE1;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_2 ;mul-long/2addr;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.mul_long_2addr.Main_testVFE2;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_4 ;mul-long/2addr;Verifier #2; Constraint B1, types of arguments - long * int
dot.junit.opcodes.mul_long_2addr.Main_testVFE3;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_5 ;mul-long/2addr;Verifier #3; Constraint B1, types of arguments - float * long
dot.junit.opcodes.mul_long_2addr.Main_testVFE4;dot.junit.opcodes.mul_long_2addr.d.T_mul_long_2addr_6 ;mul-long/2addr;Verifier #4; Constraint B1, types of arguments - reference * long
dot.junit.opcodes.mul_long.Main_testB1;dot.junit.opcodes.mul_long.d.T_mul_long_1 ;mul-long;Boundary #1;Arguments = 0, Long.MAX_VALUE
dot.junit.opcodes.mul_long.Main_testB2;dot.junit.opcodes.mul_long.d.T_mul_long_1 ;mul-long;Boundary #2;Arguments = Long.MAX_VALUE, 1
dot.junit.opcodes.mul_long.Main_testB3;dot.junit.opcodes.mul_long.d.T_mul_long_1 ;mul-long;Boundary #3;Arguments = Long.MIN_VALUE, 1
dot.junit.opcodes.mul_long.Main_testB4;dot.junit.opcodes.mul_long.d.T_mul_long_1 ;mul-long;Boundary #4;Arguments = Long.MAX_VALUE, Long.MIN_VALUE
dot.junit.opcodes.mul_long.Main_testB5;dot.junit.opcodes.mul_long.d.T_mul_long_1 ;mul-long;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.mul_long.Main_testB6;dot.junit.opcodes.mul_long.d.T_mul_long_1 ;mul-long;Boundary #6;Arguments = Long.MAX_VALUE, -1
dot.junit.opcodes.mul_long.Main_testB7;dot.junit.opcodes.mul_long.d.T_mul_long_1 ;mul-long;Boundary #7;Arguments = Long.MIN_VALUE, -1
dot.junit.opcodes.mul_long.Main_testN1;dot.junit.opcodes.mul_long.d.T_mul_long_1 ;mul-long;Normal #1;Arguments = 222000000000l, 5000000000l
dot.junit.opcodes.mul_long.Main_testN2;dot.junit.opcodes.mul_long.d.T_mul_long_1 ;mul-long;Normal #2;Arguments = -123456789l, 123456789l
dot.junit.opcodes.mul_long.Main_testN3;dot.junit.opcodes.mul_long.d.T_mul_long_1 ;mul-long;Normal #3;Arguments = -123456789l, -123456789l
dot.junit.opcodes.mul_long.Main_testN4;dot.junit.opcodes.mul_long.d.T_mul_long_3 ;mul-long;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this multiplication of long and long makes no sense but shall not crash the VM.
dot.junit.opcodes.mul_long.Main_testVFE1;dot.junit.opcodes.mul_long.d.T_mul_long_2 ;mul-long;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.mul_long.Main_testVFE2;dot.junit.opcodes.mul_long.d.T_mul_long_4 ;mul-long;Verifier #2; Constraint B1, types of arguments - long * int
dot.junit.opcodes.mul_long.Main_testVFE3;dot.junit.opcodes.mul_long.d.T_mul_long_5 ;mul-long;Verifier #3; Constraint B1, types of arguments - float * long
dot.junit.opcodes.mul_long.Main_testVFE4;dot.junit.opcodes.mul_long.d.T_mul_long_6 ;mul-long;Verifier #4; Constraint B1, types of arguments - reference * long
dot.junit.opcodes.neg_double.Main_testB1;dot.junit.opcodes.neg_double.d.T_neg_double_1 ;neg-double;Boundary #1;Argument = Double.NaN
dot.junit.opcodes.neg_double.Main_testB2;dot.junit.opcodes.neg_double.d.T_neg_double_1 ;neg-double;Boundary #2;Argument = Double.NEGATIVE_INFINITY
dot.junit.opcodes.neg_double.Main_testB3;dot.junit.opcodes.neg_double.d.T_neg_double_1 ;neg-double;Boundary #3;Argument = Double.POSITIVE_INFINITY
dot.junit.opcodes.neg_double.Main_testB4;dot.junit.opcodes.neg_double.d.T_neg_double_1 ;neg-double;Boundary #4;Argument = Double.MAX_VALUE
dot.junit.opcodes.neg_double.Main_testB5;dot.junit.opcodes.neg_double.d.T_neg_double_1 ;neg-double;Boundary #5;Argument = Double.MIN_VALUE
dot.junit.opcodes.neg_double.Main_testN1;dot.junit.opcodes.neg_double.d.T_neg_double_1 ;neg-double;Normal #1;Argument = 1
dot.junit.opcodes.neg_double.Main_testN2;dot.junit.opcodes.neg_double.d.T_neg_double_1 ;neg-double;Normal #2;Argument = -1
dot.junit.opcodes.neg_double.Main_testN3;dot.junit.opcodes.neg_double.d.T_neg_double_1 ;neg-double;Normal #3;Argument = +0
dot.junit.opcodes.neg_double.Main_testN4;dot.junit.opcodes.neg_double.d.T_neg_double_1 ;neg-double;Normal #4;Argument = -2.7
dot.junit.opcodes.neg_double.Main_testN5;dot.junit.opcodes.neg_double.d.T_neg_double_4 ;neg-double;Normal #5;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this operation of long and double makes no sense but shall not crash the VM.
dot.junit.opcodes.neg_double.Main_testVFE1;dot.junit.opcodes.neg_double.d.T_neg_double_2 ;neg-double;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.neg_double.Main_testVFE2;dot.junit.opcodes.neg_double.d.T_neg_double_3 ;neg-double;Verifier #2; Constraint B1, type of argument - float
dot.junit.opcodes.neg_double.Main_testVFE3;dot.junit.opcodes.neg_double.d.T_neg_double_5 ;neg-double;Verifier #3; Constraint B1, type of argument - int
dot.junit.opcodes.neg_double.Main_testVFE4;dot.junit.opcodes.neg_double.d.T_neg_double_6 ;neg-double;Verifier #4; Constraint B1, type of argument - reference
dot.junit.opcodes.neg_float.Main_testB1;dot.junit.opcodes.neg_float.d.T_neg_float_1 ;neg-float;Boundary #1;Argument = Float.NaN
dot.junit.opcodes.neg_float.Main_testB2;dot.junit.opcodes.neg_float.d.T_neg_float_1 ;neg-float;Boundary #2;Argument = Float.NEGATIVE_INFINITY
dot.junit.opcodes.neg_float.Main_testB3;dot.junit.opcodes.neg_float.d.T_neg_float_1 ;neg-float;Boundary #3;Argument = Float.POSITIVE_INFINITY
dot.junit.opcodes.neg_float.Main_testB4;dot.junit.opcodes.neg_float.d.T_neg_float_1 ;neg-float;Boundary #4;Argument = Float.MAX_VALUE
dot.junit.opcodes.neg_float.Main_testB5;dot.junit.opcodes.neg_float.d.T_neg_float_1 ;neg-float;Boundary #5;Argument = Float.MIN
dot.junit.opcodes.neg_float.Main_testN1;dot.junit.opcodes.neg_float.d.T_neg_float_1 ;neg-float;Normal #1;Argument = 1
dot.junit.opcodes.neg_float.Main_testN2;dot.junit.opcodes.neg_float.d.T_neg_float_1 ;neg-float;Normal #2;Argument = -1
dot.junit.opcodes.neg_float.Main_testN3;dot.junit.opcodes.neg_float.d.T_neg_float_1 ;neg-float;Normal #3;Argument = +0
dot.junit.opcodes.neg_float.Main_testN4;dot.junit.opcodes.neg_float.d.T_neg_float_1 ;neg-float;Normal #4;Argument = -2.7
dot.junit.opcodes.neg_float.Main_testN5;dot.junit.opcodes.neg_float.d.T_neg_float_6 ;neg-float;Normal #5;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.neg_float.Main_testVFE1;dot.junit.opcodes.neg_float.d.T_neg_float_2 ;neg-float;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.neg_float.Main_testVFE2;dot.junit.opcodes.neg_float.d.T_neg_float_3 ;neg-float;Verifier #2; Constraint B1, type of argument - double
dot.junit.opcodes.neg_float.Main_testVFE3;dot.junit.opcodes.neg_float.d.T_neg_float_4 ;neg-float;Verifier #3; Constraint B1, type of argument - long
dot.junit.opcodes.neg_float.Main_testVFE4;dot.junit.opcodes.neg_float.d.T_neg_float_5 ;neg-float;Verifier #4; Constraint B1, type of argument - reference
dot.junit.opcodes.neg_int.Main_testB1;dot.junit.opcodes.neg_int.d.T_neg_int_1 ;neg-int;Boundary #1;Argument = Integer.MAX_VALUE
dot.junit.opcodes.neg_int.Main_testB2;dot.junit.opcodes.neg_int.d.T_neg_int_1 ;neg-int;Boundary #2;Argument = Integer.MIN_VALUE
dot.junit.opcodes.neg_int.Main_testN1;dot.junit.opcodes.neg_int.d.T_neg_int_1 ;neg-int;Normal #1;Argument = 1
dot.junit.opcodes.neg_int.Main_testN2;dot.junit.opcodes.neg_int.d.T_neg_int_1 ;neg-int;Normal #2;Argument = -1
dot.junit.opcodes.neg_int.Main_testN3;dot.junit.opcodes.neg_int.d.T_neg_int_1 ;neg-int;Normal #3;Argument = 32768
dot.junit.opcodes.neg_int.Main_testN4;dot.junit.opcodes.neg_int.d.T_neg_int_1 ;neg-int;Normal #4;Argument = 0
dot.junit.opcodes.neg_int.Main_testN5;dot.junit.opcodes.neg_int.d.T_neg_int_2 ;neg-int;Normal #5;Check that -x == (~x + 1)
dot.junit.opcodes.neg_int.Main_testN6;dot.junit.opcodes.neg_int.d.T_neg_int_7 ;neg-int;Normal #6;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.neg_int.Main_testVFE1;dot.junit.opcodes.neg_int.d.T_neg_int_3 ;neg-int;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.neg_int.Main_testVFE2;dot.junit.opcodes.neg_int.d.T_neg_int_4 ;neg-int;Verifier #2; Constraint B1, type of argument - double
dot.junit.opcodes.neg_int.Main_testVFE3;dot.junit.opcodes.neg_int.d.T_neg_int_5 ;neg-int;Verifier #3; Constraint B1, type of argument - long
dot.junit.opcodes.neg_int.Main_testVFE4;dot.junit.opcodes.neg_int.d.T_neg_int_6 ;neg-int;Verifier #4; Constraint B1, type of argument - reference
dot.junit.opcodes.neg_long.Main_testB1;dot.junit.opcodes.neg_long.d.T_neg_long_1 ;neg-long;Boundary #1;Argument = 0
dot.junit.opcodes.neg_long.Main_testB2;dot.junit.opcodes.neg_long.d.T_neg_long_1 ;neg-long;Boundary #2;Argument = Long.MAX_VALUE
dot.junit.opcodes.neg_long.Main_testB3;dot.junit.opcodes.neg_long.d.T_neg_long_1 ;neg-long;Boundary #3;Argument = Long.MIN_VALUE
dot.junit.opcodes.neg_long.Main_testN1;dot.junit.opcodes.neg_long.d.T_neg_long_1 ;neg-long;Normal #1;Argument = 123123123272432432l
dot.junit.opcodes.neg_long.Main_testN2;dot.junit.opcodes.neg_long.d.T_neg_long_1 ;neg-long;Normal #2;Argument = 1
dot.junit.opcodes.neg_long.Main_testN3;dot.junit.opcodes.neg_long.d.T_neg_long_1 ;neg-long;Normal #3;Argument = -1
dot.junit.opcodes.neg_long.Main_testN4;dot.junit.opcodes.neg_long.d.T_neg_long_2 ;neg-long;Normal #4;Check that -x == (~x + 1)
dot.junit.opcodes.neg_long.Main_testN5;dot.junit.opcodes.neg_long.d.T_neg_long_4 ;neg-long;Normal #5;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this operation of long and double makes no sense but shall not crash the VM.
dot.junit.opcodes.neg_long.Main_testVFE1;dot.junit.opcodes.neg_long.d.T_neg_long_3 ;neg-long;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.neg_long.Main_testVFE2;dot.junit.opcodes.neg_long.d.T_neg_long_5 ;neg-long;Verifier #2; Constraint B1, type of argument - int
dot.junit.opcodes.neg_long.Main_testVFE3;dot.junit.opcodes.neg_long.d.T_neg_long_6 ;neg-long;Verifier #3; Constraint B1, type of argument - float
dot.junit.opcodes.neg_long.Main_testVFE4;dot.junit.opcodes.neg_long.d.T_neg_long_7 ;neg-long;Verifier #4; Constraint B1, type of argument - reference
dot.junit.opcodes.new_array.Main_testB1;dot.junit.opcodes.new_array.d.T_new_array_1 ;new-array;Boundary #1;Array size = 0
dot.junit.opcodes.new_array.Main_testE1;dot.junit.opcodes.new_array.d.T_new_array_2 ;new-array;Exception #1;Expected NegativeArraySizeException
dot.junit.opcodes.new_array.Main_testN1;dot.junit.opcodes.new_array.d.T_new_array_1 ;new-array;Normal #1;Array of ints
dot.junit.opcodes.new_array.Main_testN2;dot.junit.opcodes.new_array.d.T_new_array_2 ;new-array;Normal #2;Array of booleans
dot.junit.opcodes.new_array.Main_testN3;dot.junit.opcodes.new_array.d.T_new_array_3 ;new-array;Normal #3;Array of Objects
dot.junit.opcodes.new_array.Main_testVFE1;dot.junit.opcodes.new_array.d.T_new_array_4 ;new-array;Verifier #1; Constraint B1, number of registers
dot.junit.opcodes.new_array.Main_testVFE2;dot.junit.opcodes.new_array.d.T_new_array_5 ;new-array;Verifier #2; Constraint B1, size argument - long
dot.junit.opcodes.new_array.Main_testVFE3;dot.junit.opcodes.new_array.d.T_new_array_9 ;new-array;Verifier #3; Constraint B1, size argument - reference
dot.junit.opcodes.new_array.Main_testVFE4;dot.junit.opcodes.new_array.d.T_new_array_6 ;new-array;Verifier #4; Constraint A19, constant pool index
dot.junit.opcodes.new_array.Main_testVFE5;dot.junit.opcodes.new_array.d.T_new_array_7 ;new-array;Verifier #5; Constraint A22, attempt to create object
dot.junit.opcodes.new_array.Main_testVFE6;dot.junit.opcodes.new_array.d.T_new_array_8 ;new-array;Verifier #6; Constraint A20, array of more than 255 dimensions
dot.junit.opcodes.new_array.Main_testVFE7;dot.junit.opcodes.new_array.d.T_new_array_11 ;new-array;Verifier #7; Constraint n/a, Attempt to instantiate array of non-existent class.
dot.junit.opcodes.new_array.Main_testVFE8;dot.junit.opcodes.new_array.d.T_new_array_10 dot.junit.opcodes.new_array.TestStubs ;new-array;Verifier #8; Constraint n/a, Attempt to instantiate array of inaccessible class.
dot.junit.opcodes.new_instance.Main_testE1;dot.junit.opcodes.new_instance.d.T_new_instance_3 ;new-instance;Exception #1;Class initialization throws exception
dot.junit.opcodes.new_instance.Main_testE4;dot.junit.opcodes.new_instance.d.TestAbstractClass dot.junit.opcodes.new_instance.d.T_new_instance_8 ;new-instance;Exception #4; Constraint A21, attempt to instantiate interface
dot.junit.opcodes.new_instance.Main_testE5;dot.junit.opcodes.new_instance.d.T_new_instance_9 dot.junit.opcodes.new_instance.d.TestAbstractClass ;new-instance;Exception #5; Constraint A21, attempt to instantiate abstract class
dot.junit.opcodes.new_instance.Main_testN1;dot.junit.opcodes.new_instance.d.T_new_instance_1 ;new-instance;Normal #1;New String
dot.junit.opcodes.new_instance.Main_testVFE1;dot.junit.opcodes.new_instance.d.T_new_instance_6 ;new-instance;Verifier #1; Constraint A18, constant pool index
dot.junit.opcodes.new_instance.Main_testVFE2;dot.junit.opcodes.new_instance.d.T_new_instance_7 ;new-instance;Verifier #2; Constraint A21, attempt to create array using new
dot.junit.opcodes.new_instance.Main_testVFE3;dot.junit.opcodes.new_instance.d.T_new_instance_2 ;new-instance;Verifier #3; Constraint B6, Attempt to access uninitialized class (before <init> is called
dot.junit.opcodes.new_instance.Main_testVFE4;dot.junit.opcodes.new_instance.d.T_new_instance_10 ;new-instance;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.new_instance.Main_testVFE5;dot.junit.opcodes.new_instance.TestStubs dot.junit.opcodes.new_instance.d.T_new_instance_4 ;new-instance;Verifier #5; Constraint n/a, Attempt to instantiate array of inaccessible class.
dot.junit.opcodes.new_instance.Main_testVFE6;dot.junit.opcodes.new_instance.d.T_new_instance_5 ;new-instance;Verifier #6; Constraint n/a, Attempt to instantiate array of non-existent class.
dot.junit.opcodes.new_instance.Main_testVFE7;dot.junit.opcodes.new_instance.d.T_new_instance_11 ;new-instance;Verifier #7; Constraint B7, A register which holds the result of a new-instance instruction must not be used if the same new-instance  instruction is again executed before the instance is initialized
dot.junit.opcodes.new_instance.Main_testVFE8;dot.junit.opcodes.new_instance.d.T_new_instance_12 ;new-instance;Verifier #8; Constraint B7, A register which holds the result of a new-instance instruction must not be used if the same new-instance  instruction is again executed before the instance is initialized
dot.junit.opcodes.nop.Main_testN1;dot.junit.opcodes.nop.d.T_nop_1 ;nop;Normal #1;Tests nop
dot.junit.opcodes.not_int.Main_testB1;dot.junit.opcodes.not_int.d.T_not_int_1 ;not-int;Boundary #1;Argument = Integer.MAX_VALUE
dot.junit.opcodes.not_int.Main_testB2;dot.junit.opcodes.not_int.d.T_not_int_1 ;not-int;Boundary #2;Argument = Integer.MIN_VALUE
dot.junit.opcodes.not_int.Main_testB3;dot.junit.opcodes.not_int.d.T_not_int_1 ;not-int;Boundary #3;Argument = 1
dot.junit.opcodes.not_int.Main_testB4;dot.junit.opcodes.not_int.d.T_not_int_1 ;not-int;Boundary #4;Argument = 0
dot.junit.opcodes.not_int.Main_testB5;dot.junit.opcodes.not_int.d.T_not_int_1 ;not-int;Boundary #5;Argument = -1
dot.junit.opcodes.not_int.Main_testB6;dot.junit.opcodes.not_int.d.T_not_int_1 ;not-int;Boundary #6;Argument = Short.MAX_VALUE
dot.junit.opcodes.not_int.Main_testB7;dot.junit.opcodes.not_int.d.T_not_int_1 ;not-int;Boundary #7;Argument = Short.MIN_VALUE
dot.junit.opcodes.not_int.Main_testN1;dot.junit.opcodes.not_int.d.T_not_int_1 ;not-int;Normal #1;Argument = 5; 256
dot.junit.opcodes.not_int.Main_testN2;dot.junit.opcodes.not_int.d.T_not_int_1 ;not-int;Normal #2;Argument = -5, -256
dot.junit.opcodes.not_int.Main_testN3;dot.junit.opcodes.not_int.d.T_not_int_1 ;not-int;Normal #3;Argument = 0xcafe; 0x12c
dot.junit.opcodes.not_int.Main_testN4;dot.junit.opcodes.not_int.d.T_not_int_2 ;not-int;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this multiplication of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.not_int.Main_testVFE1;dot.junit.opcodes.not_int.d.T_not_int_3 ;not-int;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.not_int.Main_testVFE2;dot.junit.opcodes.not_int.d.T_not_int_4 ;not-int;Verifier #2; Constraint B1, types of arguments - double
dot.junit.opcodes.not_int.Main_testVFE3;dot.junit.opcodes.not_int.d.T_not_int_5 ;not-int;Verifier #3; Constraint B1, types of arguments - long
dot.junit.opcodes.not_int.Main_testVFE4;dot.junit.opcodes.not_int.d.T_not_int_6 ;not-int;Verifier #4; Constraint B1, types of arguments - reference
dot.junit.opcodes.not_long.Main_testB1;dot.junit.opcodes.not_long.d.T_not_long_1 ;not-long;Boundary #1;Argument = Long.MAX_VALUE
dot.junit.opcodes.not_long.Main_testB2;dot.junit.opcodes.not_long.d.T_not_long_1 ;not-long;Boundary #2;Argument = Long.MIN_VALUE
dot.junit.opcodes.not_long.Main_testB3;dot.junit.opcodes.not_long.d.T_not_long_1 ;not-long;Boundary #3;Argument = 1l
dot.junit.opcodes.not_long.Main_testB4;dot.junit.opcodes.not_long.d.T_not_long_1 ;not-long;Boundary #4;Argument = 0l
dot.junit.opcodes.not_long.Main_testB5;dot.junit.opcodes.not_long.d.T_not_long_1 ;not-long;Boundary #5;Argument = -1l
dot.junit.opcodes.not_long.Main_testN1;dot.junit.opcodes.not_long.d.T_not_long_1 ;not-long;Normal #1;Argument = 500000l
dot.junit.opcodes.not_long.Main_testN2;dot.junit.opcodes.not_long.d.T_not_long_1 ;not-long;Normal #2;Argument = -500000l
dot.junit.opcodes.not_long.Main_testN3;dot.junit.opcodes.not_long.d.T_not_long_1 ;not-long;Normal #3;Argument = 0xcafe; 0x12c
dot.junit.opcodes.not_long.Main_testN4;dot.junit.opcodes.not_long.d.T_not_long_2 ;not-long;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this multiplication of long and double makes no sense but shall not crash the VM.
dot.junit.opcodes.not_long.Main_testVFE1;dot.junit.opcodes.not_long.d.T_not_long_3 ;not-long;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.not_long.Main_testVFE2;dot.junit.opcodes.not_long.d.T_not_long_4 ;not-long;Verifier #2; Constraint B1, types of arguments - int
dot.junit.opcodes.not_long.Main_testVFE3;dot.junit.opcodes.not_long.d.T_not_long_5 ;not-long;Verifier #3; Constraint B1, types of arguments - float
dot.junit.opcodes.not_long.Main_testVFE4;dot.junit.opcodes.not_long.d.T_not_long_6 ;not-long;Verifier #4; Constraint B1, types of arguments - reference
dot.junit.opcodes.opc_const.Main_testN1;dot.junit.opcodes.opc_const.d.T_opc_const_1 ;const;Normal #1;Const v1, 1.54
dot.junit.opcodes.opc_const.Main_testN2;dot.junit.opcodes.opc_const.d.T_opc_const_2 ;const;Normal #2;Const v254, 20000000
dot.junit.opcodes.opc_const.Main_testVFE1;dot.junit.opcodes.opc_const.d.T_opc_const_3 ;const;Verifier #1; Constraint B1, number of registers
dot.junit.opcodes.opc_const.Main_testVFE2;dot.junit.opcodes.opc_const.d.T_opc_const_4 ;const;Verifier #2; Constraint B11, When writing to a register that is one half of a register  pair, but not touching the other half, the old register pair gets broken up, and the  other register involved in it becomes undefined
dot.junit.opcodes.opc_goto.Main_testN1;dot.junit.opcodes.opc_goto.d.T_opc_goto_1 ;goto;Normal #1;Forward and backward goto. This test also tests constraint C17 allowing to have backward goto as a last opcode in the method.
dot.junit.opcodes.opc_goto.Main_testVFE1;dot.junit.opcodes.opc_goto.d.T_opc_goto_2 ;goto;Verifier #1; Constraint A6, branch target is inside instruction
dot.junit.opcodes.opc_goto.Main_testVFE2;dot.junit.opcodes.opc_goto.d.T_opc_goto_3 ;goto;Verifier #2; Constraint A6, branch target shall be inside the method
dot.junit.opcodes.opc_goto.Main_testVFE3;dot.junit.opcodes.opc_goto.d.T_opc_goto_4 ;goto;Verifier #3; Constraint n/a, zero offset
dot.junit.opcodes.opc_return.Main_testE1;dot.junit.opcodes.opc_return.d.T_opc_return_3 ;return;Exception #1;Method is synchronized but thread is not monitor owner
dot.junit.opcodes.opc_return.Main_testN1;dot.junit.opcodes.opc_return.d.T_opc_return_1 ;return;Normal #1;Check that frames are discarded and reinstananted correctly
dot.junit.opcodes.opc_return.Main_testVFE1;dot.junit.opcodes.opc_return.d.T_opc_return_5 ;return;Verifier #1; Constraint B11, method's return type - long
dot.junit.opcodes.opc_return.Main_testVFE2;dot.junit.opcodes.opc_return.d.T_opc_return_6 ;return;Verifier #2; Constraint B11, method's return type - reference
dot.junit.opcodes.opc_return.Main_testVFE3;dot.junit.opcodes.opc_return.d.T_opc_return_7 ;return;Verifier #3; Constraint A23, number of registers
dot.junit.opcodes.opc_return.Main_testVFE4;dot.junit.opcodes.opc_return.d.T_opc_return_8 ;return;Verifier #4; Constraint B1, return on wide register pair
dot.junit.opcodes.opc_throw.Main_testE1;dot.junit.opcodes.opc_throw.d.T_opc_throw_4 ;throw;Exception #1;NullPointerException If objectref is null, opc_throw throws a NullPointerException instead of objectref
dot.junit.opcodes.opc_throw.Main_testE2;dot.junit.opcodes.opc_throw.d.T_opc_throw_5 ;throw;Exception #2;Expected IllegalMonitorStateException
dot.junit.opcodes.opc_throw.Main_testN1;dot.junit.opcodes.opc_throw.d.T_opc_throw_1 ;throw;Normal #1;Check throw functionality. This test also tests constraint C17 allowing to have throw as a last opcode in the method.
dot.junit.opcodes.opc_throw.Main_testN2;dot.junit.opcodes.opc_throw.d.T_opc_throw_2 ;throw;Normal #2;Throwing of the objectref on the class Throwable
dot.junit.opcodes.opc_throw.Main_testN3;dot.junit.opcodes.opc_throw.d.T_opc_throw_8 ;throw;Normal #3;Throwing of the objectref on the subclass of Throwable
dot.junit.opcodes.opc_throw.Main_testN4;dot.junit.opcodes.opc_throw.d.T_opc_throw_12 ;throw;Normal #4;Nearest matching catch must be executed in case of exception
dot.junit.opcodes.opc_throw.Main_testVFE2;dot.junit.opcodes.opc_throw.d.T_opc_throw_6 ;throw;Verifier #2; Constraint A23, (number of registers)
dot.junit.opcodes.opc_throw.Main_testVFE3;dot.junit.opcodes.opc_throw.d.T_opc_throw_7 ;throw;Verifier #3; Constraint B1, type of argument - float
dot.junit.opcodes.opc_throw.Main_testVFE4;dot.junit.opcodes.opc_throw.d.T_opc_throw_7 ;throw;Verifier #4; Constraint B1, type of argument - long
dot.junit.opcodes.opc_throw.Main_testVFE5;dot.junit.opcodes.opc_throw.d.T_opc_throw_10 ;throw;Verifier #5; Constraint B16, operand must be must be assignment-compatible  with java.lang.Throwable
dot.junit.opcodes.or_int_2addr.Main_testB1;dot.junit.opcodes.or_int_2addr.d.T_or_int_2addr_1 ;or-int/2addr;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.or_int_2addr.Main_testB2;dot.junit.opcodes.or_int_2addr.d.T_or_int_2addr_1 ;or-int/2addr;Boundary #2;Arguments = Integer.MAX_VALUE & Integer.MIN_VALUE
dot.junit.opcodes.or_int_2addr.Main_testN1;dot.junit.opcodes.or_int_2addr.d.T_or_int_2addr_1 ;or-int/2addr;Normal #1;Arguments = 15, 8
dot.junit.opcodes.or_int_2addr.Main_testN2;dot.junit.opcodes.or_int_2addr.d.T_or_int_2addr_1 ;or-int/2addr;Normal #2;Arguments = 0xfffffff8, 0xfffffff1
dot.junit.opcodes.or_int_2addr.Main_testN3;dot.junit.opcodes.or_int_2addr.d.T_or_int_2addr_1 ;or-int/2addr;Normal #3;Arguments = 0xcafe & -1
dot.junit.opcodes.or_int_2addr.Main_testN4;dot.junit.opcodes.or_int_2addr.d.T_or_int_2addr_6 ;or-int/2addr;Normal #4;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.or_int_2addr.Main_testVFE1;dot.junit.opcodes.or_int_2addr.d.T_or_int_2addr_2 ;or-int/2addr;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.or_int_2addr.Main_testVFE2;dot.junit.opcodes.or_int_2addr.d.T_or_int_2addr_3 ;or-int/2addr;Verifier #2; Constraint B1, types of arguments - double & int
dot.junit.opcodes.or_int_2addr.Main_testVFE3;dot.junit.opcodes.or_int_2addr.d.T_or_int_2addr_4 ;or-int/2addr;Verifier #3; Constraint B1, types of arguments - long & int
dot.junit.opcodes.or_int_2addr.Main_testVFE4;dot.junit.opcodes.or_int_2addr.d.T_or_int_2addr_5 ;or-int/2addr;Verifier #4; Constraint B1, types of arguments - reference & int
dot.junit.opcodes.or_int_lit16.Main_testB1;dot.junit.opcodes.or_int_lit16.d.T_or_int_lit16_3 ;or-int/lit16;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.or_int_lit16.Main_testB2;dot.junit.opcodes.or_int_lit16.d.T_or_int_lit16_5 ;or-int/lit16;Boundary #2;Arguments = Short.MAX_VALUE & Short.MIN_VALUE
dot.junit.opcodes.or_int_lit16.Main_testN1;dot.junit.opcodes.or_int_lit16.d.T_or_int_lit16_1 ;or-int/lit16;Normal #1;Arguments = 15, 8
dot.junit.opcodes.or_int_lit16.Main_testN2;dot.junit.opcodes.or_int_lit16.d.T_or_int_lit16_2 ;or-int/lit16;Normal #2;Arguments = 0x5ff5, 0x7ff7
dot.junit.opcodes.or_int_lit16.Main_testN3;dot.junit.opcodes.or_int_lit16.d.T_or_int_lit16_3 ;or-int/lit16;Normal #3;Arguments = 0xcafe & -1
dot.junit.opcodes.or_int_lit16.Main_testN4;dot.junit.opcodes.or_int_lit16.d.T_or_int_lit16_4 ;or-int/lit16;Normal #4;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.or_int_lit16.Main_testVFE1;dot.junit.opcodes.or_int_lit16.d.T_or_int_lit16_6 ;or-int/lit16;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.or_int_lit16.Main_testVFE2;dot.junit.opcodes.or_int_lit16.d.T_or_int_lit16_7 ;or-int/lit16;Verifier #2; Constraint B1, types of arguments - double & int
dot.junit.opcodes.or_int_lit16.Main_testVFE3;dot.junit.opcodes.or_int_lit16.d.T_or_int_lit16_8 ;or-int/lit16;Verifier #3; Constraint B1, types of arguments - long & int
dot.junit.opcodes.or_int_lit16.Main_testVFE4;dot.junit.opcodes.or_int_lit16.d.T_or_int_lit16_9 ;or-int/lit16;Verifier #4; Constraint B1, types of arguments - reference & int
dot.junit.opcodes.or_int_lit8.Main_testB1;dot.junit.opcodes.or_int_lit8.d.T_or_int_lit8_3 ;or-int/lit8;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.or_int_lit8.Main_testB2;dot.junit.opcodes.or_int_lit8.d.T_or_int_lit8_5 ;or-int/lit8;Boundary #2;Arguments = Short.MAX_VALUE & Short.MIN_VALUE
dot.junit.opcodes.or_int_lit8.Main_testN1;dot.junit.opcodes.or_int_lit8.d.T_or_int_lit8_1 ;or-int/lit8;Normal #1;Arguments = 15, 8
dot.junit.opcodes.or_int_lit8.Main_testN2;dot.junit.opcodes.or_int_lit8.d.T_or_int_lit8_2 ;or-int/lit8;Normal #2;Arguments = 0x5f, 0x7f
dot.junit.opcodes.or_int_lit8.Main_testN3;dot.junit.opcodes.or_int_lit8.d.T_or_int_lit8_3 ;or-int/lit8;Normal #3;Arguments = 0xcafe & -1
dot.junit.opcodes.or_int_lit8.Main_testN4;dot.junit.opcodes.or_int_lit8.d.T_or_int_lit8_4 ;or-int/lit8;Normal #4;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.or_int_lit8.Main_testVFE1;dot.junit.opcodes.or_int_lit8.d.T_or_int_lit8_6 ;or-int/lit8;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.or_int_lit8.Main_testVFE2;dot.junit.opcodes.or_int_lit8.d.T_or_int_lit8_7 ;or-int/lit8;Verifier #2; Constraint B1, types of arguments - double & int
dot.junit.opcodes.or_int_lit8.Main_testVFE3;dot.junit.opcodes.or_int_lit8.d.T_or_int_lit8_8 ;or-int/lit8;Verifier #3; Constraint B1, types of arguments - long & int
dot.junit.opcodes.or_int_lit8.Main_testVFE4;dot.junit.opcodes.or_int_lit8.d.T_or_int_lit8_9 ;or-int/lit8;Verifier #4; Constraint B1, types of arguments - reference & int
dot.junit.opcodes.or_int.Main_testB1;dot.junit.opcodes.or_int.d.T_or_int_1 ;or-int;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.or_int.Main_testB2;dot.junit.opcodes.or_int.d.T_or_int_1 ;or-int;Boundary #2;Arguments = Integer.MAX_VALUE & Integer.MIN_VALUE
dot.junit.opcodes.or_int.Main_testN1;dot.junit.opcodes.or_int.d.T_or_int_1 ;or-int;Normal #1;Arguments = 15, 8
dot.junit.opcodes.or_int.Main_testN2;dot.junit.opcodes.or_int.d.T_or_int_1 ;or-int;Normal #2;Arguments = 0xfffffff8, 0xfffffff1
dot.junit.opcodes.or_int.Main_testN3;dot.junit.opcodes.or_int.d.T_or_int_1 ;or-int;Normal #3;Arguments = 0xcafe & -1
dot.junit.opcodes.or_int.Main_testN4;dot.junit.opcodes.or_int.d.T_or_int_6 ;or-int;Normal #4;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.or_int.Main_testVFE1;dot.junit.opcodes.or_int.d.T_or_int_2 ;or-int;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.or_int.Main_testVFE2;dot.junit.opcodes.or_int.d.T_or_int_3 ;or-int;Verifier #2; Constraint B1, types of arguments - double & int
dot.junit.opcodes.or_int.Main_testVFE3;dot.junit.opcodes.or_int.d.T_or_int_4 ;or-int;Verifier #3; Constraint B1, types of arguments - long & int
dot.junit.opcodes.or_int.Main_testVFE4;dot.junit.opcodes.or_int.d.T_or_int_5 ;or-int;Verifier #4; Constraint B1, types of arguments - reference & int
dot.junit.opcodes.or_long_2addr.Main_testB1;dot.junit.opcodes.or_long_2addr.d.T_or_long_2addr_1 ;or-long/2addr;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.or_long_2addr.Main_testB2;dot.junit.opcodes.or_long_2addr.d.T_or_long_2addr_1 ;or-long/2addr;Boundary #2;Arguments = Long.MAX_VALUE & Long.MIN_VALUE
dot.junit.opcodes.or_long_2addr.Main_testN1;dot.junit.opcodes.or_long_2addr.d.T_or_long_2addr_1 ;or-long/2addr;Normal #1;Arguments = 123456789121l, 2l
dot.junit.opcodes.or_long_2addr.Main_testN2;dot.junit.opcodes.or_long_2addr.d.T_or_long_2addr_1 ;or-long/2addr;Normal #2;Arguments = 0xffffffffffffff8l, 0xffffffffffffff1l
dot.junit.opcodes.or_long_2addr.Main_testN3;dot.junit.opcodes.or_long_2addr.d.T_or_long_2addr_1 ;or-long/2addr;Normal #3;Arguments = 0xabcdefabcdef & -1
dot.junit.opcodes.or_long_2addr.Main_testN4;dot.junit.opcodes.or_long_2addr.d.T_or_long_2addr_3 ;or-long/2addr;Normal #4;Types of arguments - double, long. Dalvik doens't distinguish 64-bits types internally, so this operation of double and long makes no sense but shall not crash the VM.
dot.junit.opcodes.or_long_2addr.Main_testVFE1;dot.junit.opcodes.or_long_2addr.d.T_or_long_2addr_2 ;or-long/2addr;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.or_long_2addr.Main_testVFE2;dot.junit.opcodes.or_long_2addr.d.T_or_long_2addr_4 ;or-long/2addr;Verifier #2; Constraint B1, types of arguments - int & long
dot.junit.opcodes.or_long_2addr.Main_testVFE3;dot.junit.opcodes.or_long_2addr.d.T_or_long_2addr_5 ;or-long/2addr;Verifier #3; Constraint B1, types of arguments - float & long
dot.junit.opcodes.or_long_2addr.Main_testVFE4;dot.junit.opcodes.or_long_2addr.d.T_or_long_2addr_6 ;or-long/2addr;Verifier #4; Constraint B1, types of arguments - reference & long
dot.junit.opcodes.or_long.Main_testB1;dot.junit.opcodes.or_long.d.T_or_long_1 ;or-long;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.or_long.Main_testB2;dot.junit.opcodes.or_long.d.T_or_long_1 ;or-long;Boundary #2;Arguments = Long.MAX_VALUE & Long.MIN_VALUE
dot.junit.opcodes.or_long.Main_testN1;dot.junit.opcodes.or_long.d.T_or_long_1 ;or-long;Normal #1;Arguments = 123456789121l, 2l
dot.junit.opcodes.or_long.Main_testN2;dot.junit.opcodes.or_long.d.T_or_long_1 ;or-long;Normal #2;Arguments = 0xffffffffffffff8l, 0xffffffffffffff1l
dot.junit.opcodes.or_long.Main_testN3;dot.junit.opcodes.or_long.d.T_or_long_1 ;or-long;Normal #3;Arguments = 0xabcdefabcdef & -1
dot.junit.opcodes.or_long.Main_testN4;dot.junit.opcodes.or_long.d.T_or_long_3 ;or-long;Normal #4;Types of arguments - double, long. Dalvik doens't distinguish 64-bits types internally, so this operation of double and long makes no sense but shall not crash the VM.
dot.junit.opcodes.or_long.Main_testVFE1;dot.junit.opcodes.or_long.d.T_or_long_2 ;or-long;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.or_long.Main_testVFE2;dot.junit.opcodes.or_long.d.T_or_long_4 ;or-long;Verifier #2; Constraint B1, types of arguments - int & long
dot.junit.opcodes.or_long.Main_testVFE3;dot.junit.opcodes.or_long.d.T_or_long_5 ;or-long;Verifier #3; Constraint B1, types of arguments - float & long
dot.junit.opcodes.or_long.Main_testVFE4;dot.junit.opcodes.or_long.d.T_or_long_6 ;or-long;Verifier #4; Constraint B1, types of arguments - reference & long
dot.junit.opcodes.packed_switch.Main_testB1;dot.junit.opcodes.packed_switch.d.T_packed_switch_1 ;packed-switch;Boundary #1;Argument = Integer.MAX_VALUE
dot.junit.opcodes.packed_switch.Main_testB2;dot.junit.opcodes.packed_switch.d.T_packed_switch_1 ;packed-switch;Boundary #2;Argument = Integer.MIN_VALUE
dot.junit.opcodes.packed_switch.Main_testB3;dot.junit.opcodes.packed_switch.d.T_packed_switch_1 ;packed-switch;Boundary #3;Argument = 0
dot.junit.opcodes.packed_switch.Main_testN1;dot.junit.opcodes.packed_switch.d.T_packed_switch_1 ;packed-switch;Normal #1;Try different values
dot.junit.opcodes.packed_switch.Main_testN2;dot.junit.opcodes.packed_switch.d.T_packed_switch_2 ;packed-switch;Normal #2;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.packed_switch.Main_testVFE1;dot.junit.opcodes.packed_switch.d.T_packed_switch_3 ;packed-switch;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.packed_switch.Main_testVFE10;dot.junit.opcodes.packed_switch.d.T_packed_switch_12 ;packed-switch;Verifier #10; Constraint B22, packed-switch-data pseudo-instructions must not be reachable by control flow
dot.junit.opcodes.packed_switch.Main_testVFE11;dot.junit.opcodes.packed_switch.d.T_packed_switch_13 ;packed-switch;Verifier #11; Constraint A7, table has wrong ident code
dot.junit.opcodes.packed_switch.Main_testVFE2;dot.junit.opcodes.packed_switch.d.T_packed_switch_4 ;packed-switch;Verifier #2; Constraint B1, type of argument - double
dot.junit.opcodes.packed_switch.Main_testVFE3;dot.junit.opcodes.packed_switch.d.T_packed_switch_5 ;packed-switch;Verifier #3; Constraint B1, type of argument - long
dot.junit.opcodes.packed_switch.Main_testVFE4;dot.junit.opcodes.packed_switch.d.T_packed_switch_6 ;packed-switch;Verifier #4; Constraint B1, type of argument - reference
dot.junit.opcodes.packed_switch.Main_testVFE5;dot.junit.opcodes.packed_switch.d.T_packed_switch_7 ;packed-switch;Verifier #5; Constraint A7, branch target shall be inside the method
dot.junit.opcodes.packed_switch.Main_testVFE6;dot.junit.opcodes.packed_switch.d.T_packed_switch_8 ;packed-switch;Verifier #6; Constraint A7, branch target shall not be "inside" instruction
dot.junit.opcodes.packed_switch.Main_testVFE7;dot.junit.opcodes.packed_switch.d.T_packed_switch_9 ;packed-switch;Verifier #7; Constraint A7, offset to table shall be inside method
dot.junit.opcodes.packed_switch.Main_testVFE9;dot.junit.opcodes.packed_switch.d.T_packed_switch_11 ;packed-switch;Verifier #9; Constraint A7, the size and the list of targets must be consistent.
dot.junit.opcodes.rem_double_2addr.Main_testB1;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_1 ;rem-double/2addr;Boundary #1;Arguments = Double.MAX_VALUE, Double.NaN
dot.junit.opcodes.rem_double_2addr.Main_testB2;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_1 ;rem-double/2addr;Boundary #2;Arguments = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
dot.junit.opcodes.rem_double_2addr.Main_testB3;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_1 ;rem-double/2addr;Boundary #3;Arguments = Double.POSITIVE_INFINITY, -2.7d
dot.junit.opcodes.rem_double_2addr.Main_testB4;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_1 ;rem-double/2addr;Boundary #4;Arguments = -2.7d, Double.NEGATIVE_INFINITY
dot.junit.opcodes.rem_double_2addr.Main_testB5;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_1 ;rem-double/2addr;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.rem_double_2addr.Main_testB6;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_1 ;rem-double/2addr;Boundary #6;Arguments = 0, -2.7
dot.junit.opcodes.rem_double_2addr.Main_testB7;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_1 ;rem-double/2addr;Boundary #7;Arguments = -2.7, 0
dot.junit.opcodes.rem_double_2addr.Main_testB8;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_1 ;rem-double/2addr;Boundary #8;Arguments = 1, Double.MAX_VALUE
dot.junit.opcodes.rem_double_2addr.Main_testB9;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_1 ;rem-double/2addr;Boundary #9;Arguments = Double.MAX_VALUE, -1E-9d
dot.junit.opcodes.rem_double_2addr.Main_testN1;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_1 ;rem-double/2addr;Normal #1;Arguments = 2.7d, 3.14d
dot.junit.opcodes.rem_double_2addr.Main_testN2;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_1 ;rem-double/2addr;Normal #2;Dividend = 0
dot.junit.opcodes.rem_double_2addr.Main_testN3;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_1 ;rem-double/2addr;Normal #3;Dividend is negative
dot.junit.opcodes.rem_double_2addr.Main_testN4;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_4 ;rem-double/2addr;Normal #4;Types of arguments - double, long. Dalvik doens't distinguish 64-bits types internally, so this operation of double and long makes no sense but shall not crash the VM.
dot.junit.opcodes.rem_double_2addr.Main_testVFE1;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_2 ;rem-double/2addr;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.rem_double_2addr.Main_testVFE2;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_3 ;rem-double/2addr;Verifier #2; Constraint B1, types of arguments - float, double
dot.junit.opcodes.rem_double_2addr.Main_testVFE3;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_5 ;rem-double/2addr;Verifier #3; Constraint B1, types of arguments - double, reference
dot.junit.opcodes.rem_double_2addr.Main_testVFE4;dot.junit.opcodes.rem_double_2addr.d.T_rem_double_2addr_6 ;rem-double/2addr;Verifier #4; Constraint B1, types of arguments - double, int
dot.junit.opcodes.rem_double.Main_testB1;dot.junit.opcodes.rem_double.d.T_rem_double_1 ;rem-double;Boundary #1;Arguments = Double.MAX_VALUE, Double.NaN
dot.junit.opcodes.rem_double.Main_testB2;dot.junit.opcodes.rem_double.d.T_rem_double_1 ;rem-double;Boundary #2;Arguments = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
dot.junit.opcodes.rem_double.Main_testB3;dot.junit.opcodes.rem_double.d.T_rem_double_1 ;rem-double;Boundary #3;Arguments = Double.POSITIVE_INFINITY, -2.7d
dot.junit.opcodes.rem_double.Main_testB4;dot.junit.opcodes.rem_double.d.T_rem_double_1 ;rem-double;Boundary #4;Arguments = -2.7d, Double.NEGATIVE_INFINITY
dot.junit.opcodes.rem_double.Main_testB5;dot.junit.opcodes.rem_double.d.T_rem_double_1 ;rem-double;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.rem_double.Main_testB6;dot.junit.opcodes.rem_double.d.T_rem_double_1 ;rem-double;Boundary #6;Arguments = 0, -2.7
dot.junit.opcodes.rem_double.Main_testB7;dot.junit.opcodes.rem_double.d.T_rem_double_1 ;rem-double;Boundary #7;Arguments = -2.7, 0
dot.junit.opcodes.rem_double.Main_testB8;dot.junit.opcodes.rem_double.d.T_rem_double_1 ;rem-double;Boundary #8;Arguments = 1, Double.MAX_VALUE
dot.junit.opcodes.rem_double.Main_testB9;dot.junit.opcodes.rem_double.d.T_rem_double_1 ;rem-double;Boundary #9;Arguments = Double.MAX_VALUE, -1E-9d
dot.junit.opcodes.rem_double.Main_testN1;dot.junit.opcodes.rem_double.d.T_rem_double_1 ;rem-double;Normal #1;Arguments = 2.7d, 3.14d
dot.junit.opcodes.rem_double.Main_testN2;dot.junit.opcodes.rem_double.d.T_rem_double_1 ;rem-double;Normal #2;Dividend = 0
dot.junit.opcodes.rem_double.Main_testN3;dot.junit.opcodes.rem_double.d.T_rem_double_1 ;rem-double;Normal #3;Dividend is negative
dot.junit.opcodes.rem_double.Main_testN4;dot.junit.opcodes.rem_double.d.T_rem_double_4 ;rem-double;Normal #4;Types of arguments - double, long. Dalvik doens't distinguish 64-bits types internally, so this operation of double and long makes no sense but shall not crash the VM.
dot.junit.opcodes.rem_double.Main_testVFE1;dot.junit.opcodes.rem_double.d.T_rem_double_2 ;rem-double;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.rem_double.Main_testVFE2;dot.junit.opcodes.rem_double.d.T_rem_double_3 ;rem-double;Verifier #2; Constraint B1, types of arguments - float, double
dot.junit.opcodes.rem_double.Main_testVFE3;dot.junit.opcodes.rem_double.d.T_rem_double_5 ;rem-double;Verifier #3; Constraint B1, types of arguments - double, reference
dot.junit.opcodes.rem_double.Main_testVFE4;dot.junit.opcodes.rem_double.d.T_rem_double_6 ;rem-double;Verifier #4; Constraint B1, types of arguments - double, int
dot.junit.opcodes.rem_float_2addr.Main_testB1;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_1 ;rem-float/2addr;Boundary #1;Arguments = Float.MAX_VALUE, Float.NaN
dot.junit.opcodes.rem_float_2addr.Main_testB2;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_1 ;rem-float/2addr;Boundary #2;Arguments = Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY
dot.junit.opcodes.rem_float_2addr.Main_testB3;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_1 ;rem-float/2addr;Boundary #3;Arguments = Float.POSITIVE_INFINITY, -2.7f
dot.junit.opcodes.rem_float_2addr.Main_testB4;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_1 ;rem-float/2addr;Boundary #4;Arguments = -2.7f, Float.NEGATIVE_INFINITY
dot.junit.opcodes.rem_float_2addr.Main_testB5;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_1 ;rem-float/2addr;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.rem_float_2addr.Main_testB6;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_1 ;rem-float/2addr;Boundary #6;Arguments = 0, -2.7
dot.junit.opcodes.rem_float_2addr.Main_testB7;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_1 ;rem-float/2addr;Boundary #7;Arguments = -2.7, 0
dot.junit.opcodes.rem_float_2addr.Main_testB8;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_1 ;rem-float/2addr;Boundary #8;Arguments = 1, Float.MAX_VALUE
dot.junit.opcodes.rem_float_2addr.Main_testB9;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_1 ;rem-float/2addr;Boundary #9;Arguments = Float.MAX_VALUE, -1E-9f
dot.junit.opcodes.rem_float_2addr.Main_testN1;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_1 ;rem-float/2addr;Normal #1;Arguments = 2.7f, 3.14f
dot.junit.opcodes.rem_float_2addr.Main_testN2;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_1 ;rem-float/2addr;Normal #2;Dividend = 0
dot.junit.opcodes.rem_float_2addr.Main_testN3;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_1 ;rem-float/2addr;Normal #3;Dividend is negative
dot.junit.opcodes.rem_float_2addr.Main_testN4;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_6 ;rem-float/2addr;Normal #4;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.rem_float_2addr.Main_testVFE1;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_2 ;rem-float/2addr;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.rem_float_2addr.Main_testVFE2;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_3 ;rem-float/2addr;Verifier #2; Constraint B1, types of arguments - float, double
dot.junit.opcodes.rem_float_2addr.Main_testVFE3;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_4 ;rem-float/2addr;Verifier #3; Constraint B1, types of arguments - long, float
dot.junit.opcodes.rem_float_2addr.Main_testVFE4;dot.junit.opcodes.rem_float_2addr.d.T_rem_float_2addr_5 ;rem-float/2addr;Verifier #4; Constraint B1, types of arguments - reference, float
dot.junit.opcodes.rem_float.Main_testB1;dot.junit.opcodes.rem_float.d.T_rem_float_1 ;rem-float;Boundary #1;Arguments = Float.MAX_VALUE, Float.NaN
dot.junit.opcodes.rem_float.Main_testB2;dot.junit.opcodes.rem_float.d.T_rem_float_1 ;rem-float;Boundary #2;Arguments = Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY
dot.junit.opcodes.rem_float.Main_testB3;dot.junit.opcodes.rem_float.d.T_rem_float_1 ;rem-float;Boundary #3;Arguments = Float.POSITIVE_INFINITY, -2.7f
dot.junit.opcodes.rem_float.Main_testB4;dot.junit.opcodes.rem_float.d.T_rem_float_1 ;rem-float;Boundary #4;Arguments = -2.7f, Float.NEGATIVE_INFINITY
dot.junit.opcodes.rem_float.Main_testB5;dot.junit.opcodes.rem_float.d.T_rem_float_1 ;rem-float;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.rem_float.Main_testB6;dot.junit.opcodes.rem_float.d.T_rem_float_1 ;rem-float;Boundary #6;Arguments = 0, -2.7
dot.junit.opcodes.rem_float.Main_testB7;dot.junit.opcodes.rem_float.d.T_rem_float_1 ;rem-float;Boundary #7;Arguments = -2.7, 0
dot.junit.opcodes.rem_float.Main_testB8;dot.junit.opcodes.rem_float.d.T_rem_float_1 ;rem-float;Boundary #8;Arguments = 1, Float.MAX_VALUE
dot.junit.opcodes.rem_float.Main_testB9;dot.junit.opcodes.rem_float.d.T_rem_float_1 ;rem-float;Boundary #9;Arguments = Float.MAX_VALUE, -1E-9f
dot.junit.opcodes.rem_float.Main_testN1;dot.junit.opcodes.rem_float.d.T_rem_float_1 ;rem-float;Normal #1;Arguments = 2.7f, 3.14f
dot.junit.opcodes.rem_float.Main_testN2;dot.junit.opcodes.rem_float.d.T_rem_float_1 ;rem-float;Normal #2;Dividend = 0
dot.junit.opcodes.rem_float.Main_testN3;dot.junit.opcodes.rem_float.d.T_rem_float_1 ;rem-float;Normal #3;Dividend is negative
dot.junit.opcodes.rem_float.Main_testN4;dot.junit.opcodes.rem_float.d.T_rem_float_6 ;rem-float;Normal #4;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.rem_float.Main_testVFE1;dot.junit.opcodes.rem_float.d.T_rem_float_2 ;rem-float;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.rem_float.Main_testVFE2;dot.junit.opcodes.rem_float.d.T_rem_float_3 ;rem-float;Verifier #2; Constraint B1, types of arguments - float, double
dot.junit.opcodes.rem_float.Main_testVFE3;dot.junit.opcodes.rem_float.d.T_rem_float_4 ;rem-float;Verifier #3; Constraint B1, types of arguments - long, float
dot.junit.opcodes.rem_float.Main_testVFE4;dot.junit.opcodes.rem_float.d.T_rem_float_5 ;rem-float;Verifier #4; Constraint B1, types of arguments - reference, float
dot.junit.opcodes.rem_int_2addr.Main_testB1;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_1 ;rem-int/2addr;Boundary #1;Arguments = Integer.MIN_VALUE, -1
dot.junit.opcodes.rem_int_2addr.Main_testB2;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_1 ;rem-int/2addr;Boundary #2;Arguments = Integer.MIN_VALUE, 1
dot.junit.opcodes.rem_int_2addr.Main_testB3;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_1 ;rem-int/2addr;Boundary #3;Arguments = Integer.MAX_VALUE, 1
dot.junit.opcodes.rem_int_2addr.Main_testB4;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_1 ;rem-int/2addr;Boundary #4;Arguments = Integer.MIN_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.rem_int_2addr.Main_testB5;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_1 ;rem-int/2addr;Boundary #5;Arguments = 1, Integer.MAX_VALUE
dot.junit.opcodes.rem_int_2addr.Main_testB6;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_1 ;rem-int/2addr;Boundary #6;Arguments = 1, Integer.MIN_VALUE
dot.junit.opcodes.rem_int_2addr.Main_testE1;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_1 ;rem-int/2addr;Exception #1;Divisor is 0
dot.junit.opcodes.rem_int_2addr.Main_testN1;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_1 ;rem-int/2addr;Normal #1;Arguments = 8, 4
dot.junit.opcodes.rem_int_2addr.Main_testN2;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_1 ;rem-int/2addr;Normal #2;Arguments = 1073741823, 4
dot.junit.opcodes.rem_int_2addr.Main_testN3;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_1 ;rem-int/2addr;Normal #3;Dividend = 0
dot.junit.opcodes.rem_int_2addr.Main_testN4;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_1 ;rem-int/2addr;Normal #4;Dividend is negative
dot.junit.opcodes.rem_int_2addr.Main_testN5;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_1 ;rem-int/2addr;Normal #5;Divisor is negative
dot.junit.opcodes.rem_int_2addr.Main_testN6;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_1 ;rem-int/2addr;Normal #6;Both Dividend and divisor are negative
dot.junit.opcodes.rem_int_2addr.Main_testN7;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_6 ;rem-int/2addr;Normal #7;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.rem_int_2addr.Main_testVFE1;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_2 ;rem-int/2addr;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.rem_int_2addr.Main_testVFE2;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_3 ;rem-int/2addr;Verifier #2; Constraint B1, types of arguments - int, double
dot.junit.opcodes.rem_int_2addr.Main_testVFE3;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_4 ;rem-int/2addr;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.rem_int_2addr.Main_testVFE4;dot.junit.opcodes.rem_int_2addr.d.T_rem_int_2addr_5 ;rem-int/2addr;Verifier #4; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.rem_int_lit16.Main_testB1;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_5 ;rem-int/lit16;Boundary #1;Arguments = Short.MIN_VALUE, -1
dot.junit.opcodes.rem_int_lit16.Main_testB2;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_6 ;rem-int/lit16;Boundary #2;Arguments = Short.MIN_VALUE, 1
dot.junit.opcodes.rem_int_lit16.Main_testB3;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_6 ;rem-int/lit16;Boundary #3;Arguments = Short.MAX_VALUE, 1
dot.junit.opcodes.rem_int_lit16.Main_testB4;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_7 ;rem-int/lit16;Boundary #4;Arguments = Short.MIN_VALUE, 32767
dot.junit.opcodes.rem_int_lit16.Main_testB5;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_7 ;rem-int/lit16;Boundary #5;Arguments = 1, 32767
dot.junit.opcodes.rem_int_lit16.Main_testB6;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_8 ;rem-int/lit16;Boundary #6;Arguments = 1, -32768
dot.junit.opcodes.rem_int_lit16.Main_testE1;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_9 ;rem-int/lit16;Exception #1;Divisor is 0
dot.junit.opcodes.rem_int_lit16.Main_testN1;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_1 ;rem-int/lit16;Normal #1;Arguments = 8, 4
dot.junit.opcodes.rem_int_lit16.Main_testN2;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_1 ;rem-int/lit16;Normal #2;Arguments = 10737, 4
dot.junit.opcodes.rem_int_lit16.Main_testN3;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_1 ;rem-int/lit16;Normal #3;Dividend = 0
dot.junit.opcodes.rem_int_lit16.Main_testN4;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_1 ;rem-int/lit16;Normal #4;Dividend is negative
dot.junit.opcodes.rem_int_lit16.Main_testN5;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_2 ;rem-int/lit16;Normal #5;Divisor is negative
dot.junit.opcodes.rem_int_lit16.Main_testN6;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_3 ;rem-int/lit16;Normal #6;Both Dividend and divisor are negative
dot.junit.opcodes.rem_int_lit16.Main_testN7;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_4 ;rem-int/lit16;Normal #7;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.rem_int_lit16.Main_testVFE1;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_10 ;rem-int/lit16;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.rem_int_lit16.Main_testVFE2;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_11 ;rem-int/lit16;Verifier #2; Constraint B1, types of arguments - int, double
dot.junit.opcodes.rem_int_lit16.Main_testVFE3;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_12 ;rem-int/lit16;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.rem_int_lit16.Main_testVFE4;dot.junit.opcodes.rem_int_lit16.d.T_rem_int_lit16_13 ;rem-int/lit16;Verifier #4; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.rem_int_lit8.Main_testB1;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_5 ;rem-int/lit8;Boundary #1;Arguments = Byte.MIN_VALUE, -1
dot.junit.opcodes.rem_int_lit8.Main_testB2;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_6 ;rem-int/lit8;Boundary #2;Arguments = Byte.MIN_VALUE, 1
dot.junit.opcodes.rem_int_lit8.Main_testB3;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_6 ;rem-int/lit8;Boundary #3;Arguments = Byte.MAX_VALUE, 1
dot.junit.opcodes.rem_int_lit8.Main_testB4;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_7 ;rem-int/lit8;Boundary #4;Arguments = Short.MIN_VALUE, 127
dot.junit.opcodes.rem_int_lit8.Main_testB5;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_7 ;rem-int/lit8;Boundary #5;Arguments = 1, 127
dot.junit.opcodes.rem_int_lit8.Main_testB6;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_8 ;rem-int/lit8;Boundary #6;Arguments = 1, -128
dot.junit.opcodes.rem_int_lit8.Main_testE1;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_9 ;rem-int/lit8;Exception #1;Divisor is 0
dot.junit.opcodes.rem_int_lit8.Main_testN1;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_1 ;rem-int/lit8;Normal #1;Arguments = 8, 4
dot.junit.opcodes.rem_int_lit8.Main_testN2;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_1 ;rem-int/lit8;Normal #2;Arguments = 123, 4
dot.junit.opcodes.rem_int_lit8.Main_testN3;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_1 ;rem-int/lit8;Normal #3;Dividend = 0
dot.junit.opcodes.rem_int_lit8.Main_testN4;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_1 ;rem-int/lit8;Normal #4;Dividend is negative
dot.junit.opcodes.rem_int_lit8.Main_testN5;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_2 ;rem-int/lit8;Normal #5;Divisor is negative
dot.junit.opcodes.rem_int_lit8.Main_testN6;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_3 ;rem-int/lit8;Normal #6;Both Dividend and divisor are negative
dot.junit.opcodes.rem_int_lit8.Main_testN7;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_4 ;rem-int/lit8;Normal #7;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.rem_int_lit8.Main_testVFE1;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_10 ;rem-int/lit8;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.rem_int_lit8.Main_testVFE2;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_11 ;rem-int/lit8;Verifier #2; Constraint B1, types of arguments - int, double
dot.junit.opcodes.rem_int_lit8.Main_testVFE3;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_12 ;rem-int/lit8;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.rem_int_lit8.Main_testVFE4;dot.junit.opcodes.rem_int_lit8.d.T_rem_int_lit8_13 ;rem-int/lit8;Verifier #4; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.rem_int.Main_testB1;dot.junit.opcodes.rem_int.d.T_rem_int_1 ;rem-int;Boundary #1;Arguments = Integer.MIN_VALUE, -1
dot.junit.opcodes.rem_int.Main_testB2;dot.junit.opcodes.rem_int.d.T_rem_int_1 ;rem-int;Boundary #2;Arguments = Integer.MIN_VALUE, 1
dot.junit.opcodes.rem_int.Main_testB3;dot.junit.opcodes.rem_int.d.T_rem_int_1 ;rem-int;Boundary #3;Arguments = Integer.MAX_VALUE, 1
dot.junit.opcodes.rem_int.Main_testB4;dot.junit.opcodes.rem_int.d.T_rem_int_1 ;rem-int;Boundary #4;Arguments = Integer.MIN_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.rem_int.Main_testB5;dot.junit.opcodes.rem_int.d.T_rem_int_1 ;rem-int;Boundary #5;Arguments = 1, Integer.MAX_VALUE
dot.junit.opcodes.rem_int.Main_testB6;dot.junit.opcodes.rem_int.d.T_rem_int_1 ;rem-int;Boundary #6;Arguments = 1, Integer.MIN_VALUE
dot.junit.opcodes.rem_int.Main_testE1;dot.junit.opcodes.rem_int.d.T_rem_int_1 ;rem-int;Exception #1;Divisor is 0
dot.junit.opcodes.rem_int.Main_testN1;dot.junit.opcodes.rem_int.d.T_rem_int_1 ;rem-int;Normal #1;Arguments = 8, 4
dot.junit.opcodes.rem_int.Main_testN2;dot.junit.opcodes.rem_int.d.T_rem_int_1 ;rem-int;Normal #2;Arguments = 1073741823, 4
dot.junit.opcodes.rem_int.Main_testN3;dot.junit.opcodes.rem_int.d.T_rem_int_1 ;rem-int;Normal #3;Dividend = 0
dot.junit.opcodes.rem_int.Main_testN4;dot.junit.opcodes.rem_int.d.T_rem_int_1 ;rem-int;Normal #4;Dividend is negative
dot.junit.opcodes.rem_int.Main_testN5;dot.junit.opcodes.rem_int.d.T_rem_int_1 ;rem-int;Normal #5;Divisor is negative
dot.junit.opcodes.rem_int.Main_testN6;dot.junit.opcodes.rem_int.d.T_rem_int_1 ;rem-int;Normal #6;Both Dividend and divisor are negative
dot.junit.opcodes.rem_int.Main_testN7;dot.junit.opcodes.rem_int.d.T_rem_int_6 ;rem-int;Normal #7;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.rem_int.Main_testVFE1;dot.junit.opcodes.rem_int.d.T_rem_int_2 ;rem-int;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.rem_int.Main_testVFE2;dot.junit.opcodes.rem_int.d.T_rem_int_3 ;rem-int;Verifier #2; Constraint B1, types of arguments - int, double
dot.junit.opcodes.rem_int.Main_testVFE3;dot.junit.opcodes.rem_int.d.T_rem_int_4 ;rem-int;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.rem_int.Main_testVFE4;dot.junit.opcodes.rem_int.d.T_rem_int_5 ;rem-int;Verifier #4; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.rem_long_2addr.Main_testB1;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_1 ;rem-long/2addr;Boundary #1;Arguments = Long.MIN_VALUE, -1l
dot.junit.opcodes.rem_long_2addr.Main_testB2;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_1 ;rem-long/2addr;Boundary #2;Arguments = Long.MIN_VALUE, 1l
dot.junit.opcodes.rem_long_2addr.Main_testB3;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_1 ;rem-long/2addr;Boundary #3;Arguments = Long.MAX_VALUE, 1l
dot.junit.opcodes.rem_long_2addr.Main_testB4;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_1 ;rem-long/2addr;Boundary #4;Arguments = Long.MIN_VALUE, Long.MAX_VALUE
dot.junit.opcodes.rem_long_2addr.Main_testB5;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_1 ;rem-long/2addr;Boundary #5;Arguments = 1l, Long.MAX_VALUE
dot.junit.opcodes.rem_long_2addr.Main_testB6;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_1 ;rem-long/2addr;Boundary #6;Arguments = 1l, Long.MIN_VALUE
dot.junit.opcodes.rem_long_2addr.Main_testE1;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_1 ;rem-long/2addr;Exception #1;Divisor is 0
dot.junit.opcodes.rem_long_2addr.Main_testN1;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_1 ;rem-long/2addr;Normal #1;Arguments = 10000000000l, 4000000000l
dot.junit.opcodes.rem_long_2addr.Main_testN2;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_1 ;rem-long/2addr;Normal #2;Arguments = 1234567890123l, 123456789l
dot.junit.opcodes.rem_long_2addr.Main_testN3;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_1 ;rem-long/2addr;Normal #3;Dividend = 0
dot.junit.opcodes.rem_long_2addr.Main_testN4;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_1 ;rem-long/2addr;Normal #4;Dividend is negative
dot.junit.opcodes.rem_long_2addr.Main_testN5;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_1 ;rem-long/2addr;Normal #5;Divisor is negative
dot.junit.opcodes.rem_long_2addr.Main_testN6;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_1 ;rem-long/2addr;Normal #6;Both Dividend and divisor are negative
dot.junit.opcodes.rem_long_2addr.Main_testN7;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_3 ;rem-long/2addr;Normal #7;Types of arguments - double, long. Dalvik doens't distinguish 64-bits types internally, so this operation of double and long makes no sense but shall not crash the VM.
dot.junit.opcodes.rem_long_2addr.Main_testVFE1;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_2 ;rem-long/2addr;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.rem_long_2addr.Main_testVFE2;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_4 ;rem-long/2addr;Verifier #2; Constraint B1, (types of arguments - int, long).
dot.junit.opcodes.rem_long_2addr.Main_testVFE3;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_5 ;rem-long/2addr;Verifier #3; Constraint B1, types of arguments - long, float
dot.junit.opcodes.rem_long_2addr.Main_testVFE4;dot.junit.opcodes.rem_long_2addr.d.T_rem_long_2addr_6 ;rem-long/2addr;Verifier #4; Constraint B1, types of arguments - reference, long
dot.junit.opcodes.rem_long.Main_testB1;dot.junit.opcodes.rem_long.d.T_rem_long_1 ;rem-long;Boundary #1;Arguments = Long.MIN_VALUE, -1l
dot.junit.opcodes.rem_long.Main_testB2;dot.junit.opcodes.rem_long.d.T_rem_long_1 ;rem-long;Boundary #2;Arguments = Long.MIN_VALUE, 1l
dot.junit.opcodes.rem_long.Main_testB3;dot.junit.opcodes.rem_long.d.T_rem_long_1 ;rem-long;Boundary #3;Arguments = Long.MAX_VALUE, 1l
dot.junit.opcodes.rem_long.Main_testB4;dot.junit.opcodes.rem_long.d.T_rem_long_1 ;rem-long;Boundary #4;Arguments = Long.MIN_VALUE, Long.MAX_VALUE
dot.junit.opcodes.rem_long.Main_testB5;dot.junit.opcodes.rem_long.d.T_rem_long_1 ;rem-long;Boundary #5;Arguments = 1l, Long.MAX_VALUE
dot.junit.opcodes.rem_long.Main_testB6;dot.junit.opcodes.rem_long.d.T_rem_long_1 ;rem-long;Boundary #6;Arguments = 1l, Long.MIN_VALUE
dot.junit.opcodes.rem_long.Main_testE1;dot.junit.opcodes.rem_long.d.T_rem_long_1 ;rem-long;Exception #1;Divisor is 0
dot.junit.opcodes.rem_long.Main_testN1;dot.junit.opcodes.rem_long.d.T_rem_long_1 ;rem-long;Normal #1;Arguments = 10000000000l, 4000000000l
dot.junit.opcodes.rem_long.Main_testN2;dot.junit.opcodes.rem_long.d.T_rem_long_1 ;rem-long;Normal #2;Arguments = 1234567890123l, 123456789l
dot.junit.opcodes.rem_long.Main_testN3;dot.junit.opcodes.rem_long.d.T_rem_long_1 ;rem-long;Normal #3;Dividend = 0
dot.junit.opcodes.rem_long.Main_testN4;dot.junit.opcodes.rem_long.d.T_rem_long_1 ;rem-long;Normal #4;Dividend is negative
dot.junit.opcodes.rem_long.Main_testN5;dot.junit.opcodes.rem_long.d.T_rem_long_1 ;rem-long;Normal #5;Divisor is negative
dot.junit.opcodes.rem_long.Main_testN6;dot.junit.opcodes.rem_long.d.T_rem_long_1 ;rem-long;Normal #6;Both Dividend and divisor are negative
dot.junit.opcodes.rem_long.Main_testN7;dot.junit.opcodes.rem_long.d.T_rem_long_3 ;rem-long;Normal #7;Types of arguments - double, long. Dalvik doens't distinguish 64-bits types internally, so this operation of double and long makes no sense but shall not crash the VM.
dot.junit.opcodes.rem_long.Main_testVFE1;dot.junit.opcodes.rem_long.d.T_rem_long_2 ;rem-long;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.rem_long.Main_testVFE2;dot.junit.opcodes.rem_long.d.T_rem_long_4 ;rem-long;Verifier #2; Constraint B1, types of arguments - int, long
dot.junit.opcodes.rem_long.Main_testVFE3;dot.junit.opcodes.rem_long.d.T_rem_long_5 ;rem-long;Verifier #3; Constraint B1, types of arguments - long, float
dot.junit.opcodes.rem_long.Main_testVFE4;dot.junit.opcodes.rem_long.d.T_rem_long_6 ;rem-long;Verifier #4; Constraint B1, types of arguments - reference, long
dot.junit.opcodes.return_object.Main_testE1;dot.junit.opcodes.return_object.d.T_return_object_8 ;return-object;Exception #1;Method is synchronized but thread is not monitor owner
dot.junit.opcodes.return_object.Main_testN1;dot.junit.opcodes.return_object.d.T_return_object_1 ;return-object;Normal #1;Simple
dot.junit.opcodes.return_object.Main_testN2;dot.junit.opcodes.return_object.d.T_return_object_1 ;return-object;Normal #2;Simple
dot.junit.opcodes.return_object.Main_testN4;dot.junit.opcodes.return_object.d.T_return_object_2 ;return-object;Normal #4;Return null
dot.junit.opcodes.return_object.Main_testN5;dot.junit.opcodes.return_object.d.T_return_object_6 ;return-object;Normal #5;Check that frames are discarded and reinstananted correctly
dot.junit.opcodes.return_object.Main_testN7;dot.junit.opcodes.return_object.d.TInterface dot.junit.opcodes.return_object.d.TChild dot.junit.opcodes.return_object.d.TSuper dot.junit.opcodes.return_object.d.T_return_object_12 ;return-object;Normal #7;Assignment compatibility (TChild returned as TSuper)
dot.junit.opcodes.return_object.Main_testN8;dot.junit.opcodes.return_object.d.TInterface dot.junit.opcodes.return_object.d.TChild dot.junit.opcodes.return_object.d.TSuper dot.junit.opcodes.return_object.d.T_return_object_13 ;return-object;Normal #8;Assignment compatibility (TChild returned as TInterface)
dot.junit.opcodes.return_object.Main_testVFE1;dot.junit.opcodes.return_object.d.T_return_object_3 ;return-object;Verifier #1; Constraint B11, method's return type - void
dot.junit.opcodes.return_object.Main_testVFE2;dot.junit.opcodes.return_object.d.T_return_object_4 ;return-object;Verifier #2; Constraint B11, method's return type - float
dot.junit.opcodes.return_object.Main_testVFE3;dot.junit.opcodes.return_object.d.T_return_object_16 ;return-object;Verifier #3; Constraint B11, method's return type - long
dot.junit.opcodes.return_object.Main_testVFE4;dot.junit.opcodes.return_object.d.T_return_object_5 ;return-object;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.return_object.Main_testVFE6;dot.junit.opcodes.return_object.d.T_return_object_10 ;return-object;Verifier #6; Constraint B1, types of argument - int
dot.junit.opcodes.return_object.Main_testVFE7;dot.junit.opcodes.return_object.d.T_return_object_11 ;return-object;Verifier #7; Constraint B1, types of argument - long
dot.junit.opcodes.return_object.Main_testVFE8;dot.junit.opcodes.return_object.d.TInterface dot.junit.opcodes.return_object.d.TChild dot.junit.opcodes.return_object.d.TSuper dot.junit.opcodes.return_object.d.T_return_object_14 ;return-object;Verifier #8; Constraint B11, assignment incompatible references
dot.junit.opcodes.return_object.Main_testVFE9;dot.junit.opcodes.return_object.d.T_return_object_15 dot.junit.opcodes.return_object.RunnerGenerator dot.junit.opcodes.return_object.Runner dot.junit.opcodes.return_object.d.TSuper2 ;return-object;Verifier #9; Constraint B11, assignment incompatible references
dot.junit.opcodes.return_void.Main_testE1;dot.junit.opcodes.return_void.d.T_return_void_3 ;return-void;Exception #1;Method is synchronized but thread is not monitor owner
dot.junit.opcodes.return_void.Main_testN1;dot.junit.opcodes.return_void.d.T_return_void_1 ;return-void;Normal #1;Check that frames are discarded and reinstananted correctly
dot.junit.opcodes.return_void.Main_testVFE1;dot.junit.opcodes.return_void.d.T_return_void_5 ;return-void;Verifier #1; Constraint B11, method's return type - int
dot.junit.opcodes.return_void.Main_testVFE2;dot.junit.opcodes.return_void.d.T_return_void_6 ;return-void;Verifier #2; Constraint B11, method's return type - reference
dot.junit.opcodes.return_void.Main_testVFE3;dot.junit.opcodes.return_void.d.T_return_void_7 ;return-void;Verifier #3; Constraint B11, method's return type - wide
dot.junit.opcodes.return_wide.Main_testE1;dot.junit.opcodes.return_wide.d.T_return_wide_3 ;return-wide;Exception #1;Method is synchronized but thread is not monitor owner
dot.junit.opcodes.return_wide.Main_testN1;dot.junit.opcodes.return_wide.d.T_return_wide_1 ;return-wide;Normal #1;Check that frames are discarded and reinstananted correctly
dot.junit.opcodes.return_wide.Main_testVFE1;dot.junit.opcodes.return_wide.d.T_return_wide_5 ;return-wide;Verifier #1; Constraint B11, method's return type - int
dot.junit.opcodes.return_wide.Main_testVFE2;dot.junit.opcodes.return_wide.d.T_return_wide_6 ;return-wide;Verifier #2; Constraint B11, method's return type - reference
dot.junit.opcodes.return_wide.Main_testVFE3;dot.junit.opcodes.return_wide.d.T_return_wide_7 ;return-wide;Verifier #3; Constraint A24, number of registers
dot.junit.opcodes.return_wide.Main_testVFE4;dot.junit.opcodes.return_wide.d.T_return_wide_8 ;return-wide;Verifier #4; Constraint B1, return-wide on single-width register
dot.junit.opcodes.rsub_int_lit8.Main_testB1;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_3 ;rsub-int/lit8;Boundary #1;1: a = Integer.MAX_VALUE, b = 0, b-a = -Integer.MAX_VALUE 2: a = Byte.MAX_VALUE, b = 0, b-a = -Byte.MAX_VALUE
dot.junit.opcodes.rsub_int_lit8.Main_testB10;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_7 ;rsub-int/lit8;Boundary #10;1: a = Integer.MIN_VALUE, b = 1, b-a = -Integer.MAX_VALUE 2: a = Integer.MAX_VALUE, b = 1, b-a = -2147483646
dot.junit.opcodes.rsub_int_lit8.Main_testB11;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_7 ;rsub-int/lit8;Boundary #11;1: a = Byte.MIN_VALUE, b = 1, b-a = 129 2: a = Byte.MAX_VALUE, b = 1, b-a = -126
dot.junit.opcodes.rsub_int_lit8.Main_testB12;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_7 ;rsub-int/lit8;Boundary #12;(a = 1, b = 1, b-a = 0)
dot.junit.opcodes.rsub_int_lit8.Main_testB2;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_3 ;rsub-int/lit8;Boundary #2;1: a = Integer.MIN_VALUE, b = 0, b-a = Integer.MIN_VALUE 2: a = Byte.MIN_VALUE, b = 0, b-a = 128
dot.junit.opcodes.rsub_int_lit8.Main_testB3;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_3 ;rsub-int/lit8;Boundary #3;(a = 0, b = 0, b-a = 0)
dot.junit.opcodes.rsub_int_lit8.Main_testB4;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_4 ;rsub-int/lit8;Boundary #4;1: a = 0, b = Byte.MAX_VALUE, b-a = Byte.MAX_VALUE 2: a = 1, b = Byte.MAX_VALUE, b-a = 126 3: a = -1, b = Byte.MAX_VALUE, b-a = 128
dot.junit.opcodes.rsub_int_lit8.Main_testB5;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_4 ;rsub-int/lit8;Boundary #5;1: a = Integer.MIN_VALUE, b = Byte.MAX_VALUE, b-a = -2147483521 2: a = Integer.MAX_VALUE, b = Byte.MAX_VALUE, b-a = -2147483520 3: a = Byte.MIN_VALUE, b = Byte.MAX_VALUE, b-a = 255
dot.junit.opcodes.rsub_int_lit8.Main_testB6;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_5 ;rsub-int/lit8;Boundary #6;1: a = 0, b = Byte.MIN_VALUE, b-a = Byte.MIN_VALUE 2: a = 1, b = Byte.MIN_VALUE, b-a = -129 3: a = -1, b = Byte.MIN_VALUE, b-a = -127
dot.junit.opcodes.rsub_int_lit8.Main_testB7;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_5 ;rsub-int/lit8;Boundary #7;1: a = Integer.MAX_VALUE, b = Byte.MIN_VALUE, b-a = 2147483521 2: a = Integer.MIN_VALUE, b = Byte.MIN_VALUE, b-a = 2147483520 3: a = Byte.MAX_VALUE, b = Byte.MIN_VALUE, b-a = -255
dot.junit.opcodes.rsub_int_lit8.Main_testB8;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_6 ;rsub-int/lit8;Boundary #8;1: a = Integer.MIN_VALUE, b = -1, b-a = Integer.MAX_VALUE 2: a = Byte.MIN_VALUE, b = -1, b-a = Byte.MAX_VALUE
dot.junit.opcodes.rsub_int_lit8.Main_testB9;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_6 ;rsub-int/lit8;Boundary #9;1: a = Integer.MAX_VALUE, b = -1, b-a = Integer.MIN_VALUE 2: a = Byte.MAX_VALUE, b = -1, b-a = Byte.MIN_VALUE
dot.junit.opcodes.rsub_int_lit8.Main_testN1;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_1 ;rsub-int/lit8;Normal #1;Normal test - check different values
dot.junit.opcodes.rsub_int_lit8.Main_testN2;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_2 ;rsub-int/lit8;Normal #2;Normal test - check different values
dot.junit.opcodes.rsub_int_lit8.Main_testN3;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_12 ;rsub-int/lit8;Normal #3;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.rsub_int_lit8.Main_testVFE1;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_8 ;rsub-int/lit8;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.rsub_int_lit8.Main_testVFE2;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_9 ;rsub-int/lit8;Verifier #2; Constraint B1, types of arguments - double, int
dot.junit.opcodes.rsub_int_lit8.Main_testVFE3;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_10 ;rsub-int/lit8;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.rsub_int_lit8.Main_testVFE4;dot.junit.opcodes.rsub_int_lit8.d.T_rsub_int_lit8_11 ;rsub-int/lit8;Verifier #4; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.rsub_int.Main_testB1;dot.junit.opcodes.rsub_int.d.T_rsub_int_3 ;rsub-int;Boundary #1;1: a = Integer.MAX_VALUE, b = 0, b-a = -Integer.MAX_VALUE 2: a = Short.MAX_VALUE, b = 0, b-a = -Short.MAX_VALUE
dot.junit.opcodes.rsub_int.Main_testB10;dot.junit.opcodes.rsub_int.d.T_rsub_int_7 ;rsub-int;Boundary #10;1: a = Integer.MIN_VALUE, b = 1, b-a = -Integer.MAX_VALUE 2: a = Integer.MAX_VALUE, b = 1, b-a = -2147483646
dot.junit.opcodes.rsub_int.Main_testB11;dot.junit.opcodes.rsub_int.d.T_rsub_int_7 ;rsub-int;Boundary #11;1: a = Short.MIN_VALUE, b = 1, b-a = 32769 2: a = Short.MAX_VALUE, b = 1, b-a = -32766
dot.junit.opcodes.rsub_int.Main_testB12;dot.junit.opcodes.rsub_int.d.T_rsub_int_7 ;rsub-int;Boundary #12;(a = 1, b = 1, b-a = 0)
dot.junit.opcodes.rsub_int.Main_testB2;dot.junit.opcodes.rsub_int.d.T_rsub_int_3 ;rsub-int;Boundary #2;1: a = Integer.MIN_VALUE, b = 0, b-a = Integer.MIN_VALUE 2: a = Short.MIN_VALUE, b = 0, b-a = 32768
dot.junit.opcodes.rsub_int.Main_testB3;dot.junit.opcodes.rsub_int.d.T_rsub_int_3 ;rsub-int;Boundary #3;(a = 0, b = 0, b-a = 0)
dot.junit.opcodes.rsub_int.Main_testB4;dot.junit.opcodes.rsub_int.d.T_rsub_int_4 ;rsub-int;Boundary #4;1: a = 0, b = Short.MAX_VALUE, b-a = Short.MAX_VALUE 2: a = 1, b = Short.MAX_VALUE, b-a = 32766 3: a = -1, b = Short.MAX_VALUE, b-a = 32768
dot.junit.opcodes.rsub_int.Main_testB5;dot.junit.opcodes.rsub_int.d.T_rsub_int_4 ;rsub-int;Boundary #5;1: a = Integer.MIN_VALUE, b = Short.MAX_VALUE, b-a = -2147450881 2: a = Integer.MAX_VALUE, b = Short.MAX_VALUE, b-a = -2147450880 3: a = Short.MIN_VALUE, b = Short.MAX_VALUE, b-a = 65535
dot.junit.opcodes.rsub_int.Main_testB6;dot.junit.opcodes.rsub_int.d.T_rsub_int_5 ;rsub-int;Boundary #6;1: a = 0, b = Short.MIN_VALUE, b-a = Short.MIN_VALUE 2: a = 1, b = Short.MIN_VALUE, b-a = -32769 3: a = -1, b = Short.MIN_VALUE, b-a = -32767
dot.junit.opcodes.rsub_int.Main_testB7;dot.junit.opcodes.rsub_int.d.T_rsub_int_5 ;rsub-int;Boundary #7;1: a = Integer.MAX_VALUE, b = Short.MIN_VALUE, b-a = 2147450881 2: a = Integer.MIN_VALUE, b = Short.MIN_VALUE, b-a = 2147450880 3: a = Short.MAX_VALUE, b = Short.MIN_VALUE, b-a = -65535
dot.junit.opcodes.rsub_int.Main_testB8;dot.junit.opcodes.rsub_int.d.T_rsub_int_6 ;rsub-int;Boundary #8;1: a = Integer.MIN_VALUE, b = -1, b-a = Integer.MAX_VALUE 2: a = Short.MIN_VALUE, b = -1, b-a = Short.MAX_VALUE
dot.junit.opcodes.rsub_int.Main_testB9;dot.junit.opcodes.rsub_int.d.T_rsub_int_6 ;rsub-int;Boundary #9;1: a = Integer.MAX_VALUE, b = -1, b-a = Integer.MIN_VALUE 2: a = Short.MAX_VALUE, b = -1, b-a = -32768
dot.junit.opcodes.rsub_int.Main_testN1;dot.junit.opcodes.rsub_int.d.T_rsub_int_1 ;rsub-int;Normal #1;Normal test - check different values
dot.junit.opcodes.rsub_int.Main_testN2;dot.junit.opcodes.rsub_int.d.T_rsub_int_2 ;rsub-int;Normal #2;Normal test - check different values
dot.junit.opcodes.rsub_int.Main_testN3;dot.junit.opcodes.rsub_int.d.T_rsub_int_12 ;rsub-int;Normal #3;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.rsub_int.Main_testVFE1;dot.junit.opcodes.rsub_int.d.T_rsub_int_8 ;rsub-int;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.rsub_int.Main_testVFE2;dot.junit.opcodes.rsub_int.d.T_rsub_int_9 ;rsub-int;Verifier #2; Constraint B1, types of arguments - double, int
dot.junit.opcodes.rsub_int.Main_testVFE3;dot.junit.opcodes.rsub_int.d.T_rsub_int_10 ;rsub-int;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.rsub_int.Main_testVFE4;dot.junit.opcodes.rsub_int.d.T_rsub_int_11 ;rsub-int;Verifier #4; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.sget_boolean.Main_testE1;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_5 ;sget-boolean;Exception #1; Constraint A12, attempt to access non-static field
dot.junit.opcodes.sget_boolean.Main_testE6;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_9 ;sget-boolean;Exception #6;Initialization of referenced class throws exception
dot.junit.opcodes.sget_boolean.Main_testN1;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_1 ;sget-boolean;Normal #1;Get boolean from static field
dot.junit.opcodes.sget_boolean.Main_testN3;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_1 dot.junit.opcodes.sget_boolean.d.T_sget_boolean_11 ;sget-boolean;Normal #3;Access protected field from subclass
dot.junit.opcodes.sget_boolean.Main_testVFE1;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_4 ;sget-boolean;Verifier #1; Constraint A12, constant pool index
dot.junit.opcodes.sget_boolean.Main_testVFE10;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_16 ;sget-boolean;Verifier #10; Constraint B1, sget_boolean shall not work for int fields
dot.junit.opcodes.sget_boolean.Main_testVFE11;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_17 ;sget-boolean;Verifier #11; Constraint B1, sget_boolean shall not work for char fields
dot.junit.opcodes.sget_boolean.Main_testVFE12;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_18 ;sget-boolean;Verifier #12; Constraint B1, sget_boolean shall not work for byte fields
dot.junit.opcodes.sget_boolean.Main_testVFE13;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_19 ;sget-boolean;Verifier #13; Constraint B1, sget_boolean shall not work for double fields
dot.junit.opcodes.sget_boolean.Main_testVFE14;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_20 ;sget-boolean;Verifier #14; Constraint B1, sget_boolean shall not work for long fields
dot.junit.opcodes.sget_boolean.Main_testVFE2;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_3 ;sget-boolean;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.sget_boolean.Main_testVFE3;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_13 ;sget-boolean;Verifier #3; Constraint B13, read boolean from long field - only field with same name but different type exists
dot.junit.opcodes.sget_boolean.Main_testVFE4;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_6 dot.junit.opcodes.sget_boolean.TestStubs ;sget-boolean;Verifier #4; Constraint n/a, Attempt to read inaccessible field.
dot.junit.opcodes.sget_boolean.Main_testVFE5;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_7 ;sget-boolean;Verifier #5; Constraint n/a, Attempt to read field of undefined class.
dot.junit.opcodes.sget_boolean.Main_testVFE6;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_8 ;sget-boolean;Verifier #6; Constraint n/a, Attempt to read undefined field.
dot.junit.opcodes.sget_boolean.Main_testVFE7;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_1 dot.junit.opcodes.sget_boolean.d.T_sget_boolean_12 ;sget-boolean;Verifier #7; Constraint n/a, Attempt to read superclass' private field from subclass.
dot.junit.opcodes.sget_boolean.Main_testVFE8;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_14 ;sget-boolean;Verifier #8; Constraint B1, sget_boolean shall not work for reference fields
dot.junit.opcodes.sget_boolean.Main_testVFE9;dot.junit.opcodes.sget_boolean.d.T_sget_boolean_15 ;sget-boolean;Verifier #9; Constraint B1, sget_boolean shall not work for short fields
dot.junit.opcodes.sget_byte.Main_testE1;dot.junit.opcodes.sget_byte.d.T_sget_byte_5 ;sget-byte;Exception #1; Constraint A12, attempt to access non-static field
dot.junit.opcodes.sget_byte.Main_testE6;dot.junit.opcodes.sget_byte.d.T_sget_byte_9 ;sget-byte;Exception #6;Initialization of referenced class throws exception
dot.junit.opcodes.sget_byte.Main_testN1;dot.junit.opcodes.sget_byte.d.T_sget_byte_1 ;sget-byte;Normal #1;Get byte from static field
dot.junit.opcodes.sget_byte.Main_testN3;dot.junit.opcodes.sget_byte.d.T_sget_byte_11 dot.junit.opcodes.sget_byte.d.T_sget_byte_1 ;sget-byte;Normal #3;Access protected field from subclass
dot.junit.opcodes.sget_byte.Main_testVFE1;dot.junit.opcodes.sget_byte.d.T_sget_byte_4 ;sget-byte;Verifier #1; Constraint A12, constant pool index
dot.junit.opcodes.sget_byte.Main_testVFE10;dot.junit.opcodes.sget_byte.d.T_sget_byte_16 ;sget-byte;Verifier #10; Constraint B1, sget_byte shall not work for int fields
dot.junit.opcodes.sget_byte.Main_testVFE11;dot.junit.opcodes.sget_byte.d.T_sget_byte_17 ;sget-byte;Verifier #11; Constraint B1, sget_byte shall not work for char fields
dot.junit.opcodes.sget_byte.Main_testVFE12;dot.junit.opcodes.sget_byte.d.T_sget_byte_18 ;sget-byte;Verifier #12; Constraint B1, sget_byte shall not work for boolean fields
dot.junit.opcodes.sget_byte.Main_testVFE13;dot.junit.opcodes.sget_byte.d.T_sget_byte_19 ;sget-byte;Verifier #13; Constraint B1, sget_byte shall not work for double fields
dot.junit.opcodes.sget_byte.Main_testVFE14;dot.junit.opcodes.sget_byte.d.T_sget_byte_20 ;sget-byte;Verifier #14; Constraint B1, sget_byte shall not work for long fields
dot.junit.opcodes.sget_byte.Main_testVFE2;dot.junit.opcodes.sget_byte.d.T_sget_byte_3 ;sget-byte;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.sget_byte.Main_testVFE3;dot.junit.opcodes.sget_byte.d.T_sget_byte_13 ;sget-byte;Verifier #3; Constraint B13, read byte from long field - only field with same name but different type exists
dot.junit.opcodes.sget_byte.Main_testVFE4;dot.junit.opcodes.sget_byte.d.T_sget_byte_6 dot.junit.opcodes.sget_byte.TestStubs ;sget-byte;Verifier #4; Constraint n/a, Attempt to read inaccessible field.
dot.junit.opcodes.sget_byte.Main_testVFE5;dot.junit.opcodes.sget_byte.d.T_sget_byte_7 ;sget-byte;Verifier #5; Constraint n/a, Attempt to read field of undefined class.
dot.junit.opcodes.sget_byte.Main_testVFE6;dot.junit.opcodes.sget_byte.d.T_sget_byte_8 ;sget-byte;Verifier #6; Constraint n/a, Attempt to read undefined field.
dot.junit.opcodes.sget_byte.Main_testVFE7;dot.junit.opcodes.sget_byte.d.T_sget_byte_12 dot.junit.opcodes.sget_byte.d.T_sget_byte_1 ;sget-byte;Verifier #7; Constraint n/a, Attempt to read superclass' private field from subclass.
dot.junit.opcodes.sget_byte.Main_testVFE8;dot.junit.opcodes.sget_byte.d.T_sget_byte_14 ;sget-byte;Verifier #8; Constraint B1, sget_byte shall not work for reference fields
dot.junit.opcodes.sget_byte.Main_testVFE9;dot.junit.opcodes.sget_byte.d.T_sget_byte_15 ;sget-byte;Verifier #9; Constraint B1, sget_byte shall not work for short fields
dot.junit.opcodes.sget_char.Main_testE1;dot.junit.opcodes.sget_char.d.T_sget_char_5 ;sget-char;Exception #1; Constraint A12, attempt to access non-static field
dot.junit.opcodes.sget_char.Main_testE6;dot.junit.opcodes.sget_char.d.T_sget_char_9 ;sget-char;Exception #6;Initialization of referenced class throws exception
dot.junit.opcodes.sget_char.Main_testN1;dot.junit.opcodes.sget_char.d.T_sget_char_1 ;sget-char;Normal #1;Get char from static field
dot.junit.opcodes.sget_char.Main_testN3;dot.junit.opcodes.sget_char.d.T_sget_char_11 dot.junit.opcodes.sget_char.d.T_sget_char_1 ;sget-char;Normal #3;Access protected field from subclass
dot.junit.opcodes.sget_char.Main_testVFE1;dot.junit.opcodes.sget_char.d.T_sget_char_4 ;sget-char;Verifier #1; Constraint A12, constant pool index
dot.junit.opcodes.sget_char.Main_testVFE10;dot.junit.opcodes.sget_char.d.T_sget_char_16 ;sget-char;Verifier #10; Constraint B1, sget_char shall not work for int fields
dot.junit.opcodes.sget_char.Main_testVFE11;dot.junit.opcodes.sget_char.d.T_sget_char_17 ;sget-char;Verifier #11; Constraint B1, sget_char shall not work for byte fields
dot.junit.opcodes.sget_char.Main_testVFE12;dot.junit.opcodes.sget_char.d.T_sget_char_18 ;sget-char;Verifier #12; Constraint B1, sget_char shall not work for boolean fields
dot.junit.opcodes.sget_char.Main_testVFE13;dot.junit.opcodes.sget_char.d.T_sget_char_19 ;sget-char;Verifier #13; Constraint B1, sget_char shall not work for double fields
dot.junit.opcodes.sget_char.Main_testVFE14;dot.junit.opcodes.sget_char.d.T_sget_char_20 ;sget-char;Verifier #14; Constraint B1, sget_char shall not work for long fields
dot.junit.opcodes.sget_char.Main_testVFE2;dot.junit.opcodes.sget_char.d.T_sget_char_3 ;sget-char;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.sget_char.Main_testVFE3;dot.junit.opcodes.sget_char.d.T_sget_char_13 ;sget-char;Verifier #3; Constraint B13, read char from long field - only field with same name but different type exists
dot.junit.opcodes.sget_char.Main_testVFE4;dot.junit.opcodes.sget_char.d.T_sget_char_6 dot.junit.opcodes.sget_char.TestStubs ;sget-char;Verifier #4; Constraint n/a, Attempt to read inaccessible field.
dot.junit.opcodes.sget_char.Main_testVFE5;dot.junit.opcodes.sget_char.d.T_sget_char_7 ;sget-char;Verifier #5; Constraint n/a, Attempt to read field of undefined class.
dot.junit.opcodes.sget_char.Main_testVFE6;dot.junit.opcodes.sget_char.d.T_sget_char_8 ;sget-char;Verifier #6; Constraint n/a, Attempt to read undefined field.
dot.junit.opcodes.sget_char.Main_testVFE7;dot.junit.opcodes.sget_char.d.T_sget_char_12 dot.junit.opcodes.sget_char.d.T_sget_char_1 ;sget-char;Verifier #7; Constraint n/a, Attempt to read superclass' private field from subclass.
dot.junit.opcodes.sget_char.Main_testVFE8;dot.junit.opcodes.sget_char.d.T_sget_char_14 ;sget-char;Verifier #8; Constraint B1, sget_char shall not work for reference fields
dot.junit.opcodes.sget_char.Main_testVFE9;dot.junit.opcodes.sget_char.d.T_sget_char_15 ;sget-char;Verifier #9; Constraint B1, sget_char shall not work for short fields
dot.junit.opcodes.sget_object.Main_testE1;dot.junit.opcodes.sget_object.d.T_sget_object_5 ;sget-object;Exception #1; Constraint A12, attempt to access non-static field
dot.junit.opcodes.sget_object.Main_testE6;dot.junit.opcodes.sget_object.d.T_sget_object_9 ;sget-object;Exception #6;Initialization of referenced class throws exception
dot.junit.opcodes.sget_object.Main_testN1;dot.junit.opcodes.sget_object.d.T_sget_object_1 ;sget-object;Normal #1;Get object from static field
dot.junit.opcodes.sget_object.Main_testN3;dot.junit.opcodes.sget_object.d.T_sget_object_1 dot.junit.opcodes.sget_object.d.T_sget_object_11 ;sget-object;Normal #3;Access protected field from subclass
dot.junit.opcodes.sget_object.Main_testVFE1;dot.junit.opcodes.sget_object.d.T_sget_object_4 ;sget-object;Verifier #1; Constraint A12, constant pool index
dot.junit.opcodes.sget_object.Main_testVFE10;dot.junit.opcodes.sget_object.d.T_sget_object_16 ;sget-object;Verifier #10; Constraint B1, sget_object shall not work for int fields
dot.junit.opcodes.sget_object.Main_testVFE11;dot.junit.opcodes.sget_object.d.T_sget_object_17 ;sget-object;Verifier #11; Constraint B1, sget_object shall not work for byte fields
dot.junit.opcodes.sget_object.Main_testVFE12;dot.junit.opcodes.sget_object.d.T_sget_object_18 ;sget-object;Verifier #12; Constraint B1, sget_object shall not work for boolean fields
dot.junit.opcodes.sget_object.Main_testVFE13;dot.junit.opcodes.sget_object.d.T_sget_object_19 ;sget-object;Verifier #13; Constraint B1, sget_object shall not work for double fields
dot.junit.opcodes.sget_object.Main_testVFE14;dot.junit.opcodes.sget_object.d.T_sget_object_20 ;sget-object;Verifier #14; Constraint B1, sget_object shall not work for long fields
dot.junit.opcodes.sget_object.Main_testVFE15;dot.junit.opcodes.sget_object.d.T_sget_object_21 ;sget-object;Verifier #15; Constraint B13, only field of different type exists)
dot.junit.opcodes.sget_object.Main_testVFE2;dot.junit.opcodes.sget_object.d.T_sget_object_3 ;sget-object;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.sget_object.Main_testVFE3;dot.junit.opcodes.sget_object.d.T_sget_object_13 ;sget-object;Verifier #3; Constraint B13, read object from long field - only field with same name but different type exists
dot.junit.opcodes.sget_object.Main_testVFE4;dot.junit.opcodes.sget_object.TestStubs dot.junit.opcodes.sget_object.d.T_sget_object_6 ;sget-object;Verifier #4; Constraint n/a, Attempt to read inaccessible field.
dot.junit.opcodes.sget_object.Main_testVFE5;dot.junit.opcodes.sget_object.d.T_sget_object_7 ;sget-object;Verifier #5; Constraint n/a, Attempt to read field of undefined class.
dot.junit.opcodes.sget_object.Main_testVFE6;dot.junit.opcodes.sget_object.d.T_sget_object_8 ;sget-object;Verifier #6; Constraint n/a, Attempt to read undefined field.
dot.junit.opcodes.sget_object.Main_testVFE7;dot.junit.opcodes.sget_object.d.T_sget_object_1 dot.junit.opcodes.sget_object.d.T_sget_object_12 ;sget-object;Verifier #7; Constraint n/a, Attempt to read superclass' private field from subclass.
dot.junit.opcodes.sget_object.Main_testVFE8;dot.junit.opcodes.sget_object.d.T_sget_object_14 ;sget-object;Verifier #8; Constraint B1, sget_object shall not work for short fields
dot.junit.opcodes.sget_object.Main_testVFE9;dot.junit.opcodes.sget_object.d.T_sget_object_15 ;sget-object;Verifier #9; Constraint B1, sget_object shall not work for char fields
dot.junit.opcodes.sget_short.Main_testE1;dot.junit.opcodes.sget_short.d.T_sget_short_5 ;sget-short;Exception #1; Constraint A12, attempt to access non-static field
dot.junit.opcodes.sget_short.Main_testE6;dot.junit.opcodes.sget_short.d.T_sget_short_9 ;sget-short;Exception #6;Initialization of referenced class throws exception
dot.junit.opcodes.sget_short.Main_testN1;dot.junit.opcodes.sget_short.d.T_sget_short_1 ;sget-short;Normal #1;Get short from static field
dot.junit.opcodes.sget_short.Main_testN3;dot.junit.opcodes.sget_short.d.T_sget_short_1 dot.junit.opcodes.sget_short.d.T_sget_short_11 ;sget-short;Normal #3;Access protected field from subclass
dot.junit.opcodes.sget_short.Main_testVFE1;dot.junit.opcodes.sget_short.d.T_sget_short_4 ;sget-short;Verifier #1; Constraint A12, constant pool index
dot.junit.opcodes.sget_short.Main_testVFE10;dot.junit.opcodes.sget_short.d.T_sget_short_16 ;sget-short;Verifier #10; Constraint B1, sget_short shall not work for int fields
dot.junit.opcodes.sget_short.Main_testVFE11;dot.junit.opcodes.sget_short.d.T_sget_short_17 ;sget-short;Verifier #11; Constraint B1, sget_short shall not work for byte fields
dot.junit.opcodes.sget_short.Main_testVFE12;dot.junit.opcodes.sget_short.d.T_sget_short_18 ;sget-short;Verifier #12; Constraint B1, sget_short shall not work for boolean fields
dot.junit.opcodes.sget_short.Main_testVFE13;dot.junit.opcodes.sget_short.d.T_sget_short_19 ;sget-short;Verifier #13; Constraint B1, sget_short shall not work for double fields
dot.junit.opcodes.sget_short.Main_testVFE14;dot.junit.opcodes.sget_short.d.T_sget_short_20 ;sget-short;Verifier #14; Constraint B1, sget_short shall not work for long fields
dot.junit.opcodes.sget_short.Main_testVFE2;dot.junit.opcodes.sget_short.d.T_sget_short_3 ;sget-short;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.sget_short.Main_testVFE3;dot.junit.opcodes.sget_short.d.T_sget_short_13 ;sget-short;Verifier #3; Constraint B13, read short from long field - only field with same name but different type exists
dot.junit.opcodes.sget_short.Main_testVFE4;dot.junit.opcodes.sget_short.TestStubs dot.junit.opcodes.sget_short.d.T_sget_short_6 ;sget-short;Verifier #4; Constraint n/a, Attempt to read inaccessible field.
dot.junit.opcodes.sget_short.Main_testVFE5;dot.junit.opcodes.sget_short.d.T_sget_short_7 ;sget-short;Verifier #5; Constraint n/a, Attempt to read field of undefined class.
dot.junit.opcodes.sget_short.Main_testVFE6;dot.junit.opcodes.sget_short.d.T_sget_short_8 ;sget-short;Verifier #6; Constraint n/a, Attempt to read undefined field.
dot.junit.opcodes.sget_short.Main_testVFE7;dot.junit.opcodes.sget_short.d.T_sget_short_1 dot.junit.opcodes.sget_short.d.T_sget_short_12 ;sget-short;Verifier #7; Constraint n/a, Attempt to read superclass' private field from subclass.
dot.junit.opcodes.sget_short.Main_testVFE8;dot.junit.opcodes.sget_short.d.T_sget_short_14 ;sget-short;Verifier #8; Constraint B1, sget_short shall not work for reference fields
dot.junit.opcodes.sget_short.Main_testVFE9;dot.junit.opcodes.sget_short.d.T_sget_short_15 ;sget-short;Verifier #9; Constraint B1, sget_short shall not work for char fields
dot.junit.opcodes.sget.Main_testE1;dot.junit.opcodes.sget.d.T_sget_5 ;sget;Exception #1; Constraint A12, attempt to access non-static field
dot.junit.opcodes.sget.Main_testE6;dot.junit.opcodes.sget.d.T_sget_9 ;sget;Exception #6;Initialization of referenced class throws exception
dot.junit.opcodes.sget.Main_testN1;dot.junit.opcodes.sget.d.T_sget_1 ;sget;Normal #1;Type - int
dot.junit.opcodes.sget.Main_testN2;dot.junit.opcodes.sget.d.T_sget_2 ;sget;Normal #2;Type - float
dot.junit.opcodes.sget.Main_testN3;dot.junit.opcodes.sget.d.T_sget_1 dot.junit.opcodes.sget.d.T_sget_11 ;sget;Normal #3;Access protected field from subclass
dot.junit.opcodes.sget.Main_testVFE1;dot.junit.opcodes.sget.d.T_sget_4 ;sget;Verifier #1; Constraint A12, constant pool index
dot.junit.opcodes.sget.Main_testVFE10;dot.junit.opcodes.sget.d.T_sget_16 ;sget;Verifier #10; Constraint B1, sget shall not work for boolean fields
dot.junit.opcodes.sget.Main_testVFE11;dot.junit.opcodes.sget.d.T_sget_17 ;sget;Verifier #11; Constraint B1, sget shall not work for char fields
dot.junit.opcodes.sget.Main_testVFE12;dot.junit.opcodes.sget.d.T_sget_18 ;sget;Verifier #12; Constraint B1, sget shall not work for byte fields
dot.junit.opcodes.sget.Main_testVFE13;dot.junit.opcodes.sget.d.T_sget_19 ;sget;Verifier #13; Constraint B1, sget shall not work for double fields
dot.junit.opcodes.sget.Main_testVFE14;dot.junit.opcodes.sget.d.T_sget_20 ;sget;Verifier #14; Constraint B1, sget shall not work for long fields
dot.junit.opcodes.sget.Main_testVFE2;dot.junit.opcodes.sget.d.T_sget_3 ;sget;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.sget.Main_testVFE3;dot.junit.opcodes.sget.d.T_sget_13 ;sget;Verifier #3; Constraint B13, read integer from long field - only field with same name but different type exists
dot.junit.opcodes.sget.Main_testVFE4;dot.junit.opcodes.sget.TestStubs dot.junit.opcodes.sget.d.T_sget_6 ;sget;Verifier #4; Constraint n/a, Attempt to read inaccessible field.
dot.junit.opcodes.sget.Main_testVFE5;dot.junit.opcodes.sget.d.T_sget_7 ;sget;Verifier #5; Constraint n/a, Attempt to read field of undefined class.
dot.junit.opcodes.sget.Main_testVFE6;dot.junit.opcodes.sget.d.T_sget_8 ;sget;Verifier #6; Constraint n/a, Attempt to read undefined field.
dot.junit.opcodes.sget.Main_testVFE7;dot.junit.opcodes.sget.d.T_sget_1 dot.junit.opcodes.sget.d.T_sget_12 ;sget;Verifier #7; Constraint n/a, Attempt to read superclass' private field from subclass.
dot.junit.opcodes.sget.Main_testVFE8;dot.junit.opcodes.sget.d.T_sget_14 ;sget;Verifier #8; Constraint B1, sget shall not work for reference fields
dot.junit.opcodes.sget.Main_testVFE9;dot.junit.opcodes.sget.d.T_sget_15 ;sget;Verifier #9; Constraint B1, sget shall not work for short fields
dot.junit.opcodes.sget_wide.Main_testE1;dot.junit.opcodes.sget_wide.d.T_sget_wide_5 ;sget-wide;Exception #1; Constraint A12, attempt to access non-static field
dot.junit.opcodes.sget_wide.Main_testE6;dot.junit.opcodes.sget_wide.d.T_sget_wide_9 ;sget-wide;Exception #6;Initialization of referenced class throws exception
dot.junit.opcodes.sget_wide.Main_testN1;dot.junit.opcodes.sget_wide.d.T_sget_wide_1 ;sget-wide;Normal #1;Type - long
dot.junit.opcodes.sget_wide.Main_testN2;dot.junit.opcodes.sget_wide.d.T_sget_wide_2 ;sget-wide;Normal #2;Type - double
dot.junit.opcodes.sget_wide.Main_testN3;dot.junit.opcodes.sget_wide.d.T_sget_wide_1 dot.junit.opcodes.sget_wide.d.T_sget_wide_11 ;sget-wide;Normal #3;Access protected field from subclass
dot.junit.opcodes.sget_wide.Main_testVFE1;dot.junit.opcodes.sget_wide.d.T_sget_wide_4 ;sget-wide;Verifier #1; Constraint A12, constant pool index
dot.junit.opcodes.sget_wide.Main_testVFE10;dot.junit.opcodes.sget_wide.d.T_sget_wide_16 ;sget-wide;Verifier #10; Constraint B1, sget-wide shall not work for boolean fields
dot.junit.opcodes.sget_wide.Main_testVFE11;dot.junit.opcodes.sget_wide.d.T_sget_wide_17 ;sget-wide;Verifier #11; Constraint B1, sget-wide shall not work for char fields
dot.junit.opcodes.sget_wide.Main_testVFE12;dot.junit.opcodes.sget_wide.d.T_sget_wide_18 ;sget-wide;Verifier #12; Constraint B1, sget-wide shall not work for byte fields
dot.junit.opcodes.sget_wide.Main_testVFE13;dot.junit.opcodes.sget_wide.d.T_sget_wide_19 ;sget-wide;Verifier #13; Constraint B1, sget-wide shall not work for float fields
dot.junit.opcodes.sget_wide.Main_testVFE14;dot.junit.opcodes.sget_wide.d.T_sget_wide_20 ;sget-wide;Verifier #14; Constraint B1, sget-wide shall not work for int fields
dot.junit.opcodes.sget_wide.Main_testVFE2;dot.junit.opcodes.sget_wide.d.T_sget_wide_3 ;sget-wide;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.sget_wide.Main_testVFE3;dot.junit.opcodes.sget_wide.d.T_sget_wide_13 ;sget-wide;Verifier #3; Constraint B13, read long from integer field - only field with same name but different type exists
dot.junit.opcodes.sget_wide.Main_testVFE4;dot.junit.opcodes.sget_wide.TestStubs dot.junit.opcodes.sget_wide.d.T_sget_wide_6 ;sget-wide;Verifier #4; Constraint n/a, Attempt to read inaccessible field.
dot.junit.opcodes.sget_wide.Main_testVFE5;dot.junit.opcodes.sget_wide.d.T_sget_wide_7 ;sget-wide;Verifier #5; Constraint n/a, Attempt to read field of undefined class.
dot.junit.opcodes.sget_wide.Main_testVFE6;dot.junit.opcodes.sget_wide.d.T_sget_wide_8 ;sget-wide;Verifier #6; Constraint n/a, Attempt to read undefined field.
dot.junit.opcodes.sget_wide.Main_testVFE7;dot.junit.opcodes.sget_wide.d.T_sget_wide_1 dot.junit.opcodes.sget_wide.d.T_sget_wide_12 ;sget-wide;Verifier #7; Constraint n/a, Attempt to read superclass' private field from subclass.
dot.junit.opcodes.sget_wide.Main_testVFE8;dot.junit.opcodes.sget_wide.d.T_sget_wide_14 ;sget-wide;Verifier #8; Constraint B1, sget-wide shall not work for reference fields
dot.junit.opcodes.sget_wide.Main_testVFE9;dot.junit.opcodes.sget_wide.d.T_sget_wide_15 ;sget-wide;Verifier #9; Constraint B1, sget-wide shall not work for short fields
dot.junit.opcodes.shl_int_2addr.Main_testB1;dot.junit.opcodes.shl_int_2addr.d.T_shl_int_2addr_1 ;shl-int/2addr;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.shl_int_2addr.Main_testB2;dot.junit.opcodes.shl_int_2addr.d.T_shl_int_2addr_1 ;shl-int/2addr;Boundary #2;Arguments = Integer.MAX_VALUE & 1
dot.junit.opcodes.shl_int_2addr.Main_testB3;dot.junit.opcodes.shl_int_2addr.d.T_shl_int_2addr_1 ;shl-int/2addr;Boundary #3;Arguments = Integer.MIN_VALUE & 1
dot.junit.opcodes.shl_int_2addr.Main_testB4;dot.junit.opcodes.shl_int_2addr.d.T_shl_int_2addr_1 ;shl-int/2addr;Boundary #4;Arguments = 1 & 0
dot.junit.opcodes.shl_int_2addr.Main_testN1;dot.junit.opcodes.shl_int_2addr.d.T_shl_int_2addr_1 ;shl-int/2addr;Normal #1;15 << 1
dot.junit.opcodes.shl_int_2addr.Main_testN2;dot.junit.opcodes.shl_int_2addr.d.T_shl_int_2addr_1 ;shl-int/2addr;Normal #2;33 << 2
dot.junit.opcodes.shl_int_2addr.Main_testN3;dot.junit.opcodes.shl_int_2addr.d.T_shl_int_2addr_1 ;shl-int/2addr;Normal #3;-15 << 1
dot.junit.opcodes.shl_int_2addr.Main_testN4;dot.junit.opcodes.shl_int_2addr.d.T_shl_int_2addr_1 ;shl-int/2addr;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.shl_int_2addr.Main_testN5;dot.junit.opcodes.shl_int_2addr.d.T_shl_int_2addr_1 ;shl-int/2addr;Normal #5;Verify that shift distance is actually in range 0 to 32.
dot.junit.opcodes.shl_int_2addr.Main_testN6;dot.junit.opcodes.shl_int_2addr.d.T_shl_int_2addr_6 ;shl-int/2addr;Normal #6;Types of arguments - float, float. Dalvik doens't distinguish 32-bits types internally, so this operation for float parameters makes no sense but shall not crash the VM.
dot.junit.opcodes.shl_int_2addr.Main_testVFE1;dot.junit.opcodes.shl_int_2addr.d.T_shl_int_2addr_2 ;shl-int/2addr;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.shl_int_2addr.Main_testVFE2;dot.junit.opcodes.shl_int_2addr.d.T_shl_int_2addr_3 ;shl-int/2addr;Verifier #2; Constraint B1, types of arguments - double & int
dot.junit.opcodes.shl_int_2addr.Main_testVFE3;dot.junit.opcodes.shl_int_2addr.d.T_shl_int_2addr_4 ;shl-int/2addr;Verifier #3; Constraint B1, types of arguments - long & int
dot.junit.opcodes.shl_int_2addr.Main_testVFE4;dot.junit.opcodes.shl_int_2addr.d.T_shl_int_2addr_5 ;shl-int/2addr;Verifier #4; Constraint B1, types of arguments - reference & int
dot.junit.opcodes.shl_int_lit8.Main_testB1;dot.junit.opcodes.shl_int_lit8.d.T_shl_int_lit8_3 ;shl-int/lit8;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.shl_int_lit8.Main_testB2;dot.junit.opcodes.shl_int_lit8.d.T_shl_int_lit8_1 ;shl-int/lit8;Boundary #2;Arguments = Integer.MAX_VALUE & 1
dot.junit.opcodes.shl_int_lit8.Main_testB3;dot.junit.opcodes.shl_int_lit8.d.T_shl_int_lit8_1 ;shl-int/lit8;Boundary #3;Arguments = Integer.MIN_VALUE & 1
dot.junit.opcodes.shl_int_lit8.Main_testB4;dot.junit.opcodes.shl_int_lit8.d.T_shl_int_lit8_5 ;shl-int/lit8;Boundary #4;Arguments = 1 & 0
dot.junit.opcodes.shl_int_lit8.Main_testN1;dot.junit.opcodes.shl_int_lit8.d.T_shl_int_lit8_1 ;shl-int/lit8;Normal #1;15 << 1
dot.junit.opcodes.shl_int_lit8.Main_testN2;dot.junit.opcodes.shl_int_lit8.d.T_shl_int_lit8_2 ;shl-int/lit8;Normal #2;33 << 2
dot.junit.opcodes.shl_int_lit8.Main_testN3;dot.junit.opcodes.shl_int_lit8.d.T_shl_int_lit8_1 ;shl-int/lit8;Normal #3;-15 << 1
dot.junit.opcodes.shl_int_lit8.Main_testN4;dot.junit.opcodes.shl_int_lit8.d.T_shl_int_lit8_3 ;shl-int/lit8;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.shl_int_lit8.Main_testN5;dot.junit.opcodes.shl_int_lit8.d.T_shl_int_lit8_4 ;shl-int/lit8;Normal #5;Verify that shift distance is actually in range 0 to 32.
dot.junit.opcodes.shl_int_lit8.Main_testN6;dot.junit.opcodes.shl_int_lit8.d.T_shl_int_lit8_6 ;shl-int/lit8;Normal #6;Types of arguments - float. Dalvik doens't distinguish 32-bits types internally, so this operation of float makes no sense but shall not crash the VM.
dot.junit.opcodes.shl_int_lit8.Main_testVFE1;dot.junit.opcodes.shl_int_lit8.d.T_shl_int_lit8_7 ;shl-int/lit8;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.shl_int_lit8.Main_testVFE2;dot.junit.opcodes.shl_int_lit8.d.T_shl_int_lit8_8 ;shl-int/lit8;Verifier #2; Constraint B1, types of arguments - double & int
dot.junit.opcodes.shl_int_lit8.Main_testVFE3;dot.junit.opcodes.shl_int_lit8.d.T_shl_int_lit8_9 ;shl-int/lit8;Verifier #3; Constraint B1, types of arguments - long & int
dot.junit.opcodes.shl_int_lit8.Main_testVFE4;dot.junit.opcodes.shl_int_lit8.d.T_shl_int_lit8_10 ;shl-int/lit8;Verifier #4; Constraint B1, types of arguments - reference & int
dot.junit.opcodes.shl_int.Main_testB1;dot.junit.opcodes.shl_int.d.T_shl_int_1 ;shl-int;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.shl_int.Main_testB2;dot.junit.opcodes.shl_int.d.T_shl_int_1 ;shl-int;Boundary #2;Arguments = Integer.MAX_VALUE & 1
dot.junit.opcodes.shl_int.Main_testB3;dot.junit.opcodes.shl_int.d.T_shl_int_1 ;shl-int;Boundary #3;Arguments = Integer.MIN_VALUE & 1
dot.junit.opcodes.shl_int.Main_testB4;dot.junit.opcodes.shl_int.d.T_shl_int_1 ;shl-int;Boundary #4;Arguments = 1 & 0
dot.junit.opcodes.shl_int.Main_testN1;dot.junit.opcodes.shl_int.d.T_shl_int_1 ;shl-int;Normal #1;15 << 1
dot.junit.opcodes.shl_int.Main_testN2;dot.junit.opcodes.shl_int.d.T_shl_int_1 ;shl-int;Normal #2;33 << 2
dot.junit.opcodes.shl_int.Main_testN3;dot.junit.opcodes.shl_int.d.T_shl_int_1 ;shl-int;Normal #3;-15 << 1
dot.junit.opcodes.shl_int.Main_testN4;dot.junit.opcodes.shl_int.d.T_shl_int_1 ;shl-int;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.shl_int.Main_testN5;dot.junit.opcodes.shl_int.d.T_shl_int_1 ;shl-int;Normal #5;Verify that shift distance is actually in range 0 to 32.
dot.junit.opcodes.shl_int.Main_testN6;dot.junit.opcodes.shl_int.d.T_shl_int_6 ;shl-int;Normal #6;Types of arguments - float, float. Dalvik doens't distinguish 32-bits types internally, so this operation float parameters makes no sense but shall not crash the VM.
dot.junit.opcodes.shl_int.Main_testVFE1;dot.junit.opcodes.shl_int.d.T_shl_int_2 ;shl-int;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.shl_int.Main_testVFE2;dot.junit.opcodes.shl_int.d.T_shl_int_3 ;shl-int;Verifier #2; Constraint B1, types of arguments - double & int
dot.junit.opcodes.shl_int.Main_testVFE3;dot.junit.opcodes.shl_int.d.T_shl_int_4 ;shl-int;Verifier #3; Constraint B1, types of arguments - long & int
dot.junit.opcodes.shl_int.Main_testVFE4;dot.junit.opcodes.shl_int.d.T_shl_int_5 ;shl-int;Verifier #4; Constraint B1, types of arguments - reference & int
dot.junit.opcodes.shl_long_2addr.Main_testB1;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_1 ;shl-long/2addr;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.shl_long_2addr.Main_testB2;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_1 ;shl-long/2addr;Boundary #2;Arguments = 1 & 0
dot.junit.opcodes.shl_long_2addr.Main_testB3;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_1 ;shl-long/2addr;Boundary #3;Arguments = Long.MAX_VALUE & 1
dot.junit.opcodes.shl_long_2addr.Main_testB4;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_1 ;shl-long/2addr;Boundary #4;Arguments = Long.MIN_VALUE & 1
dot.junit.opcodes.shl_long_2addr.Main_testN1;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_1 ;shl-long/2addr;Normal #1;Arguments = 5000000000l, 3
dot.junit.opcodes.shl_long_2addr.Main_testN2;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_1 ;shl-long/2addr;Normal #2;Arguments = 5000000000l, 1
dot.junit.opcodes.shl_long_2addr.Main_testN3;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_1 ;shl-long/2addr;Normal #3;Arguments = -5000000000l, 1
dot.junit.opcodes.shl_long_2addr.Main_testN4;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_1 ;shl-long/2addr;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.shl_long_2addr.Main_testN5;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_1 ;shl-long/2addr;Normal #5;Verify that shift distance is actually in range 0 to 64.
dot.junit.opcodes.shl_long_2addr.Main_testN6;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_7 ;shl-long/2addr;Normal #6;Types of arguments - double, int. Dalvik doens't distinguish 64-bits types internally, so this operation of double makes no sense but shall not crash the VM.
dot.junit.opcodes.shl_long_2addr.Main_testVFE1;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_2 ;shl-long/2addr;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.shl_long_2addr.Main_testVFE2;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_3 ;shl-long/2addr;Verifier #2; Constraint B1, types of arguments - long, double
dot.junit.opcodes.shl_long_2addr.Main_testVFE3;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_4 ;shl-long/2addr;Verifier #3; Constraint B1, types of arguments - int, int
dot.junit.opcodes.shl_long_2addr.Main_testVFE4;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_5 ;shl-long/2addr;Verifier #4; Constraint B1, types of arguments - float, int
dot.junit.opcodes.shl_long_2addr.Main_testVFE5;dot.junit.opcodes.shl_long_2addr.d.T_shl_long_2addr_6 ;shl-long/2addr;Verifier #5; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.shl_long.Main_testB1;dot.junit.opcodes.shl_long.d.T_shl_long_1 ;shl-long;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.shl_long.Main_testB2;dot.junit.opcodes.shl_long.d.T_shl_long_1 ;shl-long;Boundary #2;Arguments = 1 & 0
dot.junit.opcodes.shl_long.Main_testB3;dot.junit.opcodes.shl_long.d.T_shl_long_1 ;shl-long;Boundary #3;Arguments = Long.MAX_VALUE & 1
dot.junit.opcodes.shl_long.Main_testB4;dot.junit.opcodes.shl_long.d.T_shl_long_1 ;shl-long;Boundary #4;Arguments = Long.MIN_VALUE & 1
dot.junit.opcodes.shl_long.Main_testN1;dot.junit.opcodes.shl_long.d.T_shl_long_1 ;shl-long;Normal #1;Arguments = 5000000000l, 3
dot.junit.opcodes.shl_long.Main_testN2;dot.junit.opcodes.shl_long.d.T_shl_long_1 ;shl-long;Normal #2;Arguments = 5000000000l, 1
dot.junit.opcodes.shl_long.Main_testN3;dot.junit.opcodes.shl_long.d.T_shl_long_1 ;shl-long;Normal #3;Arguments = -5000000000l, 1
dot.junit.opcodes.shl_long.Main_testN4;dot.junit.opcodes.shl_long.d.T_shl_long_1 ;shl-long;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.shl_long.Main_testN5;dot.junit.opcodes.shl_long.d.T_shl_long_1 ;shl-long;Normal #5;Verify that shift distance is actually in range 0 to 64.
dot.junit.opcodes.shl_long.Main_testN6;dot.junit.opcodes.shl_long.d.T_shl_long_7 ;shl-long;Normal #6;Types of arguments - double, int. Dalvik doens't distinguish 64-bits types internally, so this operation of double makes no sense but shall not crash the VM.
dot.junit.opcodes.shl_long.Main_testVFE1;dot.junit.opcodes.shl_long.d.T_shl_long_2 ;shl-long;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.shl_long.Main_testVFE2;dot.junit.opcodes.shl_long.d.T_shl_long_3 ;shl-long;Verifier #2; Constraint B1, types of arguments - long & double
dot.junit.opcodes.shl_long.Main_testVFE3;dot.junit.opcodes.shl_long.d.T_shl_long_4 ;shl-long;Verifier #3; Constraint B1, types of arguments - int & int
dot.junit.opcodes.shl_long.Main_testVFE4;dot.junit.opcodes.shl_long.d.T_shl_long_5 ;shl-long;Verifier #4; Constraint B1, types of arguments - float & int
dot.junit.opcodes.shl_long.Main_testVFE5;dot.junit.opcodes.shl_long.d.T_shl_long_6 ;shl-long;Verifier #5; Constraint B1, types of arguments - reference & int
dot.junit.opcodes.shr_int_2addr.Main_testB1;dot.junit.opcodes.shr_int_2addr.d.T_shr_int_2addr_1 ;shr-int/2addr;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.shr_int_2addr.Main_testB2;dot.junit.opcodes.shr_int_2addr.d.T_shr_int_2addr_1 ;shr-int/2addr;Boundary #2;Arguments = Integer.MAX_VALUE & 1
dot.junit.opcodes.shr_int_2addr.Main_testB3;dot.junit.opcodes.shr_int_2addr.d.T_shr_int_2addr_1 ;shr-int/2addr;Boundary #3;Arguments = Integer.MIN_VALUE & 1
dot.junit.opcodes.shr_int_2addr.Main_testB4;dot.junit.opcodes.shr_int_2addr.d.T_shr_int_2addr_1 ;shr-int/2addr;Boundary #4;Arguments = 1 & 0
dot.junit.opcodes.shr_int_2addr.Main_testN1;dot.junit.opcodes.shr_int_2addr.d.T_shr_int_2addr_1 ;shr-int/2addr;Normal #1;15 >> 1
dot.junit.opcodes.shr_int_2addr.Main_testN2;dot.junit.opcodes.shr_int_2addr.d.T_shr_int_2addr_1 ;shr-int/2addr;Normal #2;33 >> 2
dot.junit.opcodes.shr_int_2addr.Main_testN3;dot.junit.opcodes.shr_int_2addr.d.T_shr_int_2addr_1 ;shr-int/2addr;Normal #3;-15 >> 1
dot.junit.opcodes.shr_int_2addr.Main_testN4;dot.junit.opcodes.shr_int_2addr.d.T_shr_int_2addr_1 ;shr-int/2addr;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.shr_int_2addr.Main_testN5;dot.junit.opcodes.shr_int_2addr.d.T_shr_int_2addr_1 ;shr-int/2addr;Normal #5;Verify that shift distance is actually in range 0 to 32.
dot.junit.opcodes.shr_int_2addr.Main_testN6;dot.junit.opcodes.shr_int_2addr.d.T_shr_int_2addr_6 ;shr-int/2addr;Normal #6;Types of arguments - float, float. Dalvik doens't distinguish 32-bits types internally, so this operation of float makes no sense but shall not crash the VM.
dot.junit.opcodes.shr_int_2addr.Main_testVFE1;dot.junit.opcodes.shr_int_2addr.d.T_shr_int_2addr_2 ;shr-int/2addr;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.shr_int_2addr.Main_testVFE2;dot.junit.opcodes.shr_int_2addr.d.T_shr_int_2addr_3 ;shr-int/2addr;Verifier #2; Constraint B1, types of arguments - double, int
dot.junit.opcodes.shr_int_2addr.Main_testVFE3;dot.junit.opcodes.shr_int_2addr.d.T_shr_int_2addr_4 ;shr-int/2addr;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.shr_int_2addr.Main_testVFE4;dot.junit.opcodes.shr_int_2addr.d.T_shr_int_2addr_5 ;shr-int/2addr;Verifier #4; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.shr_int_lit8.Main_testB1;dot.junit.opcodes.shr_int_lit8.d.T_shr_int_lit8_3 ;shr-int/lit8;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.shr_int_lit8.Main_testB2;dot.junit.opcodes.shr_int_lit8.d.T_shr_int_lit8_1 ;shr-int/lit8;Boundary #2;Arguments = Integer.MAX_VALUE & 1
dot.junit.opcodes.shr_int_lit8.Main_testB3;dot.junit.opcodes.shr_int_lit8.d.T_shr_int_lit8_1 ;shr-int/lit8;Boundary #3;Arguments = Integer.MIN_VALUE & 1
dot.junit.opcodes.shr_int_lit8.Main_testB4;dot.junit.opcodes.shr_int_lit8.d.T_shr_int_lit8_5 ;shr-int/lit8;Boundary #4;Arguments = 1 & 0
dot.junit.opcodes.shr_int_lit8.Main_testN1;dot.junit.opcodes.shr_int_lit8.d.T_shr_int_lit8_1 ;shr-int/lit8;Normal #1;15 >> 1
dot.junit.opcodes.shr_int_lit8.Main_testN2;dot.junit.opcodes.shr_int_lit8.d.T_shr_int_lit8_2 ;shr-int/lit8;Normal #2;33 >> 2
dot.junit.opcodes.shr_int_lit8.Main_testN3;dot.junit.opcodes.shr_int_lit8.d.T_shr_int_lit8_1 ;shr-int/lit8;Normal #3;-15 >> 1
dot.junit.opcodes.shr_int_lit8.Main_testN4;dot.junit.opcodes.shr_int_lit8.d.T_shr_int_lit8_3 ;shr-int/lit8;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.shr_int_lit8.Main_testN5;dot.junit.opcodes.shr_int_lit8.d.T_shr_int_lit8_4 ;shr-int/lit8;Normal #5;Verify that shift distance is actually in range 0 to 32.
dot.junit.opcodes.shr_int_lit8.Main_testN6;dot.junit.opcodes.shr_int_lit8.d.T_shr_int_lit8_6 ;shr-int/lit8;Normal #6;Types of arguments - float. Dalvik doens't distinguish 32-bits types internally, so this operation of float makes no sense but shall not crash the VM.
dot.junit.opcodes.shr_int_lit8.Main_testVFE1;dot.junit.opcodes.shr_int_lit8.d.T_shr_int_lit8_7 ;shr-int/lit8;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.shr_int_lit8.Main_testVFE2;dot.junit.opcodes.shr_int_lit8.d.T_shr_int_lit8_8 ;shr-int/lit8;Verifier #2; Constraint B1, types of arguments - double, int
dot.junit.opcodes.shr_int_lit8.Main_testVFE3;dot.junit.opcodes.shr_int_lit8.d.T_shr_int_lit8_9 ;shr-int/lit8;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.shr_int_lit8.Main_testVFE4;dot.junit.opcodes.shr_int_lit8.d.T_shr_int_lit8_10 ;shr-int/lit8;Verifier #4; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.shr_int.Main_testB1;dot.junit.opcodes.shr_int.d.T_shr_int_1 ;shr-int;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.shr_int.Main_testB2;dot.junit.opcodes.shr_int.d.T_shr_int_1 ;shr-int;Boundary #2;Arguments = Integer.MAX_VALUE & 1
dot.junit.opcodes.shr_int.Main_testB3;dot.junit.opcodes.shr_int.d.T_shr_int_1 ;shr-int;Boundary #3;Arguments = Integer.MIN_VALUE & 1
dot.junit.opcodes.shr_int.Main_testB4;dot.junit.opcodes.shr_int.d.T_shr_int_1 ;shr-int;Boundary #4;Arguments = 1 & 0
dot.junit.opcodes.shr_int.Main_testN1;dot.junit.opcodes.shr_int.d.T_shr_int_1 ;shr-int;Normal #1;15 >> 1
dot.junit.opcodes.shr_int.Main_testN2;dot.junit.opcodes.shr_int.d.T_shr_int_1 ;shr-int;Normal #2;33 >> 2
dot.junit.opcodes.shr_int.Main_testN3;dot.junit.opcodes.shr_int.d.T_shr_int_1 ;shr-int;Normal #3;-15 >> 1
dot.junit.opcodes.shr_int.Main_testN4;dot.junit.opcodes.shr_int.d.T_shr_int_1 ;shr-int;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.shr_int.Main_testN5;dot.junit.opcodes.shr_int.d.T_shr_int_1 ;shr-int;Normal #5;Verify that shift distance is actually in range 0 to 32.
dot.junit.opcodes.shr_int.Main_testN6;dot.junit.opcodes.shr_int.d.T_shr_int_6 ;shr-int;Normal #6;Types of arguments - float, float. Dalvik doens't distinguish 32-bits types internally, so this operation of float parameters makes no sense but shall not crash the VM.
dot.junit.opcodes.shr_int.Main_testVFE1;dot.junit.opcodes.shr_int.d.T_shr_int_2 ;shr-int;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.shr_int.Main_testVFE2;dot.junit.opcodes.shr_int.d.T_shr_int_3 ;shr-int;Verifier #2; Constraint B1, types of arguments - double, int
dot.junit.opcodes.shr_int.Main_testVFE3;dot.junit.opcodes.shr_int.d.T_shr_int_4 ;shr-int;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.shr_int.Main_testVFE4;dot.junit.opcodes.shr_int.d.T_shr_int_5 ;shr-int;Verifier #4; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.shr_long_2addr.Main_testB1;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_1 ;shr-long/2addr;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.shr_long_2addr.Main_testB2;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_1 ;shr-long/2addr;Boundary #2;Arguments = 1 & 0
dot.junit.opcodes.shr_long_2addr.Main_testB3;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_1 ;shr-long/2addr;Boundary #3;Arguments = Long.MAX_VALUE & 1
dot.junit.opcodes.shr_long_2addr.Main_testB4;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_1 ;shr-long/2addr;Boundary #4;Arguments = Long.MIN_VALUE & 1
dot.junit.opcodes.shr_long_2addr.Main_testN1;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_1 ;shr-long/2addr;Normal #1;Arguments = 40000000000l, 3
dot.junit.opcodes.shr_long_2addr.Main_testN2;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_1 ;shr-long/2addr;Normal #2;Arguments = 40000000000l, 1
dot.junit.opcodes.shr_long_2addr.Main_testN3;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_1 ;shr-long/2addr;Normal #3;Arguments = -40000000000l, 1
dot.junit.opcodes.shr_long_2addr.Main_testN4;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_1 ;shr-long/2addr;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.shr_long_2addr.Main_testN5;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_1 ;shr-long/2addr;Normal #5;Verify that shift distance is actually in range 0 to 64.
dot.junit.opcodes.shr_long_2addr.Main_testN6;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_7 ;shr-long/2addr;Normal #6;Types of arguments - double, int. Dalvik doens't distinguish 64-bits types internally, so this operation of double and int makes no sense but shall not crash the VM.
dot.junit.opcodes.shr_long_2addr.Main_testVFE1;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_2 ;shr-long/2addr;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.shr_long_2addr.Main_testVFE2;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_3 ;shr-long/2addr;Verifier #2; Constraint B1, types of arguments - long, double
dot.junit.opcodes.shr_long_2addr.Main_testVFE3;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_4 ;shr-long/2addr;Verifier #3; Constraint B1, types of arguments - int, int
dot.junit.opcodes.shr_long_2addr.Main_testVFE4;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_5 ;shr-long/2addr;Verifier #4; Constraint B1, types of arguments - float, int
dot.junit.opcodes.shr_long_2addr.Main_testVFE5;dot.junit.opcodes.shr_long_2addr.d.T_shr_long_2addr_6 ;shr-long/2addr;Verifier #5; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.shr_long.Main_testB1;dot.junit.opcodes.shr_long.d.T_shr_long_1 ;shr-long;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.shr_long.Main_testB2;dot.junit.opcodes.shr_long.d.T_shr_long_1 ;shr-long;Boundary #2;Arguments = 1 & 0
dot.junit.opcodes.shr_long.Main_testB3;dot.junit.opcodes.shr_long.d.T_shr_long_1 ;shr-long;Boundary #3;Arguments = Long.MAX_VALUE & 1
dot.junit.opcodes.shr_long.Main_testB4;dot.junit.opcodes.shr_long.d.T_shr_long_1 ;shr-long;Boundary #4;Arguments = Long.MIN_VALUE & 1
dot.junit.opcodes.shr_long.Main_testN1;dot.junit.opcodes.shr_long.d.T_shr_long_1 ;shr-long;Normal #1;Arguments =  40000000000l, 3
dot.junit.opcodes.shr_long.Main_testN2;dot.junit.opcodes.shr_long.d.T_shr_long_1 ;shr-long;Normal #2;Arguments = 40000000000l, 1
dot.junit.opcodes.shr_long.Main_testN3;dot.junit.opcodes.shr_long.d.T_shr_long_1 ;shr-long;Normal #3;Arguments = -40000000000l, 1
dot.junit.opcodes.shr_long.Main_testN4;dot.junit.opcodes.shr_long.d.T_shr_long_1 ;shr-long;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.shr_long.Main_testN5;dot.junit.opcodes.shr_long.d.T_shr_long_1 ;shr-long;Normal #5;Verify that shift distance is actually in range 0 to 64.
dot.junit.opcodes.shr_long.Main_testN6;dot.junit.opcodes.shr_long.d.T_shr_long_7 ;shr-long;Normal #6;Types of arguments - double, int. Dalvik doens't distinguish 64-bits types internally, so this operation of double and int makes no sense but shall not crash the VM.
dot.junit.opcodes.shr_long.Main_testVFE1;dot.junit.opcodes.shr_long.d.T_shr_long_2 ;shr-long;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.shr_long.Main_testVFE2;dot.junit.opcodes.shr_long.d.T_shr_long_3 ;shr-long;Verifier #2; Constraint B1, types of arguments - long, double
dot.junit.opcodes.shr_long.Main_testVFE3;dot.junit.opcodes.shr_long.d.T_shr_long_4 ;shr-long;Verifier #3; Constraint B1, types of arguments - int, int
dot.junit.opcodes.shr_long.Main_testVFE4;dot.junit.opcodes.shr_long.d.T_shr_long_5 ;shr-long;Verifier #4; Constraint B1, types of arguments - float, int
dot.junit.opcodes.shr_long.Main_testVFE5;dot.junit.opcodes.shr_long.d.T_shr_long_6 ;shr-long;Verifier #5; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.sparse_switch.Main_testB1;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_1 ;sparse-switch;Boundary #1;Argument = Integer.MAX_VALUE
dot.junit.opcodes.sparse_switch.Main_testB2;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_1 ;sparse-switch;Boundary #2;Argument = Integer.MIN_VALUE
dot.junit.opcodes.sparse_switch.Main_testB3;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_1 ;sparse-switch;Boundary #3;Argument = 0
dot.junit.opcodes.sparse_switch.Main_testN1;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_1 ;sparse-switch;Normal #1;Try different values
dot.junit.opcodes.sparse_switch.Main_testN2;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_2 ;sparse-switch;Normal #2;Types of arguments - float, int. Dalvik doens't distinguish 32-bits types internally, so this operation of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.sparse_switch.Main_testVFE1;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_3 ;sparse-switch;Verifier #1; Constraint A23, number of registers
dot.junit.opcodes.sparse_switch.Main_testVFE10;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_12 ;sparse-switch;Verifier #10; Constraint A8, number of entries in jump table
dot.junit.opcodes.sparse_switch.Main_testVFE11;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_13 ;sparse-switch;Verifier #11; Constraint B22, sparse-switch-data pseudo-instructions must not be reachable by control flow
dot.junit.opcodes.sparse_switch.Main_testVFE12;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_14 ;sparse-switch;Verifier #12; Constraint A8, table has wrong ident code
dot.junit.opcodes.sparse_switch.Main_testVFE2;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_4 ;sparse-switch;Verifier #2; Constraint B1, type of argument - double
dot.junit.opcodes.sparse_switch.Main_testVFE3;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_5 ;sparse-switch;Verifier #3; Constraint B1, type of argument - long
dot.junit.opcodes.sparse_switch.Main_testVFE4;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_6 ;sparse-switch;Verifier #4; Constraint B1, type of argument - reference
dot.junit.opcodes.sparse_switch.Main_testVFE5;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_7 ;sparse-switch;Verifier #5; Constraint A8, branch target shall be inside the method
dot.junit.opcodes.sparse_switch.Main_testVFE6;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_8 ;sparse-switch;Verifier #6; Constraint A8, branch target shall not be "inside" instruction
dot.junit.opcodes.sparse_switch.Main_testVFE7;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_9 ;sparse-switch;Verifier #7; Constraint A8, offset to table shall be inside method
dot.junit.opcodes.sparse_switch.Main_testVFE9;dot.junit.opcodes.sparse_switch.d.T_sparse_switch_11 ;sparse-switch;Verifier #9; Constraint A8, pairs shall be sorted in ascending order
dot.junit.opcodes.sput_boolean.Main_testE6;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_13 ;sput-boolean;Exception #6;Initialization of referenced class throws exception
dot.junit.opcodes.sput_boolean.Main_testN1;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_1 ;sput-boolean;Normal #1;Put boolean into static field
dot.junit.opcodes.sput_boolean.Main_testN2;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_12 ;sput-boolean;Normal #2;Modification of final field
dot.junit.opcodes.sput_boolean.Main_testN4;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_14 dot.junit.opcodes.sput_boolean.d.T_sput_boolean_1 ;sput-boolean;Normal #4;Modification of protected field from subclass
dot.junit.opcodes.sput_boolean.Main_testVFE1;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_3 ;sput-boolean;Verifier #1; Constraint A12, constant pool index
dot.junit.opcodes.sput_boolean.Main_testVFE10;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_9 ;sput-boolean;Verifier #10; Constraint n/a, Attempt to modify field of undefined class.
dot.junit.opcodes.sput_boolean.Main_testVFE11;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_10 ;sput-boolean;Verifier #11; Constraint n/a, Attempt to modify undefined field.
dot.junit.opcodes.sput_boolean.Main_testVFE12;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_15 dot.junit.opcodes.sput_boolean.d.T_sput_boolean_1 ;sput-boolean;Verifier #12; Constraint n/a, Attempt to modify superclass' private field from subclass.
dot.junit.opcodes.sput_boolean.Main_testVFE13;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_2 ;sput-boolean;Verifier #13; Constraint B1, sput_boolean shall not work for wide numbers
dot.junit.opcodes.sput_boolean.Main_testVFE14;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_20 ;sput-boolean;Verifier #14; Constraint B1, sput_boolean shall not work for reference fields
dot.junit.opcodes.sput_boolean.Main_testVFE15;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_21 ;sput-boolean;Verifier #15; Constraint B1, sput_boolean shall not work for short fields
dot.junit.opcodes.sput_boolean.Main_testVFE16;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_22 ;sput-boolean;Verifier #16; Constraint B1, sput_boolean shall not work for int fields
dot.junit.opcodes.sput_boolean.Main_testVFE17;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_23 ;sput-boolean;Verifier #17; Constraint B1, sput_boolean shall not work for char fields
dot.junit.opcodes.sput_boolean.Main_testVFE18;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_24 ;sput-boolean;Verifier #18; Constraint B1, sput_boolean shall not work for byte fields
dot.junit.opcodes.sput_boolean.Main_testVFE19;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_11 dot.junit.opcodes.sput_boolean.TestStubs ;sput-boolean;Verifier #19; Constraint B1, Modification of final field in other class.
dot.junit.opcodes.sput_boolean.Main_testVFE2;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_4 ;sput-boolean;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.sput_boolean.Main_testVFE5;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_17 ;sput-boolean;Verifier #5; Constraint B13, put boolean into long field - only field with same name but different type exists
dot.junit.opcodes.sput_boolean.Main_testVFE6;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_6 ;sput-boolean;Verifier #6; Constraint B13, put value '2' into boolean field
dot.junit.opcodes.sput_boolean.Main_testVFE7;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_18 ;sput-boolean;Verifier #7; Constraint B13, type of field doesn't match opcode - attempt to modify double field with single-width register
dot.junit.opcodes.sput_boolean.Main_testVFE8;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_7 ;sput-boolean;Verifier #8; Constraint A12, Attempt to set non-static field.
dot.junit.opcodes.sput_boolean.Main_testVFE9;dot.junit.opcodes.sput_boolean.d.T_sput_boolean_8 dot.junit.opcodes.sput_boolean.TestStubs ;sput-boolean;Verifier #9; Constraint n/a, Attempt to modify inaccessible field.
dot.junit.opcodes.sput_byte.Main_testE6;dot.junit.opcodes.sput_byte.d.T_sput_byte_13 ;sput-byte;Exception #6;Initialization of referenced class throws exception
dot.junit.opcodes.sput_byte.Main_testN1;dot.junit.opcodes.sput_byte.d.T_sput_byte_1 ;sput-byte;Normal #1;Put byte into static field
dot.junit.opcodes.sput_byte.Main_testN2;dot.junit.opcodes.sput_byte.d.T_sput_byte_12 ;sput-byte;Normal #2;Modification of final field
dot.junit.opcodes.sput_byte.Main_testN4;dot.junit.opcodes.sput_byte.d.T_sput_byte_14 dot.junit.opcodes.sput_byte.d.T_sput_byte_1 ;sput-byte;Normal #4;Modification of protected field from subclass
dot.junit.opcodes.sput_byte.Main_testVFE1;dot.junit.opcodes.sput_byte.d.T_sput_byte_3 ;sput-byte;Verifier #1; Constraint A12, constant pool index
dot.junit.opcodes.sput_byte.Main_testVFE10;dot.junit.opcodes.sput_byte.d.T_sput_byte_9 ;sput-byte;Verifier #10; Constraint n/a, Attempt to modify field of undefined class.
dot.junit.opcodes.sput_byte.Main_testVFE11;dot.junit.opcodes.sput_byte.d.T_sput_byte_10 ;sput-byte;Verifier #11; Constraint n/a, Attempt to modify undefined field.
dot.junit.opcodes.sput_byte.Main_testVFE12;dot.junit.opcodes.sput_byte.d.T_sput_byte_15 dot.junit.opcodes.sput_byte.d.T_sput_byte_1 ;sput-byte;Verifier #12; Constraint n/a, Attempt to modify superclass' private field from subclass.
dot.junit.opcodes.sput_byte.Main_testVFE13;dot.junit.opcodes.sput_byte.d.T_sput_byte_2 ;sput-byte;Verifier #13; Constraint B1, sput-byte shall not work for wide numbers
dot.junit.opcodes.sput_byte.Main_testVFE14;dot.junit.opcodes.sput_byte.d.T_sput_byte_20 ;sput-byte;Verifier #14; Constraint B1, sput-byte shall not work for reference fields
dot.junit.opcodes.sput_byte.Main_testVFE15;dot.junit.opcodes.sput_byte.d.T_sput_byte_21 ;sput-byte;Verifier #15; Constraint B1, sput-byte shall not work for short fields
dot.junit.opcodes.sput_byte.Main_testVFE16;dot.junit.opcodes.sput_byte.d.T_sput_byte_22 ;sput-byte;Verifier #16; Constraint B1, sput-byte shall not work for int fields
dot.junit.opcodes.sput_byte.Main_testVFE17;dot.junit.opcodes.sput_byte.d.T_sput_byte_23 ;sput-byte;Verifier #17; Constraint B1, sput-byte shall not work for char fields
dot.junit.opcodes.sput_byte.Main_testVFE18;dot.junit.opcodes.sput_byte.d.T_sput_byte_24 ;sput-byte;Verifier #18; Constraint B1, sput-byte shall not work for boolean fields
dot.junit.opcodes.sput_byte.Main_testVFE19;dot.junit.opcodes.sput_byte.TestStubs dot.junit.opcodes.sput_byte.d.T_sput_byte_11 ;sput-byte;Verifier #19; Constraint n/a, Modification of final field in other class
dot.junit.opcodes.sput_byte.Main_testVFE2;dot.junit.opcodes.sput_byte.d.T_sput_byte_4 ;sput-byte;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.sput_byte.Main_testVFE5;dot.junit.opcodes.sput_byte.d.T_sput_byte_17 ;sput-byte;Verifier #5; Constraint B13, put byte into long field - only field with same name but different type exists
dot.junit.opcodes.sput_byte.Main_testVFE6;dot.junit.opcodes.sput_byte.d.T_sput_byte_6 ;sput-byte;Verifier #6; Constraint B13, put value '256' into byte field
dot.junit.opcodes.sput_byte.Main_testVFE7;dot.junit.opcodes.sput_byte.d.T_sput_byte_18 ;sput-byte;Verifier #7; Constraint B13, type of field doesn't match opcode - attempt to modify double field with single-width register
dot.junit.opcodes.sput_byte.Main_testVFE8;dot.junit.opcodes.sput_byte.d.T_sput_byte_7 ;sput-byte;Verifier #8; Constraint A12, Attempt to set non-static field.
dot.junit.opcodes.sput_byte.Main_testVFE9;dot.junit.opcodes.sput_byte.d.T_sput_byte_8 dot.junit.opcodes.sput_byte.TestStubs ;sput-byte;Verifier #9; Constraint n/a, Attempt to modify inaccessible field.
dot.junit.opcodes.sput_char.Main_testE6;dot.junit.opcodes.sput_char.d.T_sput_char_13 ;sput-char;Exception #6;Initialization of referenced class throws exception
dot.junit.opcodes.sput_char.Main_testN1;dot.junit.opcodes.sput_char.d.T_sput_char_1 ;sput-char;Normal #1;Put char into static field
dot.junit.opcodes.sput_char.Main_testN2;dot.junit.opcodes.sput_char.d.T_sput_char_12 ;sput-char;Normal #2;Modification of final field
dot.junit.opcodes.sput_char.Main_testN4;dot.junit.opcodes.sput_char.d.T_sput_char_1 dot.junit.opcodes.sput_char.d.T_sput_char_14 ;sput-char;Normal #4;Modification of protected field from subclass
dot.junit.opcodes.sput_char.Main_testVFE1;dot.junit.opcodes.sput_char.d.T_sput_char_3 ;sput-char;Verifier #1; Constraint A12, constant pool index
dot.junit.opcodes.sput_char.Main_testVFE10;dot.junit.opcodes.sput_char.d.T_sput_char_9 ;sput-char;Verifier #10; Constraint n/a, Attempt to modify field of undefined class.
dot.junit.opcodes.sput_char.Main_testVFE11;dot.junit.opcodes.sput_char.d.T_sput_char_10 ;sput-char;Verifier #11; Constraint n/a, Attempt to modify undefined field.
dot.junit.opcodes.sput_char.Main_testVFE12;dot.junit.opcodes.sput_char.d.T_sput_char_1 dot.junit.opcodes.sput_char.d.T_sput_char_15 ;sput-char;Verifier #12; Constraint n/a, Attempt to modify superclass' private field from subclass.
dot.junit.opcodes.sput_char.Main_testVFE13;dot.junit.opcodes.sput_char.d.T_sput_char_2 ;sput-char;Verifier #13; Constraint B1, sput-char shall not work for wide numbers
dot.junit.opcodes.sput_char.Main_testVFE14;dot.junit.opcodes.sput_char.d.T_sput_char_20 ;sput-char;Verifier #14; Constraint B1, sput-char shall not work for reference fields
dot.junit.opcodes.sput_char.Main_testVFE15;dot.junit.opcodes.sput_char.d.T_sput_char_21 ;sput-char;Verifier #15; Constraint B1, sput-char shall not work for short fields
dot.junit.opcodes.sput_char.Main_testVFE16;dot.junit.opcodes.sput_char.d.T_sput_char_22 ;sput-char;Verifier #16; Constraint B1, sput-char shall not work for int fields
dot.junit.opcodes.sput_char.Main_testVFE17;dot.junit.opcodes.sput_char.d.T_sput_char_23 ;sput-char;Verifier #17; Constraint B1, sput-char shall not work for byte fields
dot.junit.opcodes.sput_char.Main_testVFE18;dot.junit.opcodes.sput_char.d.T_sput_char_24 ;sput-char;Verifier #18; Constraint B1, sput-char shall not work for boolean fields
dot.junit.opcodes.sput_char.Main_testVFE19;dot.junit.opcodes.sput_char.TestStubs dot.junit.opcodes.sput_char.d.T_sput_char_11 ;sput-char;Verifier #19; Constraint n/a, Modification of final field in other class
dot.junit.opcodes.sput_char.Main_testVFE2;dot.junit.opcodes.sput_char.d.T_sput_char_4 ;sput-char;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.sput_char.Main_testVFE5;dot.junit.opcodes.sput_char.d.T_sput_char_17 ;sput-char;Verifier #5; Constraint B13, put char into long field - only field with same name but different type exists
dot.junit.opcodes.sput_char.Main_testVFE6;dot.junit.opcodes.sput_char.d.T_sput_char_6 ;sput-char;Verifier #6; Constraint B13, put value '66000' into byte field
dot.junit.opcodes.sput_char.Main_testVFE7;dot.junit.opcodes.sput_char.d.T_sput_char_18 ;sput-char;Verifier #7; Constraint B13, type of field doesn't match opcode - attempt to modify double field with single-width register
dot.junit.opcodes.sput_char.Main_testVFE8;dot.junit.opcodes.sput_char.d.T_sput_char_7 ;sput-char;Verifier #8; Constraint A12, Attempt to set non-static field.
dot.junit.opcodes.sput_char.Main_testVFE9;dot.junit.opcodes.sput_char.TestStubs dot.junit.opcodes.sput_char.d.T_sput_char_8 ;sput-char;Verifier #9; Constraint n/a, Attempt to modify inaccessible field.
dot.junit.opcodes.sput_object.Main_testE6;dot.junit.opcodes.sput_object.d.T_sput_object_13 ;sput-object;Exception #6;Initialization of referenced class throws exception
dot.junit.opcodes.sput_object.Main_testN1;dot.junit.opcodes.sput_object.d.T_sput_object_1 ;sput-object;Normal #1;Put reference into static field
dot.junit.opcodes.sput_object.Main_testN2;dot.junit.opcodes.sput_object.d.T_sput_object_12 ;sput-object;Normal #2;Modification of final field
dot.junit.opcodes.sput_object.Main_testN4;dot.junit.opcodes.sput_object.d.T_sput_object_1 dot.junit.opcodes.sput_object.d.T_sput_object_14 ;sput-object;Normal #4;Modification of protected field from subclass
dot.junit.opcodes.sput_object.Main_testVFE1;dot.junit.opcodes.sput_object.d.T_sput_object_3 ;sput-object;Verifier #1; Constraint A12, constant pool index
dot.junit.opcodes.sput_object.Main_testVFE10;dot.junit.opcodes.sput_object.d.T_sput_object_9 ;sput-object;Verifier #10; Constraint n/a, Attempt to modify field of undefined class.
dot.junit.opcodes.sput_object.Main_testVFE11;dot.junit.opcodes.sput_object.d.T_sput_object_10 ;sput-object;Verifier #11; Constraint n/a, Attempt to modify undefined field.
dot.junit.opcodes.sput_object.Main_testVFE12;dot.junit.opcodes.sput_object.d.T_sput_object_1 dot.junit.opcodes.sput_object.d.T_sput_object_15 ;sput-object;Verifier #12; Constraint n/a, Attempt to modify superclass' private field from subclass.
dot.junit.opcodes.sput_object.Main_testVFE13;dot.junit.opcodes.sput_object.d.T_sput_object_2 ;sput-object;Verifier #13; Constraint B1, sput-object shall not work for wide numbers
dot.junit.opcodes.sput_object.Main_testVFE14;dot.junit.opcodes.sput_object.d.T_sput_object_20 ;sput-object;Verifier #14; Constraint B13, assignment incompatible references
dot.junit.opcodes.sput_object.Main_testVFE15;dot.junit.opcodes.sput_object.d.T_sput_object_21 ;sput-object;Verifier #15; Constraint B1, sput-object shall not work for char fields
dot.junit.opcodes.sput_object.Main_testVFE16;dot.junit.opcodes.sput_object.d.T_sput_object_22 ;sput-object;Verifier #16; Constraint B1, sput-object shall not work for int fields
dot.junit.opcodes.sput_object.Main_testVFE17;dot.junit.opcodes.sput_object.d.T_sput_object_23 ;sput-object;Verifier #17; Constraint B1, sput-object shall not work for byte fields
dot.junit.opcodes.sput_object.Main_testVFE18;dot.junit.opcodes.sput_object.d.T_sput_object_24 ;sput-object;Verifier #18; Constraint B1, sput-object shall not work for boolean fields
dot.junit.opcodes.sput_object.Main_testVFE19;dot.junit.opcodes.sput_object.TestStubs dot.junit.opcodes.sput_object.d.T_sput_object_11 ;sput-object;Verifier #19; Constraint B1, Modification of final field in other class
dot.junit.opcodes.sput_object.Main_testVFE2;dot.junit.opcodes.sput_object.d.T_sput_object_4 ;sput-object;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.sput_object.Main_testVFE5;dot.junit.opcodes.sput_object.d.T_sput_object_17 ;sput-object;Verifier #5; Constraint B13, put object into long field - only field with same name but different type exists
dot.junit.opcodes.sput_object.Main_testVFE6;dot.junit.opcodes.sput_object.d.T_sput_object_6 ;sput-object;Verifier #6; Constraint B1, sput-object shall not work for short fields
dot.junit.opcodes.sput_object.Main_testVFE7;dot.junit.opcodes.sput_object.d.T_sput_object_18 ;sput-object;Verifier #7; Constraint B13, type of field doesn't match opcode - attempt to modify double field with single-width register
dot.junit.opcodes.sput_object.Main_testVFE8;dot.junit.opcodes.sput_object.d.T_sput_object_7 ;sput-object;Verifier #8; Constraint A12, Attempt to set non-static field.
dot.junit.opcodes.sput_object.Main_testVFE9;dot.junit.opcodes.sput_object.TestStubs dot.junit.opcodes.sput_object.d.T_sput_object_8 ;sput-object;Verifier #9; Constraint n/a, Attempt to modify inaccessible field.
dot.junit.opcodes.sput_short.Main_testE6;dot.junit.opcodes.sput_short.d.T_sput_short_13 ;sput-short;Exception #6;Initialization of referenced class throws exception
dot.junit.opcodes.sput_short.Main_testN1;dot.junit.opcodes.sput_short.d.T_sput_short_1 ;sput-short;Normal #1;Put short into static field
dot.junit.opcodes.sput_short.Main_testN2;dot.junit.opcodes.sput_short.d.T_sput_short_12 ;sput-short;Normal #2;Modification of final field
dot.junit.opcodes.sput_short.Main_testN4;dot.junit.opcodes.sput_short.d.T_sput_short_1 dot.junit.opcodes.sput_short.d.T_sput_short_14 ;sput-short;Normal #4;Modification of protected field from subclass
dot.junit.opcodes.sput_short.Main_testVFE1;dot.junit.opcodes.sput_short.d.T_sput_short_3 ;sput-short;Verifier #1; Constraint A12, constant pool index
dot.junit.opcodes.sput_short.Main_testVFE10;dot.junit.opcodes.sput_short.d.T_sput_short_9 ;sput-short;Verifier #10; Constraint n/a, Attempt to modify field of undefined class.
dot.junit.opcodes.sput_short.Main_testVFE11;dot.junit.opcodes.sput_short.d.T_sput_short_10 ;sput-short;Verifier #11; Constraint n/a, Attempt to modify undefined field.
dot.junit.opcodes.sput_short.Main_testVFE12;dot.junit.opcodes.sput_short.d.T_sput_short_1 dot.junit.opcodes.sput_short.d.T_sput_short_15 ;sput-short;Verifier #12; Constraint n/a, Attempt to modify superclass' private field from subclass.
dot.junit.opcodes.sput_short.Main_testVFE13;dot.junit.opcodes.sput_short.d.T_sput_short_2 ;sput-short;Verifier #13; Constraint B1, sput-short shall not work for wide numbers
dot.junit.opcodes.sput_short.Main_testVFE14;dot.junit.opcodes.sput_short.d.T_sput_short_20 ;sput-short;Verifier #14; Constraint B1, sput-short shall not work for reference fields
dot.junit.opcodes.sput_short.Main_testVFE15;dot.junit.opcodes.sput_short.d.T_sput_short_21 ;sput-short;Verifier #15; Constraint B1, sput-short shall not work for char fields
dot.junit.opcodes.sput_short.Main_testVFE16;dot.junit.opcodes.sput_short.d.T_sput_short_22 ;sput-short;Verifier #16; Constraint B1, sput-short shall not work for int fields
dot.junit.opcodes.sput_short.Main_testVFE17;dot.junit.opcodes.sput_short.d.T_sput_short_23 ;sput-short;Verifier #17; Constraint B1, sput-short shall not work for byte fields
dot.junit.opcodes.sput_short.Main_testVFE18;dot.junit.opcodes.sput_short.d.T_sput_short_24 ;sput-short;Verifier #18; Constraint B1, sput-short shall not work for boolean fields
dot.junit.opcodes.sput_short.Main_testVFE19;dot.junit.opcodes.sput_short.TestStubs dot.junit.opcodes.sput_short.d.T_sput_short_11 ;sput-short;Verifier #19; Constraint n/a, Modification of final field in other class
dot.junit.opcodes.sput_short.Main_testVFE2;dot.junit.opcodes.sput_short.d.T_sput_short_4 ;sput-short;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.sput_short.Main_testVFE5;dot.junit.opcodes.sput_short.d.T_sput_short_17 ;sput-short;Verifier #5; Constraint B13, put short into long field - only field with same name but different type exists
dot.junit.opcodes.sput_short.Main_testVFE6;dot.junit.opcodes.sput_short.d.T_sput_short_6 ;sput-short;Verifier #6; Constraint B13, put value '66000' into byte field
dot.junit.opcodes.sput_short.Main_testVFE7;dot.junit.opcodes.sput_short.d.T_sput_short_18 ;sput-short;Verifier #7; Constraint B13, type of field doesn't match opcode - attempt to modify double field with single-width register
dot.junit.opcodes.sput_short.Main_testVFE8;dot.junit.opcodes.sput_short.d.T_sput_short_7 ;sput-short;Verifier #8; Constraint A12, Attempt to set non-static field.
dot.junit.opcodes.sput_short.Main_testVFE9;dot.junit.opcodes.sput_short.TestStubs dot.junit.opcodes.sput_short.d.T_sput_short_8 ;sput-short;Verifier #9; Constraint n/a, Attempt to modify inaccessible field.
dot.junit.opcodes.sput.Main_testE6;dot.junit.opcodes.sput.d.T_sput_13 ;sput;Exception #6;Initialization of referenced class throws exception
dot.junit.opcodes.sput.Main_testN1;dot.junit.opcodes.sput.d.T_sput_1 ;sput;Normal #1;Type - int
dot.junit.opcodes.sput.Main_testN2;dot.junit.opcodes.sput.d.T_sput_19 ;sput;Normal #2;Type - float
dot.junit.opcodes.sput.Main_testN3;dot.junit.opcodes.sput.d.T_sput_12 ;sput;Normal #3;Modification of final field
dot.junit.opcodes.sput.Main_testN4;dot.junit.opcodes.sput.d.T_sput_14 dot.junit.opcodes.sput.d.T_sput_1 ;sput;Normal #4;Modification of protected field from subclass
dot.junit.opcodes.sput.Main_testN6;dot.junit.opcodes.sput.d.T_sput_5 ;sput;Normal #6;Trying to put float into integer field. Dalvik doens't distinguish 32-bits types internally, so this operation makes no sense but shall not crash the VM.
dot.junit.opcodes.sput.Main_testVFE1;dot.junit.opcodes.sput.d.T_sput_3 ;sput;Verifier #1; Constraint A12, constant pool index
dot.junit.opcodes.sput.Main_testVFE10;dot.junit.opcodes.sput.d.T_sput_9 ;sput;Verifier #10; Constraint n/a, Attempt to modify field of undefined class.
dot.junit.opcodes.sput.Main_testVFE11;dot.junit.opcodes.sput.d.T_sput_10 ;sput;Verifier #11; Constraint n/a, Attempt to modify undefined field.
dot.junit.opcodes.sput.Main_testVFE12;dot.junit.opcodes.sput.d.T_sput_15 dot.junit.opcodes.sput.d.T_sput_1 ;sput;Verifier #12; Constraint n/a, Attempt to modify superclass' private field from subclass.
dot.junit.opcodes.sput.Main_testVFE13;dot.junit.opcodes.sput.d.T_sput_2 ;sput;Verifier #13; Constraint B1, sput shall not work for wide numbers
dot.junit.opcodes.sput.Main_testVFE14;dot.junit.opcodes.sput.d.T_sput_20 ;sput;Verifier #14; Constraint B1, sput shall not work for reference fields
dot.junit.opcodes.sput.Main_testVFE15;dot.junit.opcodes.sput.d.T_sput_21 ;sput;Verifier #15; Constraint B1, sput shall not work for short fields
dot.junit.opcodes.sput.Main_testVFE16;dot.junit.opcodes.sput.d.T_sput_22 ;sput;Verifier #16; Constraint B1, sput shall not work for boolean fields
dot.junit.opcodes.sput.Main_testVFE17;dot.junit.opcodes.sput.d.T_sput_23 ;sput;Verifier #17; Constraint B1, sput shall not work for char fields
dot.junit.opcodes.sput.Main_testVFE18;dot.junit.opcodes.sput.d.T_sput_24 ;sput;Verifier #18; Constraint B1, sput shall not work for byte fields
dot.junit.opcodes.sput.Main_testVFE19;dot.junit.opcodes.sput.TestStubs dot.junit.opcodes.sput.d.T_sput_11 ;sput;Verifier #19; Constraint n/a, Modification of final field in other class
dot.junit.opcodes.sput.Main_testVFE2;dot.junit.opcodes.sput.d.T_sput_4 ;sput;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.sput.Main_testVFE5;dot.junit.opcodes.sput.d.T_sput_17 ;sput;Verifier #5; Constraint B13, put integer into long field - only field with same name but different type exists
dot.junit.opcodes.sput.Main_testVFE7;dot.junit.opcodes.sput.d.T_sput_18 ;sput;Verifier #7; Constraint B13, type of field doesn't match opcode - attempt to modify double field with single-width register
dot.junit.opcodes.sput.Main_testVFE8;dot.junit.opcodes.sput.d.T_sput_7 ;sput;Verifier #8; Constraint A12, Attempt to set non-static field.
dot.junit.opcodes.sput.Main_testVFE9;dot.junit.opcodes.sput.TestStubs dot.junit.opcodes.sput.d.T_sput_8 ;sput;Verifier #9; Constraint n/a, Attempt to modify inaccessible field.
dot.junit.opcodes.sput_wide.Main_testE6;dot.junit.opcodes.sput_wide.d.T_sput_wide_13 ;sput-wide;Exception #6;Initialization of referenced class throws exception
dot.junit.opcodes.sput_wide.Main_testN1;dot.junit.opcodes.sput_wide.d.T_sput_wide_1 ;sput-wide;Normal #1;Put long into static field
dot.junit.opcodes.sput_wide.Main_testN2;dot.junit.opcodes.sput_wide.d.T_sput_wide_5 ;sput-wide;Normal #2;Put double into static field
dot.junit.opcodes.sput_wide.Main_testN3;dot.junit.opcodes.sput_wide.d.T_sput_wide_12 ;sput-wide;Normal #3;Modification of final field
dot.junit.opcodes.sput_wide.Main_testN4;dot.junit.opcodes.sput_wide.d.T_sput_wide_1 dot.junit.opcodes.sput_wide.d.T_sput_wide_14 ;sput-wide;Normal #4;Modification of protected field from subclass
dot.junit.opcodes.sput_wide.Main_testVFE1;dot.junit.opcodes.sput_wide.d.T_sput_wide_3 ;sput-wide;Verifier #1; Constraint A12, constant pool index
dot.junit.opcodes.sput_wide.Main_testVFE10;dot.junit.opcodes.sput_wide.d.T_sput_wide_9 ;sput-wide;Verifier #10; Constraint n/a, Attempt to modify field of undefined class. Dalvik throws NoClassDefFoundError when executing the code.
dot.junit.opcodes.sput_wide.Main_testVFE11;dot.junit.opcodes.sput_wide.d.T_sput_wide_10 ;sput-wide;Verifier #11; Constraint n/a, Attempt to modify undefined field. Dalvik throws NoSuchFieldError when executing the code.
dot.junit.opcodes.sput_wide.Main_testVFE12;dot.junit.opcodes.sput_wide.d.T_sput_wide_1 dot.junit.opcodes.sput_wide.d.T_sput_wide_15 ;sput-wide;Verifier #12; Constraint n/a, Attempt to modify superclass' private field from subclass. Dalvik throws IllegalAccessError when executing the code.
dot.junit.opcodes.sput_wide.Main_testVFE13;dot.junit.opcodes.sput_wide.d.T_sput_wide_2 ;sput-wide;Verifier #13; Constraint B1, sput-wide shall not work for single-width numbers
dot.junit.opcodes.sput_wide.Main_testVFE14;dot.junit.opcodes.sput_wide.d.T_sput_wide_20 ;sput-wide;Verifier #14; Constraint B1, sput-wide shall not work for reference fields
dot.junit.opcodes.sput_wide.Main_testVFE15;dot.junit.opcodes.sput_wide.d.T_sput_wide_21 ;sput-wide;Verifier #15; Constraint B1, sput-wide shall not work for char fields
dot.junit.opcodes.sput_wide.Main_testVFE16;dot.junit.opcodes.sput_wide.d.T_sput_wide_22 ;sput-wide;Verifier #16; Constraint B1, sput-wide shall not work for int fields
dot.junit.opcodes.sput_wide.Main_testVFE17;dot.junit.opcodes.sput_wide.d.T_sput_wide_23 ;sput-wide;Verifier #17; Constraint B1, sput-wide shall not work for byte fields
dot.junit.opcodes.sput_wide.Main_testVFE18;dot.junit.opcodes.sput_wide.d.T_sput_wide_24 ;sput-wide;Verifier #18; Constraint B1, sput-wide shall not work for boolean fields
dot.junit.opcodes.sput_wide.Main_testVFE19;dot.junit.opcodes.sput_wide.TestStubs dot.junit.opcodes.sput_wide.d.T_sput_wide_11 ;sput-wide;Verifier #19; Constraint n/a, Modification of final field in other class
dot.junit.opcodes.sput_wide.Main_testVFE2;dot.junit.opcodes.sput_wide.d.T_sput_wide_4 ;sput-wide;Verifier #2; Constraint A23, number of registers
dot.junit.opcodes.sput_wide.Main_testVFE5;dot.junit.opcodes.sput_wide.d.T_sput_wide_17 ;sput-wide;Verifier #5; Constraint B13, put int into long field - only field with same name but different type exists
dot.junit.opcodes.sput_wide.Main_testVFE6;dot.junit.opcodes.sput_wide.d.T_sput_wide_6 ;sput-wide;Verifier #6; Constraint B1, sput-wide shall not work for short fields
dot.junit.opcodes.sput_wide.Main_testVFE7;dot.junit.opcodes.sput_wide.d.T_sput_wide_18 ;sput-wide;Verifier #7; Constraint B13, type of field doesn't match opcode - attempt to modify float field with double-width register
dot.junit.opcodes.sput_wide.Main_testVFE8;dot.junit.opcodes.sput_wide.d.T_sput_wide_7 ;sput-wide;Verifier #8; Constraint A12, Attempt to set non-static field.Dalvik throws IncompatibleClassChangeError when executing the code.
dot.junit.opcodes.sput_wide.Main_testVFE9;dot.junit.opcodes.sput_wide.TestStubs dot.junit.opcodes.sput_wide.d.T_sput_wide_8 ;sput-wide;Verifier #9; Constraint n/a, Attempt to modify inaccessible field. Dalvik throws IllegalAccessError when executing the code.
dot.junit.opcodes.sub_double_2addr.Main_testB1;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_1 ;sub-double/2addr;Boundary #1;Arguments = Double.MAX_VALUE, Double.NaN
dot.junit.opcodes.sub_double_2addr.Main_testB10;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_1 ;sub-double/2addr;Boundary #10;Arguments = Double.MIN_VALUE, 4.9E-324
dot.junit.opcodes.sub_double_2addr.Main_testB2;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_1 ;sub-double/2addr;Boundary #2;Arguments = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
dot.junit.opcodes.sub_double_2addr.Main_testB3;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_1 ;sub-double/2addr;Boundary #3;Arguments = Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY
dot.junit.opcodes.sub_double_2addr.Main_testB4;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_1 ;sub-double/2addr;Boundary #4;Arguments = Double.POSITIVE_INFINITY, -2.7d
dot.junit.opcodes.sub_double_2addr.Main_testB5;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_1 ;sub-double/2addr;Boundary #5;Arguments = +0, -0d
dot.junit.opcodes.sub_double_2addr.Main_testB6;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_1 ;sub-double/2addr;Boundary #6;Arguments = -0d, -0d
dot.junit.opcodes.sub_double_2addr.Main_testB7;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_1 ;sub-double/2addr;Boundary #7;Arguments = +0d, +0d
dot.junit.opcodes.sub_double_2addr.Main_testB8;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_1 ;sub-double/2addr;Boundary #8;Arguments = 2.7d, 2.7d
dot.junit.opcodes.sub_double_2addr.Main_testB9;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_1 ;sub-double/2addr;Boundary #9;Arguments = Double.MAX_VALUE, Double.MAX_VALUE
dot.junit.opcodes.sub_double_2addr.Main_testN1;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_1 ;sub-double/2addr;Normal #1;Arguments = 2.7d, 3.14d
dot.junit.opcodes.sub_double_2addr.Main_testN2;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_1 ;sub-double/2addr;Normal #2;Arguments = 0, -3.14d
dot.junit.opcodes.sub_double_2addr.Main_testN3;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_1 ;sub-double/2addr;Normal #3;
dot.junit.opcodes.sub_double_2addr.Main_testN4;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_3 ;sub-double/2addr;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this subtraction of double and long makes no sense but shall not crash the VM.
dot.junit.opcodes.sub_double_2addr.Main_testVFE1;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_2 ;sub-double/2addr;Verifier #1; Constraint B1, types of arguments - float, double
dot.junit.opcodes.sub_double_2addr.Main_testVFE2;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_5 ;sub-double/2addr;Verifier #2; Constraint A24, number of registers
dot.junit.opcodes.sub_double_2addr.Main_testVFE3;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_4 ;sub-double/2addr;Verifier #3; Constraint B1, types of arguments - double, reference
dot.junit.opcodes.sub_double_2addr.Main_testVFE4;dot.junit.opcodes.sub_double_2addr.d.T_sub_double_2addr_6 ;sub-double/2addr;Verifier #4; Constraint B1, types of arguments - int, int
dot.junit.opcodes.sub_double.Main_testB1;dot.junit.opcodes.sub_double.d.T_sub_double_1 ;sub-double;Boundary #1;Arguments = Double.MAX_VALUE, Double.NaN
dot.junit.opcodes.sub_double.Main_testB10;dot.junit.opcodes.sub_double.d.T_sub_double_1 ;sub-double;Boundary #10;Arguments = Double.MIN_VALUE, 4.9E-324
dot.junit.opcodes.sub_double.Main_testB2;dot.junit.opcodes.sub_double.d.T_sub_double_1 ;sub-double;Boundary #2;Arguments = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
dot.junit.opcodes.sub_double.Main_testB3;dot.junit.opcodes.sub_double.d.T_sub_double_1 ;sub-double;Boundary #3;Arguments = Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY
dot.junit.opcodes.sub_double.Main_testB4;dot.junit.opcodes.sub_double.d.T_sub_double_1 ;sub-double;Boundary #4;Arguments = Double.POSITIVE_INFINITY, -2.7d
dot.junit.opcodes.sub_double.Main_testB5;dot.junit.opcodes.sub_double.d.T_sub_double_1 ;sub-double;Boundary #5;Arguments = +0, -0d
dot.junit.opcodes.sub_double.Main_testB6;dot.junit.opcodes.sub_double.d.T_sub_double_1 ;sub-double;Boundary #6;Arguments = -0d, -0d
dot.junit.opcodes.sub_double.Main_testB7;dot.junit.opcodes.sub_double.d.T_sub_double_1 ;sub-double;Boundary #7;Arguments = +0d, +0d
dot.junit.opcodes.sub_double.Main_testB8;dot.junit.opcodes.sub_double.d.T_sub_double_1 ;sub-double;Boundary #8;Arguments = 2.7d, 2.7d
dot.junit.opcodes.sub_double.Main_testB9;dot.junit.opcodes.sub_double.d.T_sub_double_1 ;sub-double;Boundary #9;Arguments = Double.MAX_VALUE, Double.MAX_VALUE
dot.junit.opcodes.sub_double.Main_testN1;dot.junit.opcodes.sub_double.d.T_sub_double_1 ;sub-double;Normal #1;Arguments = 2.7d, 3.14d
dot.junit.opcodes.sub_double.Main_testN2;dot.junit.opcodes.sub_double.d.T_sub_double_1 ;sub-double;Normal #2;Arguments = 0, -3.14d
dot.junit.opcodes.sub_double.Main_testN3;dot.junit.opcodes.sub_double.d.T_sub_double_1 ;sub-double;Normal #3;
dot.junit.opcodes.sub_double.Main_testN4;dot.junit.opcodes.sub_double.d.T_sub_double_3 ;sub-double;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this subtraction of double and long makes no sense but shall not crash the VM.
dot.junit.opcodes.sub_double.Main_testVFE1;dot.junit.opcodes.sub_double.d.T_sub_double_2 ;sub-double;Verifier #1; Constraint B1, types of arguments - float, double
dot.junit.opcodes.sub_double.Main_testVFE2;dot.junit.opcodes.sub_double.d.T_sub_double_5 ;sub-double;Verifier #2; Constraint A24, number of registers
dot.junit.opcodes.sub_double.Main_testVFE3;dot.junit.opcodes.sub_double.d.T_sub_double_4 ;sub-double;Verifier #3; Constraint B1, types of arguments - double, reference
dot.junit.opcodes.sub_double.Main_testVFE4;dot.junit.opcodes.sub_double.d.T_sub_double_6 ;sub-double;Verifier #4; Constraint B1, types of arguments - int, int
dot.junit.opcodes.sub_float_2addr.Main_testB1;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_1 ;sub-float/2addr;Boundary #1;Arguments = Float.MAX_VALUE, Float.NaN
dot.junit.opcodes.sub_float_2addr.Main_testB10;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_1 ;sub-float/2addr;Boundary #10;Arguments = Float.MIN_VALUE, -1.4E-45f
dot.junit.opcodes.sub_float_2addr.Main_testB11;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_1 ;sub-float/2addr;Boundary #11;Arguments = Float.MAX_VALUE, -Float.MAX_VALUE
dot.junit.opcodes.sub_float_2addr.Main_testB2;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_1 ;sub-float/2addr;Boundary #2;Arguments = Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY
dot.junit.opcodes.sub_float_2addr.Main_testB3;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_1 ;sub-float/2addr;Boundary #3;Arguments = Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY
dot.junit.opcodes.sub_float_2addr.Main_testB4;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_1 ;sub-float/2addr;Boundary #4;Arguments = Float.POSITIVE_INFINITY, -2.7f
dot.junit.opcodes.sub_float_2addr.Main_testB5;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_1 ;sub-float/2addr;Boundary #5;Arguments = +0, -0f
dot.junit.opcodes.sub_float_2addr.Main_testB6;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_1 ;sub-float/2addr;Boundary #6;Arguments = -0f, -0f
dot.junit.opcodes.sub_float_2addr.Main_testB7;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_1 ;sub-float/2addr;Boundary #7;Arguments = +0f, +0f
dot.junit.opcodes.sub_float_2addr.Main_testB8;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_1 ;sub-float/2addr;Boundary #8;Arguments = 2.7f, 2.7f
dot.junit.opcodes.sub_float_2addr.Main_testB9;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_1 ;sub-float/2addr;Boundary #9;Arguments = Float.MAX_VALUE, Float.MAX_VALUE
dot.junit.opcodes.sub_float_2addr.Main_testN1;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_1 ;sub-float/2addr;Normal #1;Arguments = 2.7f, 3.14f
dot.junit.opcodes.sub_float_2addr.Main_testN2;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_1 ;sub-float/2addr;Normal #2;Arguments = 0, -3.14f
dot.junit.opcodes.sub_float_2addr.Main_testN3;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_1 ;sub-float/2addr;Normal #3;
dot.junit.opcodes.sub_float_2addr.Main_testN4;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_5 ;sub-float/2addr;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this subtraction of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.sub_float_2addr.Main_testVFE2;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_2 ;sub-float/2addr;Verifier #2; Constraint B1, types of arguments - float, double
dot.junit.opcodes.sub_float_2addr.Main_testVFE3;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_3 ;sub-float/2addr;Verifier #3; Constraint B1, types of arguments - long, float
dot.junit.opcodes.sub_float_2addr.Main_testVFE4;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_4 ;sub-float/2addr;Verifier #4; Constraint B1, types of arguments - reference, float
dot.junit.opcodes.sub_float_2addr.Main_testVFE5;dot.junit.opcodes.sub_float_2addr.d.T_sub_float_2addr_6 ;sub-float/2addr;Verifier #5; Constraint A23, number of registers
dot.junit.opcodes.sub_float.Main_testB1;dot.junit.opcodes.sub_float.d.T_sub_float_1 ;sub-float;Boundary #1;Arguments = Float.MAX_VALUE, Float.NaN
dot.junit.opcodes.sub_float.Main_testB10;dot.junit.opcodes.sub_float.d.T_sub_float_1 ;sub-float;Boundary #10;Arguments = Float.MIN_VALUE, -1.4E-45f
dot.junit.opcodes.sub_float.Main_testB11;dot.junit.opcodes.sub_float.d.T_sub_float_1 ;sub-float;Boundary #11;Arguments = Float.MAX_VALUE, -Float.MAX_VALUE
dot.junit.opcodes.sub_float.Main_testB2;dot.junit.opcodes.sub_float.d.T_sub_float_1 ;sub-float;Boundary #2;Arguments = Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY
dot.junit.opcodes.sub_float.Main_testB3;dot.junit.opcodes.sub_float.d.T_sub_float_1 ;sub-float;Boundary #3;Arguments = Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY
dot.junit.opcodes.sub_float.Main_testB4;dot.junit.opcodes.sub_float.d.T_sub_float_1 ;sub-float;Boundary #4;Arguments = Float.POSITIVE_INFINITY, -2.7f
dot.junit.opcodes.sub_float.Main_testB5;dot.junit.opcodes.sub_float.d.T_sub_float_1 ;sub-float;Boundary #5;Arguments = +0, -0f
dot.junit.opcodes.sub_float.Main_testB6;dot.junit.opcodes.sub_float.d.T_sub_float_1 ;sub-float;Boundary #6;Arguments = -0f, -0f
dot.junit.opcodes.sub_float.Main_testB7;dot.junit.opcodes.sub_float.d.T_sub_float_1 ;sub-float;Boundary #7;Arguments = +0f, +0f
dot.junit.opcodes.sub_float.Main_testB8;dot.junit.opcodes.sub_float.d.T_sub_float_1 ;sub-float;Boundary #8;Arguments = 2.7f, 2.7f
dot.junit.opcodes.sub_float.Main_testB9;dot.junit.opcodes.sub_float.d.T_sub_float_1 ;sub-float;Boundary #9;Arguments = Float.MAX_VALUE, Float.MAX_VALUE
dot.junit.opcodes.sub_float.Main_testN1;dot.junit.opcodes.sub_float.d.T_sub_float_1 ;sub-float;Normal #1;Arguments = 2.7f, 3.14f
dot.junit.opcodes.sub_float.Main_testN2;dot.junit.opcodes.sub_float.d.T_sub_float_1 ;sub-float;Normal #2;Arguments = 0, -3.14f
dot.junit.opcodes.sub_float.Main_testN3;dot.junit.opcodes.sub_float.d.T_sub_float_1 ;sub-float;Normal #3;
dot.junit.opcodes.sub_float.Main_testN4;dot.junit.opcodes.sub_float.d.T_sub_float_5 ;sub-float;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this subtraction of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.sub_float.Main_testVFE2;dot.junit.opcodes.sub_float.d.T_sub_float_2 ;sub-float;Verifier #2; Constraint B1, types of arguments - float, double
dot.junit.opcodes.sub_float.Main_testVFE3;dot.junit.opcodes.sub_float.d.T_sub_float_3 ;sub-float;Verifier #3; Constraint B1, types of arguments - long, float
dot.junit.opcodes.sub_float.Main_testVFE4;dot.junit.opcodes.sub_float.d.T_sub_float_4 ;sub-float;Verifier #4; Constraint B1, types of arguments - reference, float
dot.junit.opcodes.sub_float.Main_testVFE5;dot.junit.opcodes.sub_float.d.T_sub_float_6 ;sub-float;Verifier #5; Constraint A23, number of registers
dot.junit.opcodes.sub_int_2addr.Main_testB1;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_1 ;sub-int/2addr;Boundary #1;Arguments = 0, Integer.MAX_VALUE
dot.junit.opcodes.sub_int_2addr.Main_testB2;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_1 ;sub-int/2addr;Boundary #2;Arguments = Integer.MAX_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.sub_int_2addr.Main_testB3;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_1 ;sub-int/2addr;Boundary #3;Arguments = Integer.MAX_VALUE, -1
dot.junit.opcodes.sub_int_2addr.Main_testB4;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_1 ;sub-int/2addr;Boundary #4;Arguments = Integer.MIN_VALUE, 1
dot.junit.opcodes.sub_int_2addr.Main_testB5;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_1 ;sub-int/2addr;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.sub_int_2addr.Main_testB6;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_1 ;sub-int/2addr;Boundary #6;Arguments = 0, -Integer.MIN_VALUE
dot.junit.opcodes.sub_int_2addr.Main_testB7;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_1 ;sub-int/2addr;Boundary #7;Arguments = Integer.MAX_VALUE, 1
dot.junit.opcodes.sub_int_2addr.Main_testB8;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_1 ;sub-int/2addr;Boundary #8;Arguments = 1, Integer.MIN_VALUE
dot.junit.opcodes.sub_int_2addr.Main_testB9;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_1 ;sub-int/2addr;Boundary #9;Arguments = Integer.MAX_VALUE, Integer.MIN_VALUE
dot.junit.opcodes.sub_int_2addr.Main_testN1;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_1 ;sub-int/2addr;Normal #1;Arguments = 8, 4
dot.junit.opcodes.sub_int_2addr.Main_testN2;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_1 ;sub-int/2addr;Normal #2;Arguments = 0, 255
dot.junit.opcodes.sub_int_2addr.Main_testN3;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_1 ;sub-int/2addr;Normal #3;Arguments = 0, -65536
dot.junit.opcodes.sub_int_2addr.Main_testN4;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_1 ;sub-int/2addr;Normal #4;Arguments = 0, -2147483647
dot.junit.opcodes.sub_int_2addr.Main_testN5;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_5 ;sub-int/2addr;Normal #5;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this subtraction of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.sub_int_2addr.Main_testVFE2;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_2 ;sub-int/2addr;Verifier #2; Constraint B1, types of arguments - int, double
dot.junit.opcodes.sub_int_2addr.Main_testVFE3;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_3 ;sub-int/2addr;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.sub_int_2addr.Main_testVFE4;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_4 ;sub-int/2addr;Verifier #4; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.sub_int_2addr.Main_testVFE5;dot.junit.opcodes.sub_int_2addr.d.T_sub_int_2addr_6 ;sub-int/2addr;Verifier #5; Constraint A23, number of registers
dot.junit.opcodes.sub_int.Main_testB1;dot.junit.opcodes.sub_int.d.T_sub_int_1 ;sub-int;Boundary #1;Arguments = 0, Integer.MAX_VALUE
dot.junit.opcodes.sub_int.Main_testB2;dot.junit.opcodes.sub_int.d.T_sub_int_1 ;sub-int;Boundary #2;Arguments = Integer.MAX_VALUE, Integer.MAX_VALUE
dot.junit.opcodes.sub_int.Main_testB3;dot.junit.opcodes.sub_int.d.T_sub_int_1 ;sub-int;Boundary #3;Arguments = Integer.MAX_VALUE, -1
dot.junit.opcodes.sub_int.Main_testB4;dot.junit.opcodes.sub_int.d.T_sub_int_1 ;sub-int;Boundary #4;Arguments = Integer.MIN_VALUE, 1
dot.junit.opcodes.sub_int.Main_testB5;dot.junit.opcodes.sub_int.d.T_sub_int_1 ;sub-int;Boundary #5;Arguments = 0, 0
dot.junit.opcodes.sub_int.Main_testB6;dot.junit.opcodes.sub_int.d.T_sub_int_1 ;sub-int;Boundary #6;Arguments = 0, -Integer.MIN_VALUE
dot.junit.opcodes.sub_int.Main_testB7;dot.junit.opcodes.sub_int.d.T_sub_int_1 ;sub-int;Boundary #7;Arguments = Integer.MAX_VALUE, 1
dot.junit.opcodes.sub_int.Main_testB8;dot.junit.opcodes.sub_int.d.T_sub_int_1 ;sub-int;Boundary #8;Arguments = 1, Integer.MIN_VALUE
dot.junit.opcodes.sub_int.Main_testB9;dot.junit.opcodes.sub_int.d.T_sub_int_1 ;sub-int;Boundary #9;Arguments = Integer.MAX_VALUE, Integer.MIN_VALUE
dot.junit.opcodes.sub_int.Main_testN1;dot.junit.opcodes.sub_int.d.T_sub_int_1 ;sub-int;Normal #1;Arguments = 8, 4
dot.junit.opcodes.sub_int.Main_testN2;dot.junit.opcodes.sub_int.d.T_sub_int_1 ;sub-int;Normal #2;Arguments = 0, 255
dot.junit.opcodes.sub_int.Main_testN3;dot.junit.opcodes.sub_int.d.T_sub_int_1 ;sub-int;Normal #3;Arguments = 0, -65536
dot.junit.opcodes.sub_int.Main_testN4;dot.junit.opcodes.sub_int.d.T_sub_int_1 ;sub-int;Normal #4;Arguments = 0, -2147483647
dot.junit.opcodes.sub_int.Main_testN5;dot.junit.opcodes.sub_int.d.T_sub_int_5 ;sub-int;Normal #5;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this subtraction of float and int makes no sense but shall not crash the VM.
dot.junit.opcodes.sub_int.Main_testVFE2;dot.junit.opcodes.sub_int.d.T_sub_int_2 ;sub-int;Verifier #2; Constraint B1, types of arguments - int, double
dot.junit.opcodes.sub_int.Main_testVFE3;dot.junit.opcodes.sub_int.d.T_sub_int_3 ;sub-int;Verifier #3; Constraint B1, types of arguments - long, int
dot.junit.opcodes.sub_int.Main_testVFE4;dot.junit.opcodes.sub_int.d.T_sub_int_4 ;sub-int;Verifier #4; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.sub_int.Main_testVFE5;dot.junit.opcodes.sub_int.d.T_sub_int_6 ;sub-int;Verifier #5; Constraint A23, number of registers
dot.junit.opcodes.sub_long_2addr.Main_testB1;dot.junit.opcodes.sub_long_2addr.d.T_sub_long_2addr_1 ;sub-long/2addr;Boundary #1;Arguments = 0l, Long.MAX_VALUE
dot.junit.opcodes.sub_long_2addr.Main_testB2;dot.junit.opcodes.sub_long_2addr.d.T_sub_long_2addr_1 ;sub-long/2addr;Boundary #2;Arguments = 9223372036854775807L, Long.MAX_VALUE
dot.junit.opcodes.sub_long_2addr.Main_testB3;dot.junit.opcodes.sub_long_2addr.d.T_sub_long_2addr_1 ;sub-long/2addr;Boundary #3;Arguments = Long.MAX_VALUE, -1l
dot.junit.opcodes.sub_long_2addr.Main_testB4;dot.junit.opcodes.sub_long_2addr.d.T_sub_long_2addr_1 ;sub-long/2addr;Boundary #4;Arguments = Long.MIN_VALUE, 1l
dot.junit.opcodes.sub_long_2addr.Main_testB5;dot.junit.opcodes.sub_long_2addr.d.T_sub_long_2addr_1 ;sub-long/2addr;Boundary #5;Arguments = 0l, 0l
dot.junit.opcodes.sub_long_2addr.Main_testB6;dot.junit.opcodes.sub_long_2addr.d.T_sub_long_2addr_1 ;sub-long/2addr;Boundary #6;Arguments = 0l, -Long.MIN_VALUE
dot.junit.opcodes.sub_long_2addr.Main_testN1;dot.junit.opcodes.sub_long_2addr.d.T_sub_long_2addr_1 ;sub-long/2addr;Normal #1;Arguments = 1111127348242l, 11111111114l
dot.junit.opcodes.sub_long_2addr.Main_testN2;dot.junit.opcodes.sub_long_2addr.d.T_sub_long_2addr_1 ;sub-long/2addr;Normal #2;Arguments = 0, 1111127348242l
dot.junit.opcodes.sub_long_2addr.Main_testN3;dot.junit.opcodes.sub_long_2addr.d.T_sub_long_2addr_1 ;sub-long/2addr;Normal #3;Arguments = 0, -11111111114l
dot.junit.opcodes.sub_long_2addr.Main_testN4;dot.junit.opcodes.sub_long_2addr.d.T_sub_long_2addr_2 ;sub-long/2addr;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this subtraction of double and long makes no sense but shall not crash the VM.
dot.junit.opcodes.sub_long_2addr.Main_testVFE1;dot.junit.opcodes.sub_long_2addr.d.T_sub_long_2addr_6 ;sub-long/2addr;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.sub_long_2addr.Main_testVFE3;dot.junit.opcodes.sub_long_2addr.d.T_sub_long_2addr_3 ;sub-long/2addr;Verifier #3; Constraint B1, types of arguments - int, long
dot.junit.opcodes.sub_long_2addr.Main_testVFE4;dot.junit.opcodes.sub_long_2addr.d.T_sub_long_2addr_4 ;sub-long/2addr;Verifier #4; Constraint B1, types of arguments - long, float
dot.junit.opcodes.sub_long_2addr.Main_testVFE5;dot.junit.opcodes.sub_long_2addr.d.T_sub_long_2addr_5 ;sub-long/2addr;Verifier #5; Constraint B1, types of arguments - long, reference
dot.junit.opcodes.sub_long.Main_testB1;dot.junit.opcodes.sub_long.d.T_sub_long_1 ;sub-long;Boundary #1;Arguments = 0l, Long.MAX_VALUE
dot.junit.opcodes.sub_long.Main_testB2;dot.junit.opcodes.sub_long.d.T_sub_long_1 ;sub-long;Boundary #2;Arguments = 9223372036854775807L, Long.MAX_VALUE
dot.junit.opcodes.sub_long.Main_testB3;dot.junit.opcodes.sub_long.d.T_sub_long_1 ;sub-long;Boundary #3;Arguments = Long.MAX_VALUE, -1l
dot.junit.opcodes.sub_long.Main_testB4;dot.junit.opcodes.sub_long.d.T_sub_long_1 ;sub-long;Boundary #4;Arguments = Long.MIN_VALUE, 1l
dot.junit.opcodes.sub_long.Main_testB5;dot.junit.opcodes.sub_long.d.T_sub_long_1 ;sub-long;Boundary #5;Arguments = 0l, 0l
dot.junit.opcodes.sub_long.Main_testB6;dot.junit.opcodes.sub_long.d.T_sub_long_1 ;sub-long;Boundary #6;Arguments = 0l, -Long.MIN_VALUE
dot.junit.opcodes.sub_long.Main_testN1;dot.junit.opcodes.sub_long.d.T_sub_long_1 ;sub-long;Normal #1;Arguments = 1111127348242l, 11111111114l
dot.junit.opcodes.sub_long.Main_testN2;dot.junit.opcodes.sub_long.d.T_sub_long_1 ;sub-long;Normal #2;Arguments = 0, 1111127348242l
dot.junit.opcodes.sub_long.Main_testN3;dot.junit.opcodes.sub_long.d.T_sub_long_1 ;sub-long;Normal #3;Arguments = 0, -11111111114l
dot.junit.opcodes.sub_long.Main_testN4;dot.junit.opcodes.sub_long.d.T_sub_long_2 ;sub-long;Normal #4;Types of arguments - long, double. Dalvik doens't distinguish 64-bits types internally, so this subtraction of double and long makes no sense but shall not crash the VM.
dot.junit.opcodes.sub_long.Main_testVFE1;dot.junit.opcodes.sub_long.d.T_sub_long_6 ;sub-long;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.sub_long.Main_testVFE2;dot.junit.opcodes.sub_long.d.T_sub_long_3 ;sub-long;Verifier #2; Constraint B1, types of arguments - int, long
dot.junit.opcodes.sub_long.Main_testVFE3;dot.junit.opcodes.sub_long.d.T_sub_long_4 ;sub-long;Verifier #3; Constraint B1, types of arguments - long, float
dot.junit.opcodes.sub_long.Main_testVFE4;dot.junit.opcodes.sub_long.d.T_sub_long_5 ;sub-long;Verifier #4; Constraint B1, types of arguments - long, reference
dot.junit.opcodes.ushr_int_2addr.Main_testB1;dot.junit.opcodes.ushr_int_2addr.d.T_ushr_int_2addr_1 ;ushr-int/2addr;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.ushr_int_2addr.Main_testB2;dot.junit.opcodes.ushr_int_2addr.d.T_ushr_int_2addr_1 ;ushr-int/2addr;Boundary #2;Arguments = Integer.MAX_VALUE & 1
dot.junit.opcodes.ushr_int_2addr.Main_testB3;dot.junit.opcodes.ushr_int_2addr.d.T_ushr_int_2addr_1 ;ushr-int/2addr;Boundary #3;Arguments = Integer.MIN_VALUE & 1
dot.junit.opcodes.ushr_int_2addr.Main_testB4;dot.junit.opcodes.ushr_int_2addr.d.T_ushr_int_2addr_1 ;ushr-int/2addr;Boundary #4;Arguments = 1 & 0
dot.junit.opcodes.ushr_int_2addr.Main_testN1;dot.junit.opcodes.ushr_int_2addr.d.T_ushr_int_2addr_1 ;ushr-int/2addr;Normal #1;15 >> 1
dot.junit.opcodes.ushr_int_2addr.Main_testN2;dot.junit.opcodes.ushr_int_2addr.d.T_ushr_int_2addr_1 ;ushr-int/2addr;Normal #2;33 >> 2
dot.junit.opcodes.ushr_int_2addr.Main_testN3;dot.junit.opcodes.ushr_int_2addr.d.T_ushr_int_2addr_1 ;ushr-int/2addr;Normal #3;-15 >> 1
dot.junit.opcodes.ushr_int_2addr.Main_testN4;dot.junit.opcodes.ushr_int_2addr.d.T_ushr_int_2addr_1 ;ushr-int/2addr;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.ushr_int_2addr.Main_testN5;dot.junit.opcodes.ushr_int_2addr.d.T_ushr_int_2addr_1 ;ushr-int/2addr;Normal #5;Verify that shift distance is actually in range 0 to 32.
dot.junit.opcodes.ushr_int_2addr.Main_testN6;dot.junit.opcodes.ushr_int_2addr.d.T_ushr_int_2addr_5 ;ushr-int/2addr;Normal #6;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this (int >>> float) makes no sense but shall not crash the VM.
dot.junit.opcodes.ushr_int_2addr.Main_testVFE1;dot.junit.opcodes.ushr_int_2addr.d.T_ushr_int_2addr_2 ;ushr-int/2addr;Verifier #1; Constraint B1, types of arguments - double, int
dot.junit.opcodes.ushr_int_2addr.Main_testVFE2;dot.junit.opcodes.ushr_int_2addr.d.T_ushr_int_2addr_3 ;ushr-int/2addr;Verifier #2; Constraint B1, types of arguments - int, long
dot.junit.opcodes.ushr_int_2addr.Main_testVFE3;dot.junit.opcodes.ushr_int_2addr.d.T_ushr_int_2addr_4 ;ushr-int/2addr;Verifier #3; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.ushr_int_2addr.Main_testVFE4;dot.junit.opcodes.ushr_int_2addr.d.T_ushr_int_2addr_6 ;ushr-int/2addr;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.ushr_int_lit8.Main_testB1;dot.junit.opcodes.ushr_int_lit8.d.T_ushr_int_lit8_6 ;ushr-int/lit8;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.ushr_int_lit8.Main_testB2;dot.junit.opcodes.ushr_int_lit8.d.T_ushr_int_lit8_7 ;ushr-int/lit8;Boundary #2;Arguments = Integer.MAX_VALUE & 1
dot.junit.opcodes.ushr_int_lit8.Main_testB3;dot.junit.opcodes.ushr_int_lit8.d.T_ushr_int_lit8_8 ;ushr-int/lit8;Boundary #3;Arguments = Integer.MIN_VALUE & 1
dot.junit.opcodes.ushr_int_lit8.Main_testB4;dot.junit.opcodes.ushr_int_lit8.d.T_ushr_int_lit8_9 ;ushr-int/lit8;Boundary #4;Arguments = 1 & 0
dot.junit.opcodes.ushr_int_lit8.Main_testN1;dot.junit.opcodes.ushr_int_lit8.d.T_ushr_int_lit8_1 ;ushr-int/lit8;Normal #1;15 >> 1
dot.junit.opcodes.ushr_int_lit8.Main_testN2;dot.junit.opcodes.ushr_int_lit8.d.T_ushr_int_lit8_2 ;ushr-int/lit8;Normal #2;33 >> 2
dot.junit.opcodes.ushr_int_lit8.Main_testN3;dot.junit.opcodes.ushr_int_lit8.d.T_ushr_int_lit8_3 ;ushr-int/lit8;Normal #3;-15 >> 1
dot.junit.opcodes.ushr_int_lit8.Main_testN4;dot.junit.opcodes.ushr_int_lit8.d.T_ushr_int_lit8_4 ;ushr-int/lit8;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.ushr_int_lit8.Main_testN5;dot.junit.opcodes.ushr_int_lit8.d.T_ushr_int_lit8_5 ;ushr-int/lit8;Normal #5;Verify that shift distance is actually in range 0 to 32.
dot.junit.opcodes.ushr_int_lit8.Main_testN6;dot.junit.opcodes.ushr_int_lit8.d.T_ushr_int_lit8_13 ;ushr-int/lit8;Normal #6;Type of argument - float. Dalvik doens't distinguish 32-bits types internally, so this (float >>> ) makes no sense but shall not crash the VM.
dot.junit.opcodes.ushr_int_lit8.Main_testVFE1;dot.junit.opcodes.ushr_int_lit8.d.T_ushr_int_lit8_10 ;ushr-int/lit8;Verifier #1; Constraint B1, types of arguments - double, int
dot.junit.opcodes.ushr_int_lit8.Main_testVFE2;dot.junit.opcodes.ushr_int_lit8.d.T_ushr_int_lit8_11 ;ushr-int/lit8;Verifier #2; Constraint B1, types of arguments - long, int
dot.junit.opcodes.ushr_int_lit8.Main_testVFE3;dot.junit.opcodes.ushr_int_lit8.d.T_ushr_int_lit8_12 ;ushr-int/lit8;Verifier #3; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.ushr_int_lit8.Main_testVFE4;dot.junit.opcodes.ushr_int_lit8.d.T_ushr_int_lit8_14 ;ushr-int/lit8;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.ushr_int.Main_testB1;dot.junit.opcodes.ushr_int.d.T_ushr_int_1 ;ushr-int;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.ushr_int.Main_testB2;dot.junit.opcodes.ushr_int.d.T_ushr_int_1 ;ushr-int;Boundary #2;Arguments = Integer.MAX_VALUE & 1
dot.junit.opcodes.ushr_int.Main_testB3;dot.junit.opcodes.ushr_int.d.T_ushr_int_1 ;ushr-int;Boundary #3;Arguments = Integer.MIN_VALUE & 1
dot.junit.opcodes.ushr_int.Main_testB4;dot.junit.opcodes.ushr_int.d.T_ushr_int_1 ;ushr-int;Boundary #4;Arguments = 1 & 0
dot.junit.opcodes.ushr_int.Main_testN1;dot.junit.opcodes.ushr_int.d.T_ushr_int_1 ;ushr-int;Normal #1;15 >> 1
dot.junit.opcodes.ushr_int.Main_testN2;dot.junit.opcodes.ushr_int.d.T_ushr_int_1 ;ushr-int;Normal #2;33 >> 2
dot.junit.opcodes.ushr_int.Main_testN3;dot.junit.opcodes.ushr_int.d.T_ushr_int_1 ;ushr-int;Normal #3;-15 >> 1
dot.junit.opcodes.ushr_int.Main_testN4;dot.junit.opcodes.ushr_int.d.T_ushr_int_1 ;ushr-int;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.ushr_int.Main_testN5;dot.junit.opcodes.ushr_int.d.T_ushr_int_1 ;ushr-int;Normal #5;Verify that shift distance is actually in range 0 to 32.
dot.junit.opcodes.ushr_int.Main_testN6;dot.junit.opcodes.ushr_int.d.T_ushr_int_5 ;ushr-int;Normal #6;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this (int >>> float) makes no sense but shall not crash the VM.
dot.junit.opcodes.ushr_int.Main_testVFE1;dot.junit.opcodes.ushr_int.d.T_ushr_int_2 ;ushr-int;Verifier #1; Constraint B1, types of arguments - double, int
dot.junit.opcodes.ushr_int.Main_testVFE2;dot.junit.opcodes.ushr_int.d.T_ushr_int_3 ;ushr-int;Verifier #2; Constraint B1, types of arguments - int, long
dot.junit.opcodes.ushr_int.Main_testVFE3;dot.junit.opcodes.ushr_int.d.T_ushr_int_4 ;ushr-int;Verifier #3; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.ushr_int.Main_testVFE4;dot.junit.opcodes.ushr_int.d.T_ushr_int_6 ;ushr-int;Verifier #4; Constraint A23, number of registers
dot.junit.opcodes.ushr_long_2addr.Main_testB1;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_1 ;ushr-long/2addr;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.ushr_long_2addr.Main_testB2;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_1 ;ushr-long/2addr;Boundary #2;Arguments = Long.MAX_VALUE & 1
dot.junit.opcodes.ushr_long_2addr.Main_testB3;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_1 ;ushr-long/2addr;Boundary #3;Arguments = Long.MIN_VALUE & 1
dot.junit.opcodes.ushr_long_2addr.Main_testB4;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_1 ;ushr-long/2addr;Boundary #4;Arguments = 1 & 0
dot.junit.opcodes.ushr_long_2addr.Main_testN1;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_1 ;ushr-long/2addr;Normal #1;Arguments =  40000000000l, 3
dot.junit.opcodes.ushr_long_2addr.Main_testN2;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_1 ;ushr-long/2addr;Normal #2;Arguments = 40000000000l, 1
dot.junit.opcodes.ushr_long_2addr.Main_testN3;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_1 ;ushr-long/2addr;Normal #3;Arguments = -123456789l, 1
dot.junit.opcodes.ushr_long_2addr.Main_testN4;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_1 ;ushr-long/2addr;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.ushr_long_2addr.Main_testN5;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_1 ;ushr-long/2addr;Normal #5;Arguments = 123456789l, 64
dot.junit.opcodes.ushr_long_2addr.Main_testN6;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_1 ;ushr-long/2addr;Normal #6;Arguments = 123456789l, 63
dot.junit.opcodes.ushr_long_2addr.Main_testN7;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_2 ;ushr-long/2addr;Normal #7;Types of arguments - double, int. Dalvik doens't distinguish 64-bits types internally, so this (double >>> int) makes no sense but shall not crash the VM.
dot.junit.opcodes.ushr_long_2addr.Main_testVFE1;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_6 ;ushr-long/2addr;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.ushr_long_2addr.Main_testVFE2;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_7 ;ushr-long/2addr;Verifier #2; Constraint B1, types of arguments - long, double
dot.junit.opcodes.ushr_long_2addr.Main_testVFE3;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_3 ;ushr-long/2addr;Verifier #3; Constraint B1, types of arguments - int, int
dot.junit.opcodes.ushr_long_2addr.Main_testVFE4;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_4 ;ushr-long/2addr;Verifier #4; Constraint B1, types of arguments - float, int
dot.junit.opcodes.ushr_long_2addr.Main_testVFE5;dot.junit.opcodes.ushr_long_2addr.d.T_ushr_long_2addr_5 ;ushr-long/2addr;Verifier #5; Constraint B1, types of arguments - long, reference
dot.junit.opcodes.ushr_long.Main_testB1;dot.junit.opcodes.ushr_long.d.T_ushr_long_1 ;ushr-long;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.ushr_long.Main_testB2;dot.junit.opcodes.ushr_long.d.T_ushr_long_1 ;ushr-long;Boundary #2;Arguments = Long.MAX_VALUE & 1
dot.junit.opcodes.ushr_long.Main_testB3;dot.junit.opcodes.ushr_long.d.T_ushr_long_1 ;ushr-long;Boundary #3;Arguments = Long.MIN_VALUE & 1
dot.junit.opcodes.ushr_long.Main_testB4;dot.junit.opcodes.ushr_long.d.T_ushr_long_1 ;ushr-long;Boundary #4;Arguments = 1 & 0
dot.junit.opcodes.ushr_long.Main_testN1;dot.junit.opcodes.ushr_long.d.T_ushr_long_1 ;ushr-long;Normal #1;Arguments = 40000000000l, 3
dot.junit.opcodes.ushr_long.Main_testN2;dot.junit.opcodes.ushr_long.d.T_ushr_long_1 ;ushr-long;Normal #2;Arguments = 40000000000l, 1
dot.junit.opcodes.ushr_long.Main_testN3;dot.junit.opcodes.ushr_long.d.T_ushr_long_1 ;ushr-long;Normal #3;Arguments = -123456789l, 1
dot.junit.opcodes.ushr_long.Main_testN4;dot.junit.opcodes.ushr_long.d.T_ushr_long_1 ;ushr-long;Normal #4;Arguments = 1 & -1
dot.junit.opcodes.ushr_long.Main_testN5;dot.junit.opcodes.ushr_long.d.T_ushr_long_1 ;ushr-long;Normal #5;Arguments = 123456789l, 64
dot.junit.opcodes.ushr_long.Main_testN6;dot.junit.opcodes.ushr_long.d.T_ushr_long_1 ;ushr-long;Normal #6;Arguments = 123456789l, 63
dot.junit.opcodes.ushr_long.Main_testN7;dot.junit.opcodes.ushr_long.d.T_ushr_long_2 ;ushr-long;Normal #7;Types of arguments - double, int. Dalvik doens't distinguish 64-bits types internally, so this (double >>> int) makes no sense but shall not crash the VM.
dot.junit.opcodes.ushr_long.Main_testVFE1;dot.junit.opcodes.ushr_long.d.T_ushr_long_6 ;ushr-long;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.ushr_long.Main_testVFE2;dot.junit.opcodes.ushr_long.d.T_ushr_long_7 ;ushr-long;Verifier #2; Constraint B1, types of arguments - long, double
dot.junit.opcodes.ushr_long.Main_testVFE3;dot.junit.opcodes.ushr_long.d.T_ushr_long_3 ;ushr-long;Verifier #3; Constraint B1, types of arguments - int, int
dot.junit.opcodes.ushr_long.Main_testVFE4;dot.junit.opcodes.ushr_long.d.T_ushr_long_4 ;ushr-long;Verifier #4; Constraint B1, types of arguments - float, int
dot.junit.opcodes.ushr_long.Main_testVFE5;dot.junit.opcodes.ushr_long.d.T_ushr_long_5 ;ushr-long;Verifier #5; Constraint B1, types of arguments - long, reference
dot.junit.opcodes.xor_int_2addr.Main_testB1;dot.junit.opcodes.xor_int_2addr.d.T_xor_int_2addr_1 ;xor-int/2addr;Boundary #1;Arguments = 0, -1
dot.junit.opcodes.xor_int_2addr.Main_testB2;dot.junit.opcodes.xor_int_2addr.d.T_xor_int_2addr_1 ;xor-int/2addr;Boundary #2;Arguments = Integer.MAX_VALUE, Integer.MIN_VALUE
dot.junit.opcodes.xor_int_2addr.Main_testN1;dot.junit.opcodes.xor_int_2addr.d.T_xor_int_2addr_1 ;xor-int/2addr;Normal #1;Arguments = 15, 8
dot.junit.opcodes.xor_int_2addr.Main_testN2;dot.junit.opcodes.xor_int_2addr.d.T_xor_int_2addr_1 ;xor-int/2addr;Normal #2;Arguments = 0xfffffff8, 0xfffffff1
dot.junit.opcodes.xor_int_2addr.Main_testN3;dot.junit.opcodes.xor_int_2addr.d.T_xor_int_2addr_1 ;xor-int/2addr;Normal #3;Arguments = 0xcafe, -1
dot.junit.opcodes.xor_int_2addr.Main_testN4;dot.junit.opcodes.xor_int_2addr.d.T_xor_int_2addr_4 ;xor-int/2addr;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this (int ^ float) makes no sense but shall not crash the VM.
dot.junit.opcodes.xor_int_2addr.Main_testVFE1;dot.junit.opcodes.xor_int_2addr.d.T_xor_int_2addr_2 ;xor-int/2addr;Verifier #1; Constraint B1, types of arguments - long, int
dot.junit.opcodes.xor_int_2addr.Main_testVFE2;dot.junit.opcodes.xor_int_2addr.d.T_xor_int_2addr_3 ;xor-int/2addr;Verifier #2; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.xor_int_2addr.Main_testVFE3;dot.junit.opcodes.xor_int_2addr.d.T_xor_int_2addr_5 ;xor-int/2addr;Verifier #3; Constraint A23, number of registers
dot.junit.opcodes.xor_int_lit16.Main_testB1;dot.junit.opcodes.xor_int_lit16.d.T_xor_int_lit16_3 ;xor-int/lit16;Boundary #1;Arguments = 0, -1
dot.junit.opcodes.xor_int_lit16.Main_testB2;dot.junit.opcodes.xor_int_lit16.d.T_xor_int_lit16_4 ;xor-int/lit16;Boundary #2;Arguments = Integer.MAX_VALUE, Short.MIN_VALUE
dot.junit.opcodes.xor_int_lit16.Main_testN1;dot.junit.opcodes.xor_int_lit16.d.T_xor_int_lit16_1 ;xor-int/lit16;Normal #1;Arguments = 15, 8
dot.junit.opcodes.xor_int_lit16.Main_testN2;dot.junit.opcodes.xor_int_lit16.d.T_xor_int_lit16_2 ;xor-int/lit16;Normal #2;Arguments = 0xfffffff8, 0xfff1
dot.junit.opcodes.xor_int_lit16.Main_testN3;dot.junit.opcodes.xor_int_lit16.d.T_xor_int_lit16_7 ;xor-int/lit16;Normal #3;Type of argument - float. Dalvik doens't distinguish 32-bits types internally, so this (float ^ int) makes no sense but shall not crash the VM.
dot.junit.opcodes.xor_int_lit16.Main_testVFE1;dot.junit.opcodes.xor_int_lit16.d.T_xor_int_lit16_5 ;xor-int/lit16;Verifier #1; Constraint B1, types of arguments - long & int
dot.junit.opcodes.xor_int_lit16.Main_testVFE2;dot.junit.opcodes.xor_int_lit16.d.T_xor_int_lit16_6 ;xor-int/lit16;Verifier #2; Constraint B1, types of arguments - reference & int
dot.junit.opcodes.xor_int_lit16.Main_testVFE3;dot.junit.opcodes.xor_int_lit16.d.T_xor_int_lit16_8 ;xor-int/lit16;Verifier #3; Constraint A23, number of registers
dot.junit.opcodes.xor_int_lit8.Main_testB1;dot.junit.opcodes.xor_int_lit8.d.T_xor_int_lit8_3 ;xor-int/lit8;Boundary #1;Arguments = 0, -1
dot.junit.opcodes.xor_int_lit8.Main_testB2;dot.junit.opcodes.xor_int_lit8.d.T_xor_int_lit8_4 ;xor-int/lit8;Boundary #2;Arguments = Integer.MAX_VALUE, Byte.MIN_VALUE
dot.junit.opcodes.xor_int_lit8.Main_testN1;dot.junit.opcodes.xor_int_lit8.d.T_xor_int_lit8_1 ;xor-int/lit8;Normal #1;Arguments = 15, 8
dot.junit.opcodes.xor_int_lit8.Main_testN2;dot.junit.opcodes.xor_int_lit8.d.T_xor_int_lit8_2 ;xor-int/lit8;Normal #2;Arguments = 0xfffffff8, 0xf1
dot.junit.opcodes.xor_int_lit8.Main_testN3;dot.junit.opcodes.xor_int_lit8.d.T_xor_int_lit8_7 ;xor-int/lit8;Normal #3;Type of argument - float. Dalvik doens't distinguish 32-bits types internally, so this (float ^ int) makes no sense but shall not crash the VM.
dot.junit.opcodes.xor_int_lit8.Main_testVFE1;dot.junit.opcodes.xor_int_lit8.d.T_xor_int_lit8_5 ;xor-int/lit8;Verifier #1; Constraint B1, types of arguments - long, int
dot.junit.opcodes.xor_int_lit8.Main_testVFE2;dot.junit.opcodes.xor_int_lit8.d.T_xor_int_lit8_6 ;xor-int/lit8;Verifier #2; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.xor_int_lit8.Main_testVFE3;dot.junit.opcodes.xor_int_lit8.d.T_xor_int_lit8_8 ;xor-int/lit8;Verifier #3; Constraint A23, number of registers
dot.junit.opcodes.xor_int.Main_testB1;dot.junit.opcodes.xor_int.d.T_xor_int_1 ;xor-int;Boundary #1;Arguments = 0, -1
dot.junit.opcodes.xor_int.Main_testB2;dot.junit.opcodes.xor_int.d.T_xor_int_1 ;xor-int;Boundary #2;Arguments = Integer.MAX_VALUE, Integer.MIN_VALUE
dot.junit.opcodes.xor_int.Main_testN1;dot.junit.opcodes.xor_int.d.T_xor_int_1 ;xor-int;Normal #1;Arguments = 15, 8
dot.junit.opcodes.xor_int.Main_testN2;dot.junit.opcodes.xor_int.d.T_xor_int_1 ;xor-int;Normal #2;Arguments = 0xfffffff8, 0xfffffff1
dot.junit.opcodes.xor_int.Main_testN3;dot.junit.opcodes.xor_int.d.T_xor_int_1 ;xor-int;Normal #3;Arguments = 0xcafe, -1
dot.junit.opcodes.xor_int.Main_testN4;dot.junit.opcodes.xor_int.d.T_xor_int_5 ;xor-int;Normal #4;Types of arguments - int, float. Dalvik doens't distinguish 32-bits types internally, so this (int ^ float) makes no sense but shall not crash the VM.
dot.junit.opcodes.xor_int.Main_testVFE1;dot.junit.opcodes.xor_int.d.T_xor_int_2 ;xor-int;Verifier #1; Constraint B1, types of arguments - long, int
dot.junit.opcodes.xor_int.Main_testVFE2;dot.junit.opcodes.xor_int.d.T_xor_int_3 ;xor-int;Verifier #2; Constraint B1, types of arguments - reference, int
dot.junit.opcodes.xor_int.Main_testVFE3;dot.junit.opcodes.xor_int.d.T_xor_int_6 ;xor-int;Verifier #3; Constraint A23, number of registers
dot.junit.opcodes.xor_long_2addr.Main_testB1;dot.junit.opcodes.xor_long_2addr.d.T_xor_long_2addr_1 ;xor-long/2addr;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.xor_long_2addr.Main_testB2;dot.junit.opcodes.xor_long_2addr.d.T_xor_long_2addr_1 ;xor-long/2addr;Boundary #2;Arguments = Long.MAX_VALUE & Long.MIN_VALUE
dot.junit.opcodes.xor_long_2addr.Main_testB3;dot.junit.opcodes.xor_long_2addr.d.T_xor_long_2addr_1 ;xor-long/2addr;Boundary #3;Arguments = Long.MAX_VALUE & Long.MAX_VALUE
dot.junit.opcodes.xor_long_2addr.Main_testN1;dot.junit.opcodes.xor_long_2addr.d.T_xor_long_2addr_1 ;xor-long/2addr;Normal #1;Arguments = 23423432423777l, 23423432423778l
dot.junit.opcodes.xor_long_2addr.Main_testN2;dot.junit.opcodes.xor_long_2addr.d.T_xor_long_2addr_1 ;xor-long/2addr;Normal #2;Arguments = 0xfffffff5, 0xfffffff1
dot.junit.opcodes.xor_long_2addr.Main_testN3;dot.junit.opcodes.xor_long_2addr.d.T_xor_long_2addr_1 ;xor-long/2addr;Normal #3;Arguments = 0xABCDEFAB & -1
dot.junit.opcodes.xor_long_2addr.Main_testN4;dot.junit.opcodes.xor_long_2addr.d.T_xor_long_2addr_2 ;xor-long/2addr;Normal #4;Types of arguments - double, long. Dalvik doens't distinguish 64-bits types internally, so this (double ^ long ) makes no sense but shall not crash the VM.
dot.junit.opcodes.xor_long_2addr.Main_testVFE1;dot.junit.opcodes.xor_long_2addr.d.T_xor_long_2addr_6 ;xor-long/2addr;Verifier #1; Constraint A24, (number of registers).
dot.junit.opcodes.xor_long_2addr.Main_testVFE2;dot.junit.opcodes.xor_long_2addr.d.T_xor_long_2addr_3 ;xor-long/2addr;Verifier #2; Constraint B1, types of arguments - int, long
dot.junit.opcodes.xor_long_2addr.Main_testVFE3;dot.junit.opcodes.xor_long_2addr.d.T_xor_long_2addr_4 ;xor-long/2addr;Verifier #3; Constraint B1, types of arguments - float, long
dot.junit.opcodes.xor_long_2addr.Main_testVFE4;dot.junit.opcodes.xor_long_2addr.d.T_xor_long_2addr_5 ;xor-long/2addr;Verifier #4; Constraint B1, types of arguments - reference, long
dot.junit.opcodes.xor_long.Main_testB1;dot.junit.opcodes.xor_long.d.T_xor_long_1 ;xor-long;Boundary #1;Arguments = 0 & -1
dot.junit.opcodes.xor_long.Main_testB2;dot.junit.opcodes.xor_long.d.T_xor_long_1 ;xor-long;Boundary #2;Arguments = Long.MAX_VALUE & Long.MIN_VALUE
dot.junit.opcodes.xor_long.Main_testB3;dot.junit.opcodes.xor_long.d.T_xor_long_1 ;xor-long;Boundary #3;Arguments = Long.MAX_VALUE & Long.MAX_VALUE
dot.junit.opcodes.xor_long.Main_testN1;dot.junit.opcodes.xor_long.d.T_xor_long_1 ;xor-long;Normal #1;Arguments = 23423432423777l, 23423432423778l
dot.junit.opcodes.xor_long.Main_testN2;dot.junit.opcodes.xor_long.d.T_xor_long_1 ;xor-long;Normal #2;Arguments = 0xfffffff5, 0xfffffff1
dot.junit.opcodes.xor_long.Main_testN3;dot.junit.opcodes.xor_long.d.T_xor_long_1 ;xor-long;Normal #3;Arguments = 0xABCDEFAB & -1
dot.junit.opcodes.xor_long.Main_testN4;dot.junit.opcodes.xor_long.d.T_xor_long_2 ;xor-long;Normal #4;Types of arguments - double, long. Dalvik doens't distinguish 64-bits types internally, so this (double ^ long ) makes no sense but shall not crash the VM.
dot.junit.opcodes.xor_long.Main_testVFE1;dot.junit.opcodes.xor_long.d.T_xor_long_6 ;xor-long;Verifier #1; Constraint A24, number of registers
dot.junit.opcodes.xor_long.Main_testVFE2;dot.junit.opcodes.xor_long.d.T_xor_long_3 ;xor-long;Verifier #2; Constraint B1, types of arguments - int, long
dot.junit.opcodes.xor_long.Main_testVFE3;dot.junit.opcodes.xor_long.d.T_xor_long_4 ;xor-long;Verifier #3; Constraint B1, types of arguments - float, long
dot.junit.opcodes.xor_long.Main_testVFE4;dot.junit.opcodes.xor_long.d.T_xor_long_5 ;xor-long;Verifier #4; Constraint B1, types of arguments - reference, long
dot.junit.verify.a1.Main_testVFE1;dot.junit.verify.a1.d.T_a1_1 ;verifier;Verifier #1; Constraint A1, empty insns array
dot.junit.verify.a3.Main_testVFE1;dot.junit.verify.a3.d.T_a3_1 ;verifier;Verifier #1; Constraint A3, The insns array must only contain valid Dalvik opcodes.
dot.junit.verify.a5.Main_testVFE1;dot.junit.verify.a5.d.T_a5_1 ;verifier;Verifier #1; Constraint A5, The last instruction in the insns array must end at index insns_size-1.
dot.junit.verify.b2.Main_testVFE1;dot.junit.verify.b2.d.T_b2_1 ;verifier;Verifier #1; Constraint B2, attempt to mess around with register-pairs.
dot.junit.verify.b2.Main_testVFE2;dot.junit.verify.b2.d.T_b2_2 ;verifier;Verifier #2; Constraint B2, attempt to mess around with register-pairs.
dot.junit.verify.b2.Main_testVFE3;dot.junit.verify.b2.d.T_b2_3 ;verifier;Verifier #3; Constraint B2, attempt to mess around with register-pairs.
dot.junit.verify.b2.Main_testVFE4;dot.junit.verify.b2.d.T_b2_4 ;verifier;Verifier #4; Constraint B2, attempt to mess around with register-pairs.
dot.junit.verify.b2.Main_testVFE5;dot.junit.verify.b2.d.T_b2_5 ;verifier;Verifier #5; Constraint B2, attempt to mess around with register-pairs.
dot.junit.verify.b3.Main_testVFE1;dot.junit.verify.b3.d.T_b3_1 ;verifier;Verifier #1; Constraint B3, register (or pair) has to be assigned first before it can be read.
dot.junit.verify.b3.Main_testVFE2;dot.junit.verify.b3.d.T_b3_2 ;verifier;Verifier #2; Constraint B3, register (or pair) has to be assigned first before it can be read.
dot.junit.verify.b17.Main_testVFE1;dot.junit.verify.b17.d.T_b17_1 ;verifier;Verifier #1; Constraint B17, attempt to leave insns array without return or throw. Since this constraint is trivial to be checked by the verifier, it is sufficient to have a trivial test.
dot.junit.format.f1.Main_testVFE1;dot.junit.format.f1.d.T_f1_1 ;format;Verifier #1; Constraint n/a, size of dex file shall be greater than size of header
dot.junit.format.f1.Main_testVFE11;dot.junit.format.f1.d.T_f1_11 ;format;Verifier #11; Constraint n/a, header and map section mismatch
dot.junit.format.f1.Main_testVFE12;dot.junit.format.f1.d.T_f1_12 ;format;Verifier #12; Constraint n/a, overlapping sections
dot.junit.format.f1.Main_testVFE2;dot.junit.format.f1.d.T_f1_2 ;format;Verifier #2; Constraint n/a, check that .dex with wrong magic is rejected
dot.junit.format.f1.Main_testVFE3;dot.junit.format.f1.d.T_f1_3 ;format;Verifier #3; Constraint n/a, check that .dex with wrong version is rejected
dot.junit.format.f1.Main_testVFE4;dot.junit.format.f1.d.T_f1_4 ;format;Verifier #4; Constraint n/a, check that .dex with wrong endian_tag is rejected
dot.junit.format.f1.Main_testVFE5;dot.junit.format.f1.d.T_f1_5 ;format;Verifier #5; Constraint n/a, check that .dex with wrong header size is rejected
dot.junit.format.f1.Main_testVFE6;dot.junit.format.f1.d.T_f1_6 ;format;Verifier #6; Constraint n/a, file length must be equal to length in header
dot.junit.format.f1.Main_testVFE7;dot.junit.format.f1.d.T_f1_7 ;format;Verifier #7; Constraint n/a, header->map_off != 0
dot.junit.format.f1.Main_testVFE8;dot.junit.format.f1.d.T_f1_8 ;format;Verifier #8; Constraint n/a, number of classes in dex shall be > 0
dot.junit.format.f1.Main_testVFE9;dot.junit.format.f1.d.T_f1_9 ;format;Verifier #9; Constraint n/a, check that .dex with wrong checksum is rejected
